<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.1.2">
  <compounddef id="group__MultiMathModule" kind="group">
    <compoundname>MultiMathModule</compoundname>
    <title>vigra::multi_math</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Namespace <computeroutput><ref refid="namespacevigra_1_1multi__math" kindref="compound">vigra::multi_math</ref></computeroutput> holds VIGRA&apos;s support for efficient arithmetic and algebraic functions on multi-dimensional arrays (that is, <ref refid="classvigra_1_1MultiArrayView" kindref="compound">MultiArrayView</ref> and its subclasses). All <computeroutput><ref refid="namespacevigra_1_1multi__math" kindref="compound">multi_math</ref></computeroutput> functions operate element-wise. If you need matrix multiplication, use <ref refid="group__LinearAlgebraModule" kindref="compound">Linear Algebra</ref> instead.</para><para>In order to avoid overload ambiguities, multi-array arithmetic must be explicitly activated by <programlisting><codeline><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal">vigra::multi_math;</highlight></codeline>
</programlisting> (this should not be done globally, but only in the scope where the functionality is actually used).</para><para>You can then use the standard operators in the expected way: <programlisting><codeline><highlight class="normal">MultiArray&lt;2,<sp/>float&gt;<sp/>i(<ref refid="group__MultiIteratorGroup_1ga2e2ffc107bb0e38f9b1288b647c8ec5b" kindref="member" tooltip="shape type for MultiArray&amp;lt;2, T&amp;gt;">Shape2</ref>(100,<sp/>100)),<sp/>j(<ref refid="group__MultiIteratorGroup_1ga2e2ffc107bb0e38f9b1288b647c8ec5b" kindref="member" tooltip="shape type for MultiArray&amp;lt;2, T&amp;gt;">Shape2</ref>(100,<sp/>100));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">MultiArray&lt;2,<sp/>float&gt;<sp/>h<sp/><sp/>=<sp/>i<sp/>+<sp/>4.0<sp/>*<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>h<sp/>+=<sp/>(i.transpose()<sp/>-<sp/>j)<sp/>/<sp/>2.0;</highlight></codeline>
</programlisting> etc. (supported operators are <computeroutput>+ - * / ! ~ % &amp;&amp; || == != &lt; &lt;= &gt; &gt;= &lt;&lt; &gt;&gt; &amp; | ^ = += -= *= /=</computeroutput>, with both scalar and array arguments).</para><para>Algebraic functions are available as well: <programlisting><codeline><highlight class="normal">h<sp/><sp/>=<sp/><ref refid="group__LinearAlgebraFunctions_1ga2a9e01ae7ae7b39a618e9f4a6afaee5b" kindref="member">exp</ref>(-(<ref refid="group__MathFunctions_1ga5fe62e7b0dc6f379dd436c9c8338c93e" kindref="member">sq</ref>(i)<sp/>+<sp/><ref refid="group__MathFunctions_1ga5fe62e7b0dc6f379dd436c9c8338c93e" kindref="member">sq</ref>(j)));</highlight></codeline>
<codeline><highlight class="normal">h<sp/>*=<sp/><ref refid="group__FixedPoint16Operations_1gae83e1ae2e3dae6dc462c69a7c8175fc5" kindref="member" tooltip="Arctangent. Accuracy better than 1/3 degree (9 significant bits).">atan2</ref>(-i,<sp/>j);</highlight></codeline>
</programlisting> The following functions are implemented: <computeroutput>abs, erf, even, odd, sign, signi, round, roundi, sqrt, sqrti, sq, norm, squaredNorm, gamma, loggamma, exp, log, log10, sin, sin_pi, cos, cos_pi, asin, acos, tan, atan, floor, ceil, conj, real, imag, arg, atan2, pow, fmod, min, max</computeroutput>, provided the array&apos;s element type supports the respective function.</para><para>Supported element types currently include the built-in numeric types, <ref refid="classvigra_1_1TinyVector" kindref="compound">TinyVector</ref>, <ref refid="classvigra_1_1RGBValue" kindref="compound">RGBValue</ref>, <computeroutput>std::complex</computeroutput>, and <ref refid="classvigra_1_1FFTWComplex" kindref="compound">FFTWComplex</ref>.</para><para>In addition, <computeroutput><ref refid="namespacevigra_1_1multi__math" kindref="compound">multi_math</ref></computeroutput> supports a number of functions that reduce arrays to scalars: <programlisting><codeline><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>s<sp/>=<sp/>sum&lt;double&gt;(i);<sp/><sp/></highlight><highlight class="comment">//<sp/>compute<sp/>the<sp/>sum<sp/>of<sp/>the<sp/>elements,<sp/>using<sp/>&apos;double&apos;<sp/>as<sp/>accumulator<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>p<sp/>=<sp/>product&lt;double&gt;(<ref refid="group__FFTWComplexOperators_1ga6f4ef274842b6153923f02a6cd264576" kindref="member" tooltip="absolute value (= magnitude)">abs</ref>(i));<sp/><sp/></highlight><highlight class="comment">//<sp/>compute<sp/>the<sp/>product<sp/>of<sp/>the<sp/>elements&apos;<sp/>absolute<sp/>values</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>a<sp/>=<sp/>any(i<sp/>&lt;<sp/>0.0);<sp/><sp/></highlight><highlight class="comment">//<sp/>check<sp/>if<sp/>any<sp/>element<sp/>of<sp/>i<sp/>is<sp/>negative</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>b<sp/>=<sp/>all(i<sp/>&gt;<sp/>0.0);<sp/><sp/></highlight><highlight class="comment">//<sp/>check<sp/>if<sp/>all<sp/>elements<sp/>of<sp/>i<sp/>are<sp/>positive</highlight></codeline>
</programlisting></para><para>Expressions are expanded so that no temporary arrays have to be created. To optimize cache locality, loops are executed in the stride ordering of the left-hand-side array.</para><para><bold>#include</bold> &lt;<ref refid="multi__math_8hxx_source" kindref="compound">vigra/multi_math.hxx</ref>&gt;</para><para>Namespace: <ref refid="namespacevigra_1_1multi__math" kindref="compound">vigra::multi_math</ref> </para>    </detaileddescription>
  </compounddef>
</doxygen>
