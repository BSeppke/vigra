<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - vigra/accumulator.hxx Source File</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{ 
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://hci.iwr.uni-heidelberg.de/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="contents">
<table class="main_heading">
<tr>
<td width="100%">vigra/accumulator.hxx
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/************************************************************************/</span>
<a name="l00002"></a>00002 <span class="comment">/*                                                                      */</span>
<a name="l00003"></a>00003 <span class="comment">/*               Copyright 2011-2012 by Ullrich Koethe                  */</span>
<a name="l00004"></a>00004 <span class="comment">/*                                                                      */</span>
<a name="l00005"></a>00005 <span class="comment">/*    This file is part of the VIGRA computer vision library.           */</span>
<a name="l00006"></a>00006 <span class="comment">/*    The VIGRA Website is                                              */</span>
<a name="l00007"></a>00007 <span class="comment">/*        http://hci.iwr.uni-heidelberg.de/vigra/                       */</span>
<a name="l00008"></a>00008 <span class="comment">/*    Please direct questions, bug reports, and contributions to        */</span>
<a name="l00009"></a>00009 <span class="comment">/*        ullrich.koethe@iwr.uni-heidelberg.de    or                    */</span>
<a name="l00010"></a>00010 <span class="comment">/*        vigra@informatik.uni-hamburg.de                               */</span>
<a name="l00011"></a>00011 <span class="comment">/*                                                                      */</span>
<a name="l00012"></a>00012 <span class="comment">/*    Permission is hereby granted, free of charge, to any person       */</span>
<a name="l00013"></a>00013 <span class="comment">/*    obtaining a copy of this software and associated documentation    */</span>
<a name="l00014"></a>00014 <span class="comment">/*    files (the &quot;Software&quot;), to deal in the Software without           */</span>
<a name="l00015"></a>00015 <span class="comment">/*    restriction, including without limitation the rights to use,      */</span>
<a name="l00016"></a>00016 <span class="comment">/*    copy, modify, merge, publish, distribute, sublicense, and/or      */</span>
<a name="l00017"></a>00017 <span class="comment">/*    sell copies of the Software, and to permit persons to whom the    */</span>
<a name="l00018"></a>00018 <span class="comment">/*    Software is furnished to do so, subject to the following          */</span>
<a name="l00019"></a>00019 <span class="comment">/*    conditions:                                                       */</span>
<a name="l00020"></a>00020 <span class="comment">/*                                                                      */</span>
<a name="l00021"></a>00021 <span class="comment">/*    The above copyright notice and this permission notice shall be    */</span>
<a name="l00022"></a>00022 <span class="comment">/*    included in all copies or substantial portions of the             */</span>
<a name="l00023"></a>00023 <span class="comment">/*    Software.                                                         */</span>
<a name="l00024"></a>00024 <span class="comment">/*                                                                      */</span>
<a name="l00025"></a>00025 <span class="comment">/*    THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND    */</span>
<a name="l00026"></a>00026 <span class="comment">/*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES   */</span>
<a name="l00027"></a>00027 <span class="comment">/*    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND          */</span>
<a name="l00028"></a>00028 <span class="comment">/*    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT       */</span>
<a name="l00029"></a>00029 <span class="comment">/*    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,      */</span>
<a name="l00030"></a>00030 <span class="comment">/*    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING      */</span>
<a name="l00031"></a>00031 <span class="comment">/*    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR     */</span>
<a name="l00032"></a>00032 <span class="comment">/*    OTHER DEALINGS IN THE SOFTWARE.                                   */</span>
<a name="l00033"></a>00033 <span class="comment">/*                                                                      */</span>
<a name="l00034"></a>00034 <span class="comment">/************************************************************************/</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="preprocessor">#ifndef VIGRA_ACCUMULATOR_HXX</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="preprocessor">#define VIGRA_ACCUMULATOR_HXX</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span>
<a name="l00039"></a>00039 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span><span class="preprocessor">#pragma warning (disable: 4503)</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;accumulator-grammar.hxx&quot;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;config.hxx&quot;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;metaprogramming.hxx&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;bit_array.hxx&quot;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;static_assert.hxx&quot;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;mathutil.hxx&quot;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &quot;utilities.hxx&quot;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;multi_iterator_coupled.hxx&quot;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &quot;matrix.hxx&quot;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &quot;multi_math.hxx&quot;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &quot;eigensystem.hxx&quot;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &quot;histogram.hxx&quot;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="keyword">namespace </span>vigra {
<a name="l00059"></a>00059   <span class="comment"></span>
<a name="l00060"></a>00060 <span class="comment">/** \defgroup FeatureAccumulators Feature Accumulators</span>
<a name="l00061"></a>00061 <span class="comment"></span>
<a name="l00062"></a>00062 <span class="comment">The namespace &lt;tt&gt;vigra::acc&lt;/tt&gt; provides the function \ref vigra::acc::extractFeatures() along with associated statistics functors and accumulator classes. Together, they provide a framework for efficient compution of a wide variety of statistical features, both globally for an entire image, and locally for each region defined by a label array. Many different statistics can be composed out of a small number of fundamental statistics and suitable modifiers. The user simply selects the desired statistics by means of their &lt;i&gt;tags&lt;/i&gt; (see below), and a template meta-program automatically generates an efficient functor that computes exactly those statistics.</span>
<a name="l00063"></a>00063 <span class="comment"></span>
<a name="l00064"></a>00064 <span class="comment">The function \ref acc::extractFeatures() &quot;extractFeatures()&quot; scans the data in as few passes as the selected statstics permit (usually one or two passes are sufficient). Statistics are computed by accurate incremental algorithms, whose internal state is maintained by accumulator objects. The state is updated by passing data to the accumulator one sample at a time. Accumulators are grouped within an accumulator chain. Dependencies between accumulators in the accumulator chain are automatically resolved and missing dependencies are inserted. For example, to compute the mean, you also need to count the number of samples. This allows accumulators to offload some of their computations on other accumulators, making the algorithms more efficient. Each accumulator only sees data in the appropriate pass through the data, called its &quot;working pass&quot;. </span>
<a name="l00065"></a>00065 <span class="comment"></span>
<a name="l00066"></a>00066 <span class="comment">&lt;b&gt;\#include&lt;/b&gt; &lt;vigra/accumulator.hxx&gt;</span>
<a name="l00067"></a>00067 <span class="comment"></span>
<a name="l00068"></a>00068 <span class="comment">    </span>
<a name="l00069"></a>00069 <span class="comment">&lt;b&gt;Basic statistics:&lt;/b&gt;</span>
<a name="l00070"></a>00070 <span class="comment">    - PowerSum&lt;N&gt; (computes @f$ \sum_i x_i^N @f$)</span>
<a name="l00071"></a>00071 <span class="comment">    - AbsPowerSum&lt;N&gt; (computes @f$ \sum_i |x_i|^N @f$)</span>
<a name="l00072"></a>00072 <span class="comment">    - Skewness, UnbiasedSkewness</span>
<a name="l00073"></a>00073 <span class="comment">    - Kurtosis, UnbiasedKurtosis</span>
<a name="l00074"></a>00074 <span class="comment">    - Minimum, Maximum</span>
<a name="l00075"></a>00075 <span class="comment">    - FlatScatterMatrix (flattened upper-triangular part of scatter matrix)</span>
<a name="l00076"></a>00076 <span class="comment">    - 4 histogram classes (see \ref histogram &quot;below&quot;)</span>
<a name="l00077"></a>00077 <span class="comment">    - StandardQuantiles (0%, 10%, 25%, 50%, 75%, 90%, 100%)</span>
<a name="l00078"></a>00078 <span class="comment">    - ArgMinWeight, ArgMaxWeight (store data or coordinate where weight assumes its minimal or maximal value)</span>
<a name="l00079"></a>00079 <span class="comment">    - CoordinateSystem (identity matrix of appropriate size)</span>
<a name="l00080"></a>00080 <span class="comment">    </span>
<a name="l00081"></a>00081 <span class="comment">    &lt;b&gt;Modifiers:&lt;/b&gt; (S is the statistc to be modified)</span>
<a name="l00082"></a>00082 <span class="comment">    - Normalization</span>
<a name="l00083"></a>00083 <span class="comment">      &lt;table border=&quot;0&quot;&gt;</span>
<a name="l00084"></a>00084 <span class="comment">      &lt;tr&gt;&lt;td&gt; DivideByCount&lt;S&gt;        &lt;/td&gt;&lt;td&gt;  S/Count           &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00085"></a>00085 <span class="comment">      &lt;tr&gt;&lt;td&gt; RootDivideByCount&lt;S&gt;    &lt;/td&gt;&lt;td&gt;  sqrt( S/Count )     &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00086"></a>00086 <span class="comment">      &lt;tr&gt;&lt;td&gt; DivideUnbiased&lt;S&gt;       &lt;/td&gt;&lt;td&gt;  S/(Count-1)       &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00087"></a>00087 <span class="comment">      &lt;tr&gt;&lt;td&gt; RootDivideUnbiased&lt;S&gt; &amp;nbsp; &amp;nbsp;  &lt;/td&gt;&lt;td&gt;  sqrt( S/(Count-1) ) &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00088"></a>00088 <span class="comment">      &lt;/table&gt;    </span>
<a name="l00089"></a>00089 <span class="comment">    - Data preparation:</span>
<a name="l00090"></a>00090 <span class="comment">      &lt;table border=&quot;0&quot;&gt;</span>
<a name="l00091"></a>00091 <span class="comment">      &lt;tr&gt;&lt;td&gt;  Central&lt;S&gt;   &lt;/td&gt;&lt;td&gt; substract mean before computing S &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00092"></a>00092 <span class="comment">      &lt;tr&gt;&lt;td&gt;  Principal&lt;S&gt; &lt;/td&gt;&lt;td&gt; project onto PCA eigenvectors   &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00093"></a>00093 <span class="comment">      &lt;tr&gt;&lt;td&gt;  Whitened&lt;S&gt; &amp;nbsp; &amp;nbsp;  &lt;/td&gt;&lt;td&gt; scale to unit variance after PCA   &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00094"></a>00094 <span class="comment">      &lt;tr&gt;&lt;td&gt;  Coord&lt;S&gt;        &lt;/td&gt;&lt;td&gt; compute S from pixel coordinates rather than from pixel values    &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00095"></a>00095 <span class="comment">      &lt;tr&gt;&lt;td&gt;  Weighted&lt;S&gt;     &lt;/td&gt;&lt;td&gt; compute weighted version of S   &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00096"></a>00096 <span class="comment">      &lt;tr&gt;&lt;td&gt;  Global&lt;S&gt;       &lt;/td&gt;&lt;td&gt; compute S globally rather than per region (per region is default if labels are given)   &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00097"></a>00097 <span class="comment">      &lt;/table&gt;</span>
<a name="l00098"></a>00098 <span class="comment">      </span>
<a name="l00099"></a>00099 <span class="comment">    Aliases for many important features are implemented (mainly as &lt;tt&gt;typedef FullName Alias&lt;/tt&gt;). The alias names are equivalent to full names. Below are some examples for supported alias names. A full list of all available statistics and alias names can be found in the namespace reference &lt;tt&gt;vigra::acc&lt;/tt&gt;. These examples also show how to compose statistics from the fundamental statistics and modifiers:</span>
<a name="l00100"></a>00100 <span class="comment">    </span>
<a name="l00101"></a>00101 <span class="comment">    &lt;table border=&quot;0&quot;&gt;</span>
<a name="l00102"></a>00102 <span class="comment">    &lt;tr&gt;&lt;th&gt; Alias           &lt;/th&gt;&lt;th&gt;   Full Name                 &lt;/th&gt;&lt;/tr&gt;</span>
<a name="l00103"></a>00103 <span class="comment">    &lt;tr&gt;&lt;td&gt; Count           &lt;/td&gt;&lt;td&gt;  PowerSum&lt;0&gt;                &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00104"></a>00104 <span class="comment">    &lt;tr&gt;&lt;td&gt; Sum             &lt;/td&gt;&lt;td&gt;  PowerSum&lt;1&gt;                &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00105"></a>00105 <span class="comment">    &lt;tr&gt;&lt;td&gt; SumOfSquares    &lt;/td&gt;&lt;td&gt;  PowerSum&lt;2&gt;                &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00106"></a>00106 <span class="comment">    &lt;tr&gt;&lt;td&gt; Mean            &lt;/td&gt;&lt;td&gt;  DivideByCount&lt;PowerSum&lt;1&gt;&gt; &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00107"></a>00107 <span class="comment">    &lt;tr&gt;&lt;td&gt; RootMeanSquares &amp;nbsp; &lt;/td&gt;&lt;td&gt;  RootDivideByCount&lt;PowerSum&lt;2&gt;&gt; &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00108"></a>00108 <span class="comment">    &lt;tr&gt;&lt;td&gt; Moment&lt;N&gt;       &lt;/td&gt;&lt;td&gt;  DivideByCount&lt;PowerSum&lt;N&gt;&gt;  &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00109"></a>00109 <span class="comment">    &lt;tr&gt;&lt;td&gt; Variance        &lt;/td&gt;&lt;td&gt;  DivideByCount&lt;Central&lt;PowerSum&lt;2&gt;&gt;&gt;  &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00110"></a>00110 <span class="comment">    &lt;tr&gt;&lt;td&gt; StdDev          &lt;/td&gt;&lt;td&gt;  RootDivideByCount&lt;Central&lt;PowerSum&lt;2&gt;&gt;&gt;  &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00111"></a>00111 <span class="comment">    &lt;tr&gt;&lt;td&gt; Covariance      &lt;/td&gt;&lt;td&gt;  DivideByCount&lt;FlatScatterMatrix&gt; &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00112"></a>00112 <span class="comment">    &lt;tr&gt;&lt;td&gt; RegionCenter    &lt;/td&gt;&lt;td&gt;  Coord&lt;Mean&gt;                &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00113"></a>00113 <span class="comment">    &lt;tr&gt;&lt;td&gt; CenterOfMass    &lt;/td&gt;&lt;td&gt;  Weighted&lt;Coord&lt;Mean&gt;&gt;      &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00114"></a>00114 <span class="comment">    &lt;/table&gt;</span>
<a name="l00115"></a>00115 <span class="comment">    </span>
<a name="l00116"></a>00116 <span class="comment">    There are a few &lt;b&gt;rules for composing statistics&lt;/b&gt;:</span>
<a name="l00117"></a>00117 <span class="comment">    - modifiers can be specified in any order, but are internally transformed to standard order: Global&lt;Weighted&lt;Coord&lt;normalization&lt;data preparation&lt;basic statistic</span>
<a name="l00118"></a>00118 <span class="comment">    - only one normalization modifier and one data preparation modifier (Central or Principal or Whitened) is permitted </span>
<a name="l00119"></a>00119 <span class="comment">    - Count ignores all modifiers except Global and Weighted</span>
<a name="l00120"></a>00120 <span class="comment">    - Sum ignores Central and Principal, because sum would be zero</span>
<a name="l00121"></a>00121 <span class="comment">    - ArgMinWeight and ArgMaxWeight are automatically Weighted</span>
<a name="l00122"></a>00122 <span class="comment"></span>
<a name="l00123"></a>00123 <span class="comment"></span>
<a name="l00124"></a>00124 <span class="comment">    Here is an example how to use \ref acc::AccumulatorChain to compute statistics. (To use Weighted&lt;&gt; or Coord&lt;&gt; modifiers, see below):</span>
<a name="l00125"></a>00125 <span class="comment"></span>
<a name="l00126"></a>00126 <span class="comment">    \code</span>
<a name="l00127"></a>00127 <span class="comment">    #include &lt;vigra/multi_array.hxx&gt;</span>
<a name="l00128"></a>00128 <span class="comment">    #include &lt;vigra/impex.hxx&gt;</span>
<a name="l00129"></a>00129 <span class="comment">    #include &lt;vigra/accumulator.hxx&gt;</span>
<a name="l00130"></a>00130 <span class="comment">    using namespace vigra::acc;</span>
<a name="l00131"></a>00131 <span class="comment">    typedef double DataType;</span>
<a name="l00132"></a>00132 <span class="comment">    int size = 1000;</span>
<a name="l00133"></a>00133 <span class="comment">    vigra::MultiArray&lt;2, DataType&gt; data(vigra::Shape2(size, size));</span>
<a name="l00134"></a>00134 <span class="comment">   </span>
<a name="l00135"></a>00135 <span class="comment">    AccumulatorChain&lt;DataType, </span>
<a name="l00136"></a>00136 <span class="comment">        Select&lt;Variance, Mean, StdDev, Minimum, Maximum, RootMeanSquares, Skewness, Covariance&gt; &gt;</span>
<a name="l00137"></a>00137 <span class="comment">        a;</span>
<a name="l00138"></a>00138 <span class="comment">        </span>
<a name="l00139"></a>00139 <span class="comment">    std::cout &lt;&lt; &quot;passes required: &quot; &lt;&lt; a.passesRequired() &lt;&lt; std::endl;</span>
<a name="l00140"></a>00140 <span class="comment">    extractFeatures(data.begin(), data.end(), a); </span>
<a name="l00141"></a>00141 <span class="comment">    </span>
<a name="l00142"></a>00142 <span class="comment">    std::cout &lt;&lt; &quot;Mean: &quot; &lt;&lt; get&lt;Mean&gt;(a) &lt;&lt; std::endl;</span>
<a name="l00143"></a>00143 <span class="comment">    std::cout &lt;&lt; &quot;Variance: &quot; &lt;&lt; get&lt;Variance&gt;(a) &lt;&lt; std::endl;</span>
<a name="l00144"></a>00144 <span class="comment">    \endcode</span>
<a name="l00145"></a>00145 <span class="comment">    </span>
<a name="l00146"></a>00146 <span class="comment">    The \ref acc::AccumulatorChain object contains the selected statistics and their dependencies. Statistics have to be wrapped with \ref acc::Select. The statistics are computed with the acc::extractFeatures function and the statistics can be accessed with acc::get . </span>
<a name="l00147"></a>00147 <span class="comment"></span>
<a name="l00148"></a>00148 <span class="comment">    Rules and notes:</span>
<a name="l00149"></a>00149 <span class="comment">    - order of statistics in Select&lt;&gt; is arbitrary</span>
<a name="l00150"></a>00150 <span class="comment">    - up to 20 statistics in Select&lt;&gt;, but Select&lt;&gt; can be nested</span>
<a name="l00151"></a>00151 <span class="comment">    - dependencies are automatically inserted</span>
<a name="l00152"></a>00152 <span class="comment">    - duplicates are automatically removed</span>
<a name="l00153"></a>00153 <span class="comment">    - extractFeatures() does as many passes through the data as necessary</span>
<a name="l00154"></a>00154 <span class="comment">    - each accumulator only sees data in the appropriate pass (its &quot;working pass&quot;)</span>
<a name="l00155"></a>00155 <span class="comment"></span>
<a name="l00156"></a>00156 <span class="comment">    The Accumulators can also be used with vector-valued data (vigra::RGBValue, vigra::TinyVector, vigra::MultiArray or vigra::MultiArrayView):</span>
<a name="l00157"></a>00157 <span class="comment">    </span>
<a name="l00158"></a>00158 <span class="comment">    \code</span>
<a name="l00159"></a>00159 <span class="comment">    typedef vigra::RGBValue&lt;double&gt; DataType;</span>
<a name="l00160"></a>00160 <span class="comment">    AccumulatorChain&lt;DataType, Select&lt;...&gt; &gt; a;</span>
<a name="l00161"></a>00161 <span class="comment">    ...</span>
<a name="l00162"></a>00162 <span class="comment">    \endcode</span>
<a name="l00163"></a>00163 <span class="comment"></span>
<a name="l00164"></a>00164 <span class="comment">    To compute &lt;b&gt;weighted statistics&lt;/b&gt; (Weighted&lt;&gt;) or &lt;b&gt;statistics over coordinates&lt;/b&gt; (Coord&lt;&gt;), the accumulator chain can be used with several coupled arrays, one for the data and another for the weights and/or the labels. &quot;Coupled&quot; means that statistics are computed over the corresponding elements of the involved arrays. This is internally done by means of \ref CoupledScanOrderIterator and \ref vigra::CoupledHandle which provide simultaneous access to several arrays (e.g. weight and data) and corresponding coordinates. The types of the coupled arrays are best specified by means of the helper class \ref vigra::CoupledArrays :</span>
<a name="l00165"></a>00165 <span class="comment">    </span>
<a name="l00166"></a>00166 <span class="comment">    \code </span>
<a name="l00167"></a>00167 <span class="comment">    vigra::MultiArray&lt;3, RGBValue&lt;unsigned char&gt; &gt; data(...);</span>
<a name="l00168"></a>00168 <span class="comment">    vigra::MultiArray&lt;3, double&gt;                   weights(...);</span>
<a name="l00169"></a>00169 <span class="comment">    </span>
<a name="l00170"></a>00170 <span class="comment">    AccumulatorChain&lt;CoupledArrays&lt;3, RGBValue&lt;unsigned char&gt;, double&gt;,</span>
<a name="l00171"></a>00171 <span class="comment">                     Select&lt;...&gt; &gt; a;</span>
<a name="l00172"></a>00172 <span class="comment">    \endcode</span>
<a name="l00173"></a>00173 <span class="comment">    </span>
<a name="l00174"></a>00174 <span class="comment">This works likewise for label images which are needed for region statistics (see below). The indxx of the array holding data, weights, or labels respectively can be specified inside the Select wrapper. These &lt;b&gt;index specifiers&lt;/b&gt; are: (INDEX is of type int)</span>
<a name="l00175"></a>00175 <span class="comment">    - DataArg&lt;INDEX&gt;: data are in array &#39;INDEX&#39; (default INDEX=1)</span>
<a name="l00176"></a>00176 <span class="comment">    - LabelArg&lt;INDEX&gt;: labels are in array &#39;INDEX&#39; (default INDEX=2)</span>
<a name="l00177"></a>00177 <span class="comment">    - WeightArg&lt;INDEX&gt;: weights are in array &#39;INDEX&#39; (default INDEX=rightmost index)</span>
<a name="l00178"></a>00178 <span class="comment"></span>
<a name="l00179"></a>00179 <span class="comment">Pixel coordinates are always at index 0. To collect statistics, you simply pass all arrays to the &lt;tt&gt;extractFeatures()&lt;/tt&gt; function:</span>
<a name="l00180"></a>00180 <span class="comment">    \code</span>
<a name="l00181"></a>00181 <span class="comment">    using namespace vigra::acc;</span>
<a name="l00182"></a>00182 <span class="comment">    vigra::MultiArray&lt;3, double&gt; data(...), weights(...);</span>
<a name="l00183"></a>00183 <span class="comment">    </span>
<a name="l00184"></a>00184 <span class="comment">    AccumulatorChain&lt;CoupledArrays&lt;3, double, double&gt;, // two 3D arrays for data and weights</span>
<a name="l00185"></a>00185 <span class="comment">        Select&lt;DataArg&lt;1&gt;, WeightArg&lt;2&gt;,           // in which array to look (coordinates are always arg 0)</span>
<a name="l00186"></a>00186 <span class="comment">               Mean, Variance,                     //statistics over values  </span>
<a name="l00187"></a>00187 <span class="comment">               Coord&lt;Mean&gt;, Coord&lt;Variance&gt;,       //statistics over coordinates,</span>
<a name="l00188"></a>00188 <span class="comment">               Weighted&lt;Mean&gt;, Weighted&lt;Variance&gt;, //weighted values,</span>
<a name="l00189"></a>00189 <span class="comment">               Weighted&lt;Coord&lt;Mean&gt; &gt; &gt; &gt;          //weighted coordinates.</span>
<a name="l00190"></a>00190 <span class="comment">        a;</span>
<a name="l00191"></a>00191 <span class="comment">     </span>
<a name="l00192"></a>00192 <span class="comment">    extractFeatures(data, weights, a);</span>
<a name="l00193"></a>00193 <span class="comment">    \endcode</span>
<a name="l00194"></a>00194 <span class="comment">    </span>
<a name="l00195"></a>00195 <span class="comment">    This even works for a single array, which is useful if you want to combine values with coordinates. For example, to find the location of the minimum element in an array, you interpret the data as weights and select the &lt;tt&gt;Coord&lt;ArgMinWeight&gt;&lt;/tt&gt; statistic (note that the version of &lt;tt&gt;extractFeatures()&lt;/tt&gt; below only works in conjunction with &lt;tt&gt;CoupledArrays&lt;/tt&gt;, despite the fact that there is only one array involved):</span>
<a name="l00196"></a>00196 <span class="comment">    \code </span>
<a name="l00197"></a>00197 <span class="comment">    using namespace vigra::acc;</span>
<a name="l00198"></a>00198 <span class="comment">    vigra::MultiArray&lt;3, double&gt; data(...);</span>
<a name="l00199"></a>00199 <span class="comment">    </span>
<a name="l00200"></a>00200 <span class="comment">    AccumulatorChain&lt;CoupledArrays&lt;3, double&gt;,</span>
<a name="l00201"></a>00201 <span class="comment">                     Select&lt;WeightArg&lt;1&gt;,           // we interprete the data as weights</span>
<a name="l00202"></a>00202 <span class="comment">                            Coord&lt;ArgMinWeight&gt; &gt; &gt; // and look for the coordinate with minimal weight</span>
<a name="l00203"></a>00203 <span class="comment">        a;</span>
<a name="l00204"></a>00204 <span class="comment">        </span>
<a name="l00205"></a>00205 <span class="comment">    extractFeatures(data, a);</span>
<a name="l00206"></a>00206 <span class="comment">    std::cout &lt;&lt; &quot;minimum is at &quot; &lt;&lt; get&lt;Coord&lt;ArgMinWeight&gt; &gt;(a) &lt;&lt; std::endl;</span>
<a name="l00207"></a>00207 <span class="comment">    \endcode</span>
<a name="l00208"></a>00208 <span class="comment">    </span>
<a name="l00209"></a>00209 <span class="comment">    To compute &lt;b&gt;region statistics&lt;/b&gt;, you use \ref acc::AccumulatorChainArray. Regions are defined by means of a label array whose elements specify the region ID of the corresponding point. Therefore, you will always need at least two arrays here, which are again best specified using the &lt;tt&gt;CoupledArrays&lt;/tt&gt; helper:</span>
<a name="l00210"></a>00210 <span class="comment">    </span>
<a name="l00211"></a>00211 <span class="comment">    \code</span>
<a name="l00212"></a>00212 <span class="comment">    using namespace vigra::acc;</span>
<a name="l00213"></a>00213 <span class="comment">    vigra::MultiArray&lt;3, double&gt; data(...);</span>
<a name="l00214"></a>00214 <span class="comment">    vigra::MultiArray&lt;3, int&gt; labels(...);</span>
<a name="l00215"></a>00215 <span class="comment"></span>
<a name="l00216"></a>00216 <span class="comment">    AccumulatorChainArray&lt;CoupledArrays&lt;3, double, int&gt;,</span>
<a name="l00217"></a>00217 <span class="comment">        Select&lt;DataArg&lt;1&gt;, LabelArg&lt;2&gt;,       // in which array to look (coordinates are always arg 0)</span>
<a name="l00218"></a>00218 <span class="comment">               Mean, Variance,                    //per-region statistics over values</span>
<a name="l00219"></a>00219 <span class="comment">               Coord&lt;Mean&gt;, Coord&lt;Variance&gt;,      //per-region statistics over coordinates</span>
<a name="l00220"></a>00220 <span class="comment">               Global&lt;Mean&gt;, Global&lt;Variance&gt; &gt; &gt; //global statistics</span>
<a name="l00221"></a>00221 <span class="comment">    a;</span>
<a name="l00222"></a>00222 <span class="comment"></span>
<a name="l00223"></a>00223 <span class="comment">    a.ignoreLabel(0); //statistics will not be computed for region 0 (e.g. background)</span>
<a name="l00224"></a>00224 <span class="comment"></span>
<a name="l00225"></a>00225 <span class="comment">    extractFeatures(data, labels, a);</span>
<a name="l00226"></a>00226 <span class="comment"></span>
<a name="l00227"></a>00227 <span class="comment">    int regionlabel = ...;</span>
<a name="l00228"></a>00228 <span class="comment">    std::cout &lt;&lt; get&lt;Mean&gt;(a, regionlabel) &lt;&lt; std::endl; //get Mean of region with label &#39;regionlabel&#39;</span>
<a name="l00229"></a>00229 <span class="comment">    \endcode</span>
<a name="l00230"></a>00230 <span class="comment"></span>
<a name="l00231"></a>00231 <span class="comment">   </span>
<a name="l00232"></a>00232 <span class="comment">    In some application it will be known only at run-time which statistics have to be computed. An Accumulator with &lt;b&gt;run-time activation&lt;/b&gt; is provided by the \ref acc::DynamicAccumulatorChain class. One specifies a set of statistics at compile-time and from this set one can activate the needed statistics at run-time:</span>
<a name="l00233"></a>00233 <span class="comment">  </span>
<a name="l00234"></a>00234 <span class="comment">    \code</span>
<a name="l00235"></a>00235 <span class="comment">    using namespace vigra::acc;</span>
<a name="l00236"></a>00236 <span class="comment">    vigra::MultiArray&lt;2, double&gt; data(...);</span>
<a name="l00237"></a>00237 <span class="comment">    DynamicAccumulatorChain&lt;double, </span>
<a name="l00238"></a>00238 <span class="comment">        Select&lt;Mean, Minimum, Maximum, Variance, StdDev&gt; &gt; a; // at compile-time</span>
<a name="l00239"></a>00239 <span class="comment">    activate&lt;Mean&gt;(a);      //at run-time</span>
<a name="l00240"></a>00240 <span class="comment">    a.activate(&quot;Minimum&quot;);  //same as activate&lt;Minimum&gt;(a) (alias names are not recognized)</span>
<a name="l00241"></a>00241 <span class="comment">    </span>
<a name="l00242"></a>00242 <span class="comment">    extractFeatures(data.begin(), data.end(), a);</span>
<a name="l00243"></a>00243 <span class="comment">    std::cout &lt;&lt; &quot;Mean: &quot; &lt;&lt; get&lt;Mean&gt;(a) &lt;&lt; std::endl;       //ok</span>
<a name="l00244"></a>00244 <span class="comment">    //std::cout &lt;&lt; &quot;Maximum: &quot; &lt;&lt; get&lt;Maximum&gt;(a) &lt;&lt; std::endl; // run-time error because Maximum not activated</span>
<a name="l00245"></a>00245 <span class="comment">    \endcode</span>
<a name="l00246"></a>00246 <span class="comment">      </span>
<a name="l00247"></a>00247 <span class="comment">    Likewise, for run-time activation of region statistics, use \ref acc::DynamicAccumulatorChainArray. </span>
<a name="l00248"></a>00248 <span class="comment"></span>
<a name="l00249"></a>00249 <span class="comment">    &lt;b&gt;Accumulator merging&lt;/b&gt; (e.g. for parallelization or hierarchical segmentation) is possible for many accumulators:</span>
<a name="l00250"></a>00250 <span class="comment"></span>
<a name="l00251"></a>00251 <span class="comment">    \code</span>
<a name="l00252"></a>00252 <span class="comment">    using namespace vigra::acc;</span>
<a name="l00253"></a>00253 <span class="comment">    vigra::MultiArray&lt;2, double&gt; data(...);</span>
<a name="l00254"></a>00254 <span class="comment">    AccumulatorChain&lt;double, Select&lt;Mean, Variance, Skewness&gt; &gt; a, a1, a2;</span>
<a name="l00255"></a>00255 <span class="comment"></span>
<a name="l00256"></a>00256 <span class="comment">    extractFeatures(data.begin(), data.end(), a); //process entire data set at once</span>
<a name="l00257"></a>00257 <span class="comment">    extractFeatures(data.begin(), data.begin()+data.size()/2, a1); //process first half</span>
<a name="l00258"></a>00258 <span class="comment">    extractFeatures(data.begin()+data.size()/2, data.end(), a2); //process second half</span>
<a name="l00259"></a>00259 <span class="comment">    a1 += a2; // merge: a1 now equals a0 (within numerical tolerances)</span>
<a name="l00260"></a>00260 <span class="comment">    \endcode</span>
<a name="l00261"></a>00261 <span class="comment"></span>
<a name="l00262"></a>00262 <span class="comment">    Not all statistics can be merged (e.g. Principal&lt;A&gt; usually cannot, except for some important specializations). A statistic can be merged if the &quot;+=&quot; operator is supported (see the documentation of that particular statistic). If the accumulator chain only requires one pass to collect the data, it is also possible to just apply the extractFeatures() function repeatedly:</span>
<a name="l00263"></a>00263 <span class="comment"></span>
<a name="l00264"></a>00264 <span class="comment">    \code</span>
<a name="l00265"></a>00265 <span class="comment">    using namespace vigra::acc;</span>
<a name="l00266"></a>00266 <span class="comment">    vigra::MultiArray&lt;2, double&gt; data(...);</span>
<a name="l00267"></a>00267 <span class="comment">    AccumulatorChain&lt;double, Select&lt;Mean, Variance&gt; &gt; a;</span>
<a name="l00268"></a>00268 <span class="comment"></span>
<a name="l00269"></a>00269 <span class="comment">    extractFeatures(data.begin(), data.begin()+data.size()/2, a); // this works because </span>
<a name="l00270"></a>00270 <span class="comment">    extractFeatures(data.begin()+data.size()/2, data.end(), a);   // all statistics only need pass 1</span>
<a name="l00271"></a>00271 <span class="comment">    \endcode</span>
<a name="l00272"></a>00272 <span class="comment">    </span>
<a name="l00273"></a>00273 <span class="comment">    More care is needed to merge coordinate-based statistics. By default, all coordinate statistics are computed in the local coordinate system of the current region of interest. That is, the upper left corner of the ROI has the coordinate (0, 0) by default. This behavior is not desirable when you want to merge coordinate statistics from different ROIs: then, all accumulators should use the same coordinate system, usually the global system of the entire dataset. This can be achieved by the &lt;tt&gt;setCoordinateOffset()&lt;/tt&gt; function. The following code demonstrates this for the &lt;tt&gt;RegionCenter&lt;/tt&gt; statistic:</span>
<a name="l00274"></a>00274 <span class="comment"></span>
<a name="l00275"></a>00275 <span class="comment">    \code</span>
<a name="l00276"></a>00276 <span class="comment">    using namespace vigra;</span>
<a name="l00277"></a>00277 <span class="comment">    using namespace vigra::acc;</span>
<a name="l00278"></a>00278 <span class="comment">    </span>
<a name="l00279"></a>00279 <span class="comment">    MultiArray&lt;2, double&gt; data(width, height);</span>
<a name="l00280"></a>00280 <span class="comment">    MultiArray&lt;2, int&gt;    labels(width, height);</span>
<a name="l00281"></a>00281 <span class="comment">    </span>
<a name="l00282"></a>00282 <span class="comment">    AccumulatorChainArray&lt;CoupledArrays&lt;2, double, int&gt;,</span>
<a name="l00283"></a>00283 <span class="comment">                          Select&lt;DataArg&lt;1&gt;, LabelArg&lt;2&gt;, </span>
<a name="l00284"></a>00284 <span class="comment">                                 RegionCenter&gt; &gt;</span>
<a name="l00285"></a>00285 <span class="comment">    a1, a2;</span>
<a name="l00286"></a>00286 <span class="comment">    </span>
<a name="l00287"></a>00287 <span class="comment">    // a1 is responsible for the left half of the image. The local coordinate system of this ROI </span>
<a name="l00288"></a>00288 <span class="comment">    // happens to be identical to the global coordinate system, so the offset is zero.</span>
<a name="l00289"></a>00289 <span class="comment">    Shape2 origin(0,0);</span>
<a name="l00290"></a>00290 <span class="comment">    a1.setCoordinateOffset(origin);</span>
<a name="l00291"></a>00291 <span class="comment">    extractFeatures(data.subarray(origin, Shape2(width/2, height)), </span>
<a name="l00292"></a>00292 <span class="comment">                    labels.subarray(origin, Shape2(width/2, height)),</span>
<a name="l00293"></a>00293 <span class="comment">                    a1);</span>
<a name="l00294"></a>00294 <span class="comment">                    </span>
<a name="l00295"></a>00295 <span class="comment">    // a2 is responsible for the right half, so the offset of the local coordinate system is (width/2, 0)</span>
<a name="l00296"></a>00296 <span class="comment">    origin = Shape2(width/2, 0);</span>
<a name="l00297"></a>00297 <span class="comment">    a2.setCoordinateOffset(origin);</span>
<a name="l00298"></a>00298 <span class="comment">    extractFeatures(data.subarray(origin, Shape2(width, height)), </span>
<a name="l00299"></a>00299 <span class="comment">                    labels.subarray(origin, Shape2(width, height)),</span>
<a name="l00300"></a>00300 <span class="comment">                    a2);</span>
<a name="l00301"></a>00301 <span class="comment">   </span>
<a name="l00302"></a>00302 <span class="comment">    // since both accumulators worked in the same global coordinate system, we can safely merge them</span>
<a name="l00303"></a>00303 <span class="comment">    a1.merge(a2);</span>
<a name="l00304"></a>00304 <span class="comment">    \endcode</span>
<a name="l00305"></a>00305 <span class="comment">    </span>
<a name="l00306"></a>00306 <span class="comment">    When you compute region statistics in ROIs, it is sometimes desirable to use a local region labeling in each ROI. In this way, the labels of each ROI cover a consecutive range of numbers starting with 0. This can save a lot of memory, because &lt;tt&gt;AccumulatorChainArray&lt;/tt&gt; internally uses dense arrays -- accumulators will be allocated for all labels from 0 to the maxmimum label, even when many of them are unused. This is avoided by a local labeling. However, this means that label 1 (say) may refer to two different regions in different ROIs. To adjust for this mismatch, you can pass a label mapping to &lt;tt&gt;merge()&lt;/tt&gt; that provides a global label for each label of the accumulator to be merged. Thus, each region on the right hand side will be merged into the left-hand-side accumulator with the given &lt;i&gt;global&lt;/i&gt; label. For example, let us assume that the left and right half of the image contain just one region and background. Then, the accumulators of both ROIs have the label 0 (background) and 1 (the region). Upon merging, the region from the right ROI should be given the global label 2, whereas the background should keep its label 0. This is achieved like this:</span>
<a name="l00307"></a>00307 <span class="comment">    </span>
<a name="l00308"></a>00308 <span class="comment">    \code</span>
<a name="l00309"></a>00309 <span class="comment">    std::vector&lt;int&gt; labelMapping(2);</span>
<a name="l00310"></a>00310 <span class="comment">    labelMapping[0] = 0;   // background keeps label 0</span>
<a name="l00311"></a>00311 <span class="comment">    labelMapping[1] = 2;   // local region 1 becomes global region 2</span>
<a name="l00312"></a>00312 <span class="comment">    </span>
<a name="l00313"></a>00313 <span class="comment">    a1.merge(a2, labelMapping);</span>
<a name="l00314"></a>00314 <span class="comment">    \endcode</span>
<a name="l00315"></a>00315 <span class="comment"></span>
<a name="l00316"></a>00316 <span class="comment">    \anchor histogram</span>
<a name="l00317"></a>00317 <span class="comment">    Four kinds of &lt;b&gt;histograms&lt;/b&gt; are currently implemented:</span>
<a name="l00318"></a>00318 <span class="comment">    </span>
<a name="l00319"></a>00319 <span class="comment">    &lt;table border=&quot;0&quot;&gt;</span>
<a name="l00320"></a>00320 <span class="comment">      &lt;tr&gt;&lt;td&gt; IntegerHistogram      &lt;/td&gt;&lt;td&gt;   Data values are equal to bin indices   &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00321"></a>00321 <span class="comment">      &lt;tr&gt;&lt;td&gt; UserRangeHistogram    &lt;/td&gt;&lt;td&gt;  User provides lower and upper bounds for linear range mapping from values to indices.    &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00322"></a>00322 <span class="comment">      &lt;tr&gt;&lt;td&gt; AutoRangeHistogram    &lt;/td&gt;&lt;td&gt;  Range mapping bounds are defiend by minimum and maximum of the data (2 passes needed!)    &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00323"></a>00323 <span class="comment">      &lt;tr&gt;&lt;td&gt; GlobalRangeHistogram &amp;nbsp;  &lt;/td&gt;&lt;td&gt;  Likewise, but use global min/max rather than region min/max as AutoRangeHistogram will &lt;/td&gt;&lt;/tr&gt;</span>
<a name="l00324"></a>00324 <span class="comment">      &lt;/table&gt;    </span>
<a name="l00325"></a>00325 <span class="comment">  </span>
<a name="l00326"></a>00326 <span class="comment"></span>
<a name="l00327"></a>00327 <span class="comment">       </span>
<a name="l00328"></a>00328 <span class="comment">    - The number of bins is specified at compile time (as template parameter int BinCount) or at run-time (if BinCount is zero at compile time). In the first case the return type of the accumulator is TinyVector&lt;double, BinCount&gt; (number of bins cannot be changed). In the second case, the return type is MultiArray&lt;1, double&gt; and the number of bins must be set before seeing data (see example below). </span>
<a name="l00329"></a>00329 <span class="comment">    - If UserRangeHistogram is used, the bounds for the linear range mapping from values to indices must be set before seeing data (see below).</span>
<a name="l00330"></a>00330 <span class="comment">    - Options can be set by passing an instance of HistogramOptions to the accumulator chain (same options for all histograms in the chain) or by directly calling the appropriate member functions of the accumulators.</span>
<a name="l00331"></a>00331 <span class="comment">    - Merging is supported if the range mapping of the histograms is the same.</span>
<a name="l00332"></a>00332 <span class="comment">    - Histogram accumulators have two members for outliers (left_outliers, right_outliers).</span>
<a name="l00333"></a>00333 <span class="comment"></span>
<a name="l00334"></a>00334 <span class="comment">    With the StandardQuantiles class, &lt;b&gt;histogram quantiles&lt;/b&gt; (0%, 10%, 25%, 50%, 75%, 90%, 100%) are computed from a given histgram using linear interpolation. The return type is TinyVector&lt;double, 7&gt; .</span>
<a name="l00335"></a>00335 <span class="comment"></span>
<a name="l00336"></a>00336 <span class="comment">    \anchor acc_hist_options Usage:</span>
<a name="l00337"></a>00337 <span class="comment">    \code</span>
<a name="l00338"></a>00338 <span class="comment">    using namespace vigra::acc;</span>
<a name="l00339"></a>00339 <span class="comment">    typedef double DataType;</span>
<a name="l00340"></a>00340 <span class="comment">    vigra::MultiArray&lt;2, DataType&gt; data(...);</span>
<a name="l00341"></a>00341 <span class="comment">    </span>
<a name="l00342"></a>00342 <span class="comment">    typedef UserRangeHistogram&lt;40&gt; SomeHistogram;   //binCount set at compile time</span>
<a name="l00343"></a>00343 <span class="comment">    typedef UserRangeHistogram&lt;0&gt; SomeHistogram2; // binCount must be set at run-time</span>
<a name="l00344"></a>00344 <span class="comment">    typedef AutoRangeHistogram&lt;0&gt; SomeHistogram3;</span>
<a name="l00345"></a>00345 <span class="comment">    typedef StandardQuantiles&lt;SomeHistogram3&gt; Quantiles3;</span>
<a name="l00346"></a>00346 <span class="comment">    </span>
<a name="l00347"></a>00347 <span class="comment">    AccumulatorChain&lt;DataType, Select&lt;SomeHistogram, SomeHistogram2, SomeHistogram3, Quantiles3&gt; &gt; a;</span>
<a name="l00348"></a>00348 <span class="comment">    </span>
<a name="l00349"></a>00349 <span class="comment">    //set options for all histograms in the accumulator chain:</span>
<a name="l00350"></a>00350 <span class="comment">    vigra::HistogramOptions histogram_opt;         </span>
<a name="l00351"></a>00351 <span class="comment">    histogram_opt = histogram_opt.setBinCount(50); </span>
<a name="l00352"></a>00352 <span class="comment">    //histogram_opt = histogram_opt.setMinMax(0.1, 0.9); // this would set min/max for all three histograms, but range bounds </span>
<a name="l00353"></a>00353 <span class="comment">                                                         // shall be set automatically by min/max of data for SomeHistogram3</span>
<a name="l00354"></a>00354 <span class="comment">    a.setHistogramOptions(histogram_opt);  </span>
<a name="l00355"></a>00355 <span class="comment"></span>
<a name="l00356"></a>00356 <span class="comment">    // set options for a specific histogram in the accumulator chain:</span>
<a name="l00357"></a>00357 <span class="comment">    getAccumulator&lt;SomeHistogram&gt;(a).setMinMax(0.1, 0.9); // number of bins must be set before setting min/max</span>
<a name="l00358"></a>00358 <span class="comment">    getAccumulator&lt;SomeHistogram2&gt;(a).setMinMax(0.0, 1.0);</span>
<a name="l00359"></a>00359 <span class="comment"></span>
<a name="l00360"></a>00360 <span class="comment">    extractFeatures(data.begin(), data.end(), a);</span>
<a name="l00361"></a>00361 <span class="comment"></span>
<a name="l00362"></a>00362 <span class="comment">    vigra::TinyVector&lt;double, 40&gt; hist = get&lt;SomeHistogram&gt;(a);</span>
<a name="l00363"></a>00363 <span class="comment">    vigra::MultiArray&lt;1, double&gt; hist2 = get&lt;SomeHistogram2&gt;(a);</span>
<a name="l00364"></a>00364 <span class="comment">    vigra::TinyVector&lt;double, 7&gt; quant = get&lt;Quantiles3&gt;(a);</span>
<a name="l00365"></a>00365 <span class="comment">    double right_outliers = getAccumulator&lt;SomeHistogram&gt;(a).right_outliers;</span>
<a name="l00366"></a>00366 <span class="comment">    \endcode</span>
<a name="l00367"></a>00367 <span class="comment"></span>
<a name="l00368"></a>00368 <span class="comment"></span>
<a name="l00369"></a>00369 <span class="comment">    </span>
<a name="l00370"></a>00370 <span class="comment">*/</span>
<a name="l00371"></a>00371 
<a name="l00372"></a>00372 <span class="comment"></span>
<a name="l00373"></a>00373 <span class="comment">/** This namespace contains the accumulator classes, fundamental statistics and modifiers. See \ref FeatureAccumulators for examples of usage.</span>
<a name="l00374"></a>00374 <span class="comment">*/</span>
<a name="l00375"></a>00375 <span class="keyword">namespace </span>acc {
<a name="l00376"></a>00376 
<a name="l00377"></a>00377 <span class="comment">/****************************************************************************/</span>
<a name="l00378"></a>00378 <span class="comment">/*                                                                          */</span>
<a name="l00379"></a>00379 <span class="comment">/*                             infrastructure                               */</span>
<a name="l00380"></a>00380 <span class="comment">/*                                                                          */</span>
<a name="l00381"></a>00381 <span class="comment">/****************************************************************************/</span>
<a name="l00382"></a>00382 <span class="comment"></span>
<a name="l00383"></a>00383 <span class="comment">  /// \brief Wrapper for MakeTypeList that additionally performs tag standardization.</span>
<a name="l00384"></a>00384 <span class="comment"></span>
<a name="l00385"></a>00385 <span class="keyword">template</span> &lt;<span class="keyword">class </span>T01=void, <span class="keyword">class </span>T02=void, <span class="keyword">class </span>T03=void, <span class="keyword">class </span>T04=void, <span class="keyword">class </span>T05=void,
<a name="l00386"></a>00386           <span class="keyword">class </span>T06=void, <span class="keyword">class </span>T07=void, <span class="keyword">class </span>T08=void, <span class="keyword">class </span>T09=void, <span class="keyword">class </span>T10=void,
<a name="l00387"></a>00387           <span class="keyword">class </span>T11=void, <span class="keyword">class </span>T12=void, <span class="keyword">class </span>T13=void, <span class="keyword">class </span>T14=void, <span class="keyword">class </span>T15=void,
<a name="l00388"></a>00388           <span class="keyword">class </span>T16=void, <span class="keyword">class </span>T17=void, <span class="keyword">class </span>T18=void, <span class="keyword">class </span>T19=void, <span class="keyword">class </span>T20=<span class="keywordtype">void</span>&gt;
<a name="l00389"></a><a class="code" href="structvigra_1_1acc_1_1Select.html">00389</a> <span class="keyword">struct </span><a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select</a>
<a name="l00390"></a>00390 : <span class="keyword">public</span> MakeTypeList&lt;
<a name="l00391"></a>00391     typename StandardizeTag&lt;T01&gt;::type, typename StandardizeTag&lt;T02&gt;::type, typename StandardizeTag&lt;T03&gt;::type, 
<a name="l00392"></a>00392     typename StandardizeTag&lt;T04&gt;::type, typename StandardizeTag&lt;T05&gt;::type, typename StandardizeTag&lt;T06&gt;::type, 
<a name="l00393"></a>00393     typename StandardizeTag&lt;T07&gt;::type, typename StandardizeTag&lt;T08&gt;::type, typename StandardizeTag&lt;T09&gt;::type, 
<a name="l00394"></a>00394     typename StandardizeTag&lt;T10&gt;::type, typename StandardizeTag&lt;T11&gt;::type, typename StandardizeTag&lt;T12&gt;::type, 
<a name="l00395"></a>00395     typename StandardizeTag&lt;T13&gt;::type, typename StandardizeTag&lt;T14&gt;::type, typename StandardizeTag&lt;T15&gt;::type, 
<a name="l00396"></a>00396     typename StandardizeTag&lt;T16&gt;::type, typename StandardizeTag&lt;T17&gt;::type, typename StandardizeTag&lt;T18&gt;::type, 
<a name="l00397"></a>00397     typename StandardizeTag&lt;T19&gt;::type, typename StandardizeTag&lt;T20&gt;::type
<a name="l00398"></a>00398     &gt;
<a name="l00399"></a>00399 {};
<a name="l00400"></a>00400 
<a name="l00401"></a>00401     <span class="comment">// enable nesting of Select&lt;&gt; expressions </span>
<a name="l00402"></a>00402 <span class="keyword">template</span> &lt;<span class="keyword">class </span>T01, <span class="keyword">class </span>T02, <span class="keyword">class </span>T03, <span class="keyword">class </span>T04, <span class="keyword">class </span>T05,
<a name="l00403"></a>00403           <span class="keyword">class </span>T06, <span class="keyword">class </span>T07, <span class="keyword">class </span>T08, <span class="keyword">class </span>T09, <span class="keyword">class </span>T10,
<a name="l00404"></a>00404           <span class="keyword">class </span>T11, <span class="keyword">class </span>T12, <span class="keyword">class </span>T13, <span class="keyword">class </span>T14, <span class="keyword">class </span>T15,
<a name="l00405"></a>00405           <span class="keyword">class </span>T16, <span class="keyword">class </span>T17, <span class="keyword">class </span>T18, <span class="keyword">class </span>T19, <span class="keyword">class </span>T20&gt;
<a name="l00406"></a>00406 <span class="keyword">struct </span>StandardizeTag&lt;<a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select</a>&lt;T01, T02, T03, T04, T05,
<a name="l00407"></a>00407                              T06, T07, T08, T09, T10,
<a name="l00408"></a>00408                              T11, T12, T13, T14, T15,
<a name="l00409"></a>00409                              T16, T17, T18, T19, T20&gt;, 
<a name="l00410"></a>00410                       <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select</a>&lt;T01, T02, T03, T04, T05,
<a name="l00411"></a>00411                              T06, T07, T08, T09, T10,
<a name="l00412"></a>00412                              T11, T12, T13, T14, T15,
<a name="l00413"></a>00413                              T16, T17, T18, T19, T20&gt; &gt;
<a name="l00414"></a>00414 {
<a name="l00415"></a>00415     <span class="keyword">typedef</span> <span class="keyword">typename</span>  <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select</a>&lt;T01, T02, T03, T04, T05,
<a name="l00416"></a>00416                              T06, T07, T08, T09, T10,
<a name="l00417"></a>00417                              T11, T12, T13, T14, T15,
<a name="l00418"></a>00418                              T16, T17, T18, T19, T20&gt;::type type;
<a name="l00419"></a>00419 };
<a name="l00420"></a>00420 
<a name="l00421"></a>00421 <span class="keyword">struct </span>AccumulatorBegin
<a name="l00422"></a>00422 {
<a name="l00423"></a>00423     <span class="keyword">typedef</span> Select&lt;&gt; Dependencies;
<a name="l00424"></a>00424     
<a name="l00425"></a>00425     <span class="keyword">static</span> std::string name() 
<a name="l00426"></a>00426     { 
<a name="l00427"></a>00427         <span class="keywordflow">return</span> <span class="stringliteral">&quot;AccumulatorBegin (internal)&quot;</span>;
<a name="l00428"></a>00428        <span class="comment">// static const std::string n(&quot;AccumulatorBegin (internal)&quot;);</span>
<a name="l00429"></a>00429        <span class="comment">// return n;</span>
<a name="l00430"></a>00430     }
<a name="l00431"></a>00431     
<a name="l00432"></a>00432     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> BASE&gt;
<a name="l00433"></a>00433     <span class="keyword">struct </span>Impl
<a name="l00434"></a>00434     : <span class="keyword">public</span> BASE
<a name="l00435"></a>00435     {};
<a name="l00436"></a>00436 };
<a name="l00437"></a>00437 
<a name="l00438"></a>00438 
<a name="l00439"></a>00439 <span class="keyword">struct </span>AccumulatorEnd;
<a name="l00440"></a>00440 <span class="keyword">struct </span>DataArgTag;
<a name="l00441"></a>00441 <span class="keyword">struct </span>WeightArgTag;
<a name="l00442"></a>00442 <span class="keyword">struct </span>LabelArgTag;
<a name="l00443"></a>00443 <span class="keyword">struct </span>CoordArgTag;
<a name="l00444"></a>00444 <span class="keyword">struct </span>LabelDispatchTag;
<a name="l00445"></a>00445 
<a name="l00446"></a>00446 <span class="keyword">struct </span>Error__Global_statistics_are_only_defined_for_AccumulatorChainArray;
<a name="l00447"></a>00447 <span class="comment"></span>
<a name="l00448"></a>00448 <span class="comment">/** \brief Specifies index of labels in CoupledHandle. </span>
<a name="l00449"></a>00449 <span class="comment"></span>
<a name="l00450"></a>00450 <span class="comment">    LabelArg&lt;INDEX&gt; tells the acc::AccumulatorChainArray which index of the Handle contains the labels. (Note that coordinates are always index 0)</span>
<a name="l00451"></a>00451 <span class="comment"> */</span>
<a name="l00452"></a>00452 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> INDEX&gt;
<a name="l00453"></a><a class="code" href="classvigra_1_1acc_1_1LabelArg.html">00453</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1LabelArg.html" title="Specifies index of labels in CoupledHandle.">LabelArg</a>
<a name="l00454"></a>00454 {
<a name="l00455"></a>00455   <span class="keyword">public</span>:
<a name="l00456"></a>00456     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l00457"></a>00457     
<a name="l00458"></a>00458     <span class="keyword">static</span> std::string name() 
<a name="l00459"></a>00459     { 
<a name="l00460"></a>00460         <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;LabelArg&lt;&quot;</span>) + <a class="code" href="namespacevigra.html#abefdd44c2db13a2b64f36c82d3647b82">asString</a>(INDEX) + <span class="stringliteral">&quot;&gt; (internal)&quot;</span>;
<a name="l00461"></a>00461         <span class="comment">// static const std::string n = std::string(&quot;LabelArg&lt;&quot;) + asString(INDEX) + &quot;&gt; (internal)&quot;;</span>
<a name="l00462"></a>00462         <span class="comment">// return n;</span>
<a name="l00463"></a>00463     }
<a name="l00464"></a>00464     
<a name="l00465"></a>00465     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> BASE&gt;
<a name="l00466"></a>00466     <span class="keyword">struct </span>Impl
<a name="l00467"></a>00467     : <span class="keyword">public</span> BASE
<a name="l00468"></a>00468     {
<a name="l00469"></a>00469         <span class="keyword">typedef</span> LabelArgTag Tag;
<a name="l00470"></a>00470         <span class="keyword">typedef</span> <span class="keywordtype">void</span> value_type;
<a name="l00471"></a>00471         <span class="keyword">typedef</span> <span class="keywordtype">void</span> result_type;
<a name="l00472"></a>00472 
<a name="l00473"></a>00473         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> value = INDEX;
<a name="l00474"></a>00474         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> workInPass = 0;
<a name="l00475"></a>00475     };
<a name="l00476"></a>00476 };
<a name="l00477"></a>00477 
<a name="l00478"></a>00478 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> INDEX&gt;
<a name="l00479"></a>00479 <span class="keyword">class </span>CoordArg
<a name="l00480"></a>00480 {
<a name="l00481"></a>00481   <span class="keyword">public</span>:
<a name="l00482"></a>00482     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;&gt;</a> Dependencies;
<a name="l00483"></a>00483     
<a name="l00484"></a>00484     <span class="keyword">static</span> std::string name() 
<a name="l00485"></a>00485     { 
<a name="l00486"></a>00486         <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;CoordArg&lt;&quot;</span>) + <a class="code" href="namespacevigra.html#abefdd44c2db13a2b64f36c82d3647b82">asString</a>(INDEX) + <span class="stringliteral">&quot;&gt; (internal)&quot;</span>;
<a name="l00487"></a>00487         <span class="comment">// static const std::string n = std::string(&quot;CoordArg&lt;&quot;) + asString(INDEX) + &quot;&gt; (internal)&quot;;</span>
<a name="l00488"></a>00488         <span class="comment">// return n;</span>
<a name="l00489"></a>00489     }
<a name="l00490"></a>00490     
<a name="l00491"></a>00491     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> BASE&gt;
<a name="l00492"></a>00492     <span class="keyword">struct </span>Impl
<a name="l00493"></a>00493     : <span class="keyword">public</span> BASE
<a name="l00494"></a>00494     {
<a name="l00495"></a>00495         <span class="keyword">typedef</span> CoordArgTag Tag;
<a name="l00496"></a>00496         <span class="keyword">typedef</span> <span class="keywordtype">void</span> value_type;
<a name="l00497"></a>00497         <span class="keyword">typedef</span> <span class="keywordtype">void</span> result_type;
<a name="l00498"></a>00498 
<a name="l00499"></a>00499         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> value = INDEX;
<a name="l00500"></a>00500         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> workInPass = 0;
<a name="l00501"></a>00501     };
<a name="l00502"></a>00502 };
<a name="l00503"></a>00503 
<a name="l00504"></a>00504 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> TAG, <span class="keyword">class</span> NEXT=AccumulatorEnd&gt;
<a name="l00505"></a>00505 <span class="keyword">struct </span>AccumulatorBase;
<a name="l00506"></a>00506 
<a name="l00507"></a>00507 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Tag, <span class="keyword">class</span> A&gt;
<a name="l00508"></a>00508 <span class="keyword">struct </span>LookupTag;
<a name="l00509"></a>00509 
<a name="l00510"></a>00510 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Tag, <span class="keyword">class</span> A, <span class="keyword">class</span> TargetTag=<span class="keyword">typename</span> A::Tag&gt;
<a name="l00511"></a>00511 <span class="keyword">struct </span>LookupDependency;
<a name="l00512"></a>00512 
<a name="l00513"></a>00513 <span class="preprocessor">#ifndef _MSC_VER  // compiler bug? (causes &#39;ambiguous overload error&#39;)</span>
<a name="l00514"></a>00514 <span class="preprocessor"></span>
<a name="l00515"></a>00515 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG, <span class="keyword">class</span> A&gt;
<a name="l00516"></a>00516 <span class="keyword">typename</span> LookupTag&lt;TAG, A&gt;::reference
<a name="l00517"></a>00517 <a class="code" href="namespacevigra_1_1acc.html#a0e56445b73dc9e9265cfd863f77be15a">getAccumulator</a>(A &amp; a);
<a name="l00518"></a>00518 
<a name="l00519"></a>00519 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG, <span class="keyword">class</span> A&gt;
<a name="l00520"></a>00520 <span class="keyword">typename</span> LookupDependency&lt;TAG, A&gt;::result_type
<a name="l00521"></a>00521 getDependency(A <span class="keyword">const</span> &amp; a);
<a name="l00522"></a>00522 
<a name="l00523"></a>00523 <span class="preprocessor">#endif</span>
<a name="l00524"></a>00524 <span class="preprocessor"></span>
<a name="l00525"></a>00525 <span class="keyword">namespace </span>acc_detail {
<a name="l00526"></a>00526 
<a name="l00527"></a>00527 <span class="comment">/****************************************************************************/</span>
<a name="l00528"></a>00528 <span class="comment">/*                                                                          */</span>
<a name="l00529"></a>00529 <span class="comment">/*                   internal tag handling meta-functions                   */</span>
<a name="l00530"></a>00530 <span class="comment">/*                                                                          */</span>
<a name="l00531"></a>00531 <span class="comment">/****************************************************************************/</span>
<a name="l00532"></a>00532 
<a name="l00533"></a>00533     <span class="comment">// we must make sure that Arg&lt;INDEX&gt; tags are at the end of the chain because </span>
<a name="l00534"></a>00534     <span class="comment">// all other tags potentially depend on them</span>
<a name="l00535"></a>00535 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00536"></a>00536 <span class="keyword">struct </span>PushArgTagToTail
<a name="l00537"></a>00537 {
<a name="l00538"></a>00538     <span class="keyword">typedef</span> T type;
<a name="l00539"></a>00539 };
<a name="l00540"></a>00540 
<a name="l00541"></a>00541 <span class="preprocessor">#define VIGRA_PUSHARGTAG(TAG) \</span>
<a name="l00542"></a>00542 <span class="preprocessor">template &lt;int INDEX, class TAIL&gt; \</span>
<a name="l00543"></a>00543 <span class="preprocessor">struct PushArgTagToTail&lt;TypeList&lt;TAG&lt;INDEX&gt;, TAIL&gt; &gt; \</span>
<a name="l00544"></a>00544 <span class="preprocessor">{ \</span>
<a name="l00545"></a>00545 <span class="preprocessor">    typedef typename Push&lt;TAIL, TypeList&lt;TAG&lt;INDEX&gt; &gt; &gt;::type type; \</span>
<a name="l00546"></a>00546 <span class="preprocessor">};</span>
<a name="l00547"></a>00547 <span class="preprocessor"></span>
<a name="l00548"></a>00548 VIGRA_PUSHARGTAG(DataArg)
<a name="l00549"></a>00549 VIGRA_PUSHARGTAG(WeightArg)
<a name="l00550"></a>00550 VIGRA_PUSHARGTAG(CoordArg)
<a name="l00551"></a>00551 VIGRA_PUSHARGTAG(LabelArg)
<a name="l00552"></a>00552 
<a name="l00553"></a>00553 <span class="preprocessor">#undef VIGRA_PUSHARGTAG</span>
<a name="l00554"></a>00554 <span class="preprocessor"></span>
<a name="l00555"></a>00555     <span class="comment">// Insert the dependencies of the selected functors into the TypeList and sort</span>
<a name="l00556"></a>00556     <span class="comment">// the list such that dependencies come after the functors using them. Make sure </span>
<a name="l00557"></a>00557     <span class="comment">// that each functor is contained only once.</span>
<a name="l00558"></a>00558 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00559"></a>00559 <span class="keyword">struct </span>AddDependencies;
<a name="l00560"></a>00560 
<a name="l00561"></a>00561 <span class="keyword">template</span> &lt;<span class="keyword">class</span> HEAD, <span class="keyword">class</span> TAIL&gt;
<a name="l00562"></a>00562 <span class="keyword">struct </span>AddDependencies&lt;TypeList&lt;HEAD, TAIL&gt; &gt;
<a name="l00563"></a>00563 {
<a name="l00564"></a>00564     <span class="keyword">typedef</span> <span class="keyword">typename</span> AddDependencies&lt;TAIL&gt;::type                                   TailWithDependencies;
<a name="l00565"></a>00565     <span class="keyword">typedef</span> <span class="keyword">typename</span> StandardizeDependencies&lt;HEAD&gt;::type                           HeadDependencies;
<a name="l00566"></a>00566     <span class="keyword">typedef</span> <span class="keyword">typename</span> AddDependencies&lt;HeadDependencies&gt;::type                       TransitiveHeadDependencies;
<a name="l00567"></a>00567     <span class="keyword">typedef</span> TypeList&lt;HEAD, TransitiveHeadDependencies&gt;                             HeadWithDependencies;
<a name="l00568"></a>00568     <span class="keyword">typedef</span> <span class="keyword">typename</span> PushUnique&lt;HeadWithDependencies, TailWithDependencies&gt;::type  UnsortedDependencies;
<a name="l00569"></a>00569     <span class="keyword">typedef</span> <span class="keyword">typename</span> PushArgTagToTail&lt;UnsortedDependencies&gt;::type                  type;
<a name="l00570"></a>00570 };
<a name="l00571"></a>00571 
<a name="l00572"></a>00572 <span class="keyword">template</span> &lt;&gt;
<a name="l00573"></a>00573 <span class="keyword">struct </span>AddDependencies&lt;void&gt;
<a name="l00574"></a>00574 {
<a name="l00575"></a>00575     <span class="keyword">typedef</span> <span class="keywordtype">void</span> type;
<a name="l00576"></a>00576 };
<a name="l00577"></a>00577 
<a name="l00578"></a>00578     <span class="comment">// Helper class to activate dependencies at runtime (i.e. when activate&lt;Tag&gt;(accu) is called,</span>
<a name="l00579"></a>00579     <span class="comment">// activate() must also be called for Tag&#39;s dependencies).</span>
<a name="l00580"></a>00580 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Dependencies&gt;
<a name="l00581"></a>00581 <span class="keyword">struct </span>ActivateDependencies;
<a name="l00582"></a>00582 
<a name="l00583"></a>00583 <span class="keyword">template</span> &lt;<span class="keyword">class</span> HEAD, <span class="keyword">class</span> TAIL&gt;
<a name="l00584"></a>00584 <span class="keyword">struct </span>ActivateDependencies&lt;TypeList&lt;HEAD, TAIL&gt; &gt;
<a name="l00585"></a>00585 {
<a name="l00586"></a>00586     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Chain, <span class="keyword">class</span> ActiveFlags&gt;
<a name="l00587"></a>00587     <span class="keyword">static</span> <span class="keywordtype">void</span> exec(ActiveFlags &amp; flags)
<a name="l00588"></a>00588     {
<a name="l00589"></a>00589         LookupTag&lt;HEAD, Chain&gt;::type::activateImpl(flags);
<a name="l00590"></a>00590         ActivateDependencies&lt;TAIL&gt;::template exec&lt;Chain&gt;(flags);
<a name="l00591"></a>00591     }
<a name="l00592"></a>00592     
<a name="l00593"></a>00593     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Chain, <span class="keyword">class</span> ActiveFlags, <span class="keyword">class</span> GlobalFlags&gt;
<a name="l00594"></a>00594     <span class="keyword">static</span> <span class="keywordtype">void</span> exec(ActiveFlags &amp; flags, GlobalFlags &amp; gflags)
<a name="l00595"></a>00595     {
<a name="l00596"></a>00596         LookupTag&lt;HEAD, Chain&gt;::type::template activateImpl&lt;Chain&gt;(flags, gflags);
<a name="l00597"></a>00597         ActivateDependencies&lt;TAIL&gt;::template exec&lt;Chain&gt;(flags, gflags);
<a name="l00598"></a>00598     }
<a name="l00599"></a>00599 };
<a name="l00600"></a>00600 
<a name="l00601"></a>00601 <span class="keyword">template</span> &lt;<span class="keyword">class</span> HEAD, <span class="keyword">class</span> TAIL&gt;
<a name="l00602"></a>00602 <span class="keyword">struct </span>ActivateDependencies&lt;TypeList&lt;Global&lt;HEAD&gt;, TAIL&gt; &gt;
<a name="l00603"></a>00603 {
<a name="l00604"></a>00604     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Chain, <span class="keyword">class</span> ActiveFlags, <span class="keyword">class</span> GlobalFlags&gt;
<a name="l00605"></a>00605     <span class="keyword">static</span> <span class="keywordtype">void</span> exec(ActiveFlags &amp; flags, GlobalFlags &amp; gflags)
<a name="l00606"></a>00606     {
<a name="l00607"></a>00607         LookupTag&lt;Global&lt;HEAD&gt;, Chain&gt;::type::activateImpl(gflags);
<a name="l00608"></a>00608         ActivateDependencies&lt;TAIL&gt;::template exec&lt;Chain&gt;(flags, gflags);
<a name="l00609"></a>00609     }
<a name="l00610"></a>00610 };
<a name="l00611"></a>00611 
<a name="l00612"></a>00612 <span class="keyword">template</span> &lt;&gt;
<a name="l00613"></a>00613 <span class="keyword">struct </span>ActivateDependencies&lt;void&gt;
<a name="l00614"></a>00614 {
<a name="l00615"></a>00615     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Chain, <span class="keyword">class</span> ActiveFlags&gt;
<a name="l00616"></a>00616     <span class="keyword">static</span> <span class="keywordtype">void</span> exec(ActiveFlags &amp;)
<a name="l00617"></a>00617     {}
<a name="l00618"></a>00618     
<a name="l00619"></a>00619     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Chain, <span class="keyword">class</span> ActiveFlags, <span class="keyword">class</span> GlobalFlags&gt;
<a name="l00620"></a>00620     <span class="keyword">static</span> <span class="keywordtype">void</span> exec(ActiveFlags &amp;, GlobalFlags &amp;)
<a name="l00621"></a>00621     {}
<a name="l00622"></a>00622 };
<a name="l00623"></a>00623 
<a name="l00624"></a>00624 <span class="keyword">template</span> &lt;<span class="keyword">class</span> List&gt;
<a name="l00625"></a>00625 <span class="keyword">struct </span>SeparateGlobalAndRegionTags;
<a name="l00626"></a>00626 
<a name="l00627"></a>00627 <span class="keyword">template</span> &lt;<span class="keyword">class</span> HEAD, <span class="keyword">class</span> TAIL&gt;
<a name="l00628"></a>00628 <span class="keyword">struct </span>SeparateGlobalAndRegionTags&lt;TypeList&lt;HEAD, TAIL&gt; &gt;
<a name="l00629"></a>00629 {
<a name="l00630"></a>00630     <span class="keyword">typedef</span> SeparateGlobalAndRegionTags&lt;TAIL&gt;           Inner;
<a name="l00631"></a>00631     <span class="keyword">typedef</span> TypeList&lt;HEAD, typename Inner::RegionTags&gt;  RegionTags;
<a name="l00632"></a>00632     <span class="keyword">typedef</span> <span class="keyword">typename</span> Inner::GlobalTags                  GlobalTags;
<a name="l00633"></a>00633 };
<a name="l00634"></a>00634 
<a name="l00635"></a>00635 <span class="keyword">template</span> &lt;<span class="keyword">class</span> HEAD, <span class="keyword">class</span> TAIL&gt;
<a name="l00636"></a>00636 <span class="keyword">struct </span>SeparateGlobalAndRegionTags&lt;TypeList&lt;Global&lt;HEAD&gt;, TAIL&gt; &gt;
<a name="l00637"></a>00637 {
<a name="l00638"></a>00638     <span class="keyword">typedef</span> SeparateGlobalAndRegionTags&lt;TAIL&gt;           Inner;
<a name="l00639"></a>00639     <span class="keyword">typedef</span> <span class="keyword">typename</span> Inner::RegionTags                  RegionTags;
<a name="l00640"></a>00640     <span class="keyword">typedef</span> TypeList&lt;HEAD, typename Inner::GlobalTags&gt;  GlobalTags;
<a name="l00641"></a>00641 };
<a name="l00642"></a>00642 
<a name="l00643"></a>00643 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> INDEX, <span class="keyword">class</span> TAIL&gt;
<a name="l00644"></a>00644 <span class="keyword">struct </span>SeparateGlobalAndRegionTags&lt;TypeList&lt;DataArg&lt;INDEX&gt;, TAIL&gt; &gt;
<a name="l00645"></a>00645 {
<a name="l00646"></a>00646     <span class="keyword">typedef</span> SeparateGlobalAndRegionTags&lt;TAIL&gt;           Inner;
<a name="l00647"></a>00647     <span class="keyword">typedef</span> TypeList&lt;DataArg&lt;INDEX&gt;, <span class="keyword">typename</span> Inner::RegionTags&gt;  RegionTags;
<a name="l00648"></a>00648     <span class="keyword">typedef</span> TypeList&lt;DataArg&lt;INDEX&gt;, <span class="keyword">typename</span> Inner::GlobalTags&gt;  GlobalTags;
<a name="l00649"></a>00649 };
<a name="l00650"></a>00650 
<a name="l00651"></a>00651 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> INDEX, <span class="keyword">class</span> TAIL&gt;
<a name="l00652"></a>00652 <span class="keyword">struct </span>SeparateGlobalAndRegionTags&lt;TypeList&lt;LabelArg&lt;INDEX&gt;, TAIL&gt; &gt;
<a name="l00653"></a>00653 {
<a name="l00654"></a>00654     <span class="keyword">typedef</span> SeparateGlobalAndRegionTags&lt;TAIL&gt;           Inner;
<a name="l00655"></a>00655     <span class="keyword">typedef</span> <span class="keyword">typename</span> Inner::RegionTags                  RegionTags;
<a name="l00656"></a>00656     <span class="keyword">typedef</span> TypeList&lt;LabelArg&lt;INDEX&gt;, <span class="keyword">typename</span> Inner::GlobalTags&gt;  GlobalTags;
<a name="l00657"></a>00657 };
<a name="l00658"></a>00658 
<a name="l00659"></a>00659 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> INDEX, <span class="keyword">class</span> TAIL&gt;
<a name="l00660"></a>00660 <span class="keyword">struct </span>SeparateGlobalAndRegionTags&lt;TypeList&lt;WeightArg&lt;INDEX&gt;, TAIL&gt; &gt;
<a name="l00661"></a>00661 {
<a name="l00662"></a>00662     <span class="keyword">typedef</span> SeparateGlobalAndRegionTags&lt;TAIL&gt;           Inner;
<a name="l00663"></a>00663     <span class="keyword">typedef</span> TypeList&lt;WeightArg&lt;INDEX&gt;, <span class="keyword">typename</span> Inner::RegionTags&gt;  RegionTags;
<a name="l00664"></a>00664     <span class="keyword">typedef</span> TypeList&lt;WeightArg&lt;INDEX&gt;, <span class="keyword">typename</span> Inner::GlobalTags&gt;  GlobalTags;
<a name="l00665"></a>00665 };
<a name="l00666"></a>00666 
<a name="l00667"></a>00667 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> INDEX, <span class="keyword">class</span> TAIL&gt;
<a name="l00668"></a>00668 <span class="keyword">struct </span>SeparateGlobalAndRegionTags&lt;TypeList&lt;CoordArg&lt;INDEX&gt;, TAIL&gt; &gt;
<a name="l00669"></a>00669 {
<a name="l00670"></a>00670     <span class="keyword">typedef</span> SeparateGlobalAndRegionTags&lt;TAIL&gt;           Inner;
<a name="l00671"></a>00671     <span class="keyword">typedef</span> TypeList&lt;CoordArg&lt;INDEX&gt;, <span class="keyword">typename</span> Inner::RegionTags&gt;  RegionTags;
<a name="l00672"></a>00672     <span class="keyword">typedef</span> TypeList&lt;CoordArg&lt;INDEX&gt;, <span class="keyword">typename</span> Inner::GlobalTags&gt;  GlobalTags;
<a name="l00673"></a>00673 };
<a name="l00674"></a>00674 
<a name="l00675"></a>00675 <span class="keyword">template</span> &lt;&gt;
<a name="l00676"></a>00676 <span class="keyword">struct </span>SeparateGlobalAndRegionTags&lt;void&gt;
<a name="l00677"></a>00677 {
<a name="l00678"></a>00678     <span class="keyword">typedef</span> <span class="keywordtype">void</span> RegionTags;
<a name="l00679"></a>00679     <span class="keyword">typedef</span> <span class="keywordtype">void</span> GlobalTags;
<a name="l00680"></a>00680 };
<a name="l00681"></a>00681 
<a name="l00682"></a>00682 <span class="comment">/****************************************************************************/</span>
<a name="l00683"></a>00683 <span class="comment">/*                                                                          */</span>
<a name="l00684"></a>00684 <span class="comment">/*          helper classes to handle tags at runtime via strings            */</span>
<a name="l00685"></a>00685 <span class="comment">/*                                                                          */</span>
<a name="l00686"></a>00686 <span class="comment">/****************************************************************************/</span>
<a name="l00687"></a>00687 
<a name="l00688"></a>00688 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Accumulators&gt;
<a name="l00689"></a>00689 <span class="keyword">struct </span>CollectAccumulatorNames;
<a name="l00690"></a>00690 
<a name="l00691"></a>00691 <span class="keyword">template</span> &lt;<span class="keyword">class</span> HEAD, <span class="keyword">class</span> TAIL&gt;
<a name="l00692"></a>00692 <span class="keyword">struct </span>CollectAccumulatorNames&lt;TypeList&lt;HEAD, TAIL&gt; &gt;
<a name="l00693"></a>00693 {
<a name="l00694"></a>00694     <span class="keyword">template</span> &lt;<span class="keyword">class</span> BackInsertable&gt;
<a name="l00695"></a>00695     <span class="keyword">static</span> <span class="keywordtype">void</span> exec(BackInsertable &amp; a, <span class="keywordtype">bool</span> skipInternals=<span class="keyword">true</span>)
<a name="l00696"></a>00696     {
<a name="l00697"></a>00697         <span class="keywordflow">if</span>(!skipInternals || HEAD::name().find(<span class="stringliteral">&quot;internal&quot;</span>) == std::string::npos)
<a name="l00698"></a>00698             a.push_back(HEAD::name());
<a name="l00699"></a>00699         CollectAccumulatorNames&lt;TAIL&gt;::exec(a, skipInternals);
<a name="l00700"></a>00700     }
<a name="l00701"></a>00701 };
<a name="l00702"></a>00702 
<a name="l00703"></a>00703 <span class="keyword">template</span> &lt;&gt;
<a name="l00704"></a>00704 <span class="keyword">struct </span>CollectAccumulatorNames&lt;void&gt;
<a name="l00705"></a>00705 {
<a name="l00706"></a>00706     <span class="keyword">template</span> &lt;<span class="keyword">class</span> BackInsertable&gt;
<a name="l00707"></a>00707     <span class="keyword">static</span> <span class="keywordtype">void</span> exec(BackInsertable &amp; a, <span class="keywordtype">bool</span> skipInternals=<span class="keyword">true</span>)
<a name="l00708"></a>00708     {}
<a name="l00709"></a>00709 };
<a name="l00710"></a>00710 
<a name="l00711"></a>00711 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00712"></a>00712 <span class="keyword">struct </span>ApplyVisitorToTag;
<a name="l00713"></a>00713 
<a name="l00714"></a>00714 <span class="keyword">template</span> &lt;<span class="keyword">class</span> HEAD, <span class="keyword">class</span> TAIL&gt;
<a name="l00715"></a>00715 <span class="keyword">struct </span>ApplyVisitorToTag&lt;TypeList&lt;HEAD, TAIL&gt; &gt;
<a name="l00716"></a>00716 {
<a name="l00717"></a>00717     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Accu, <span class="keyword">class</span> Visitor&gt;
<a name="l00718"></a>00718     <span class="keyword">static</span> <span class="keywordtype">bool</span> exec(Accu &amp; a, std::string <span class="keyword">const</span> &amp; tag, Visitor <span class="keyword">const</span> &amp; v)
<a name="l00719"></a>00719     {
<a name="l00720"></a>00720         <span class="keyword">static</span> std::string * name = VIGRA_SAFE_STATIC(name, <span class="keyword">new</span> std::string(<a class="code" href="namespacevigra.html#a9e4131b7743b5801ce7122df2c63a9ba">normalizeString</a>(HEAD::name())));
<a name="l00721"></a>00721         <span class="keywordflow">if</span>(*name == tag)
<a name="l00722"></a>00722         {
<a name="l00723"></a>00723             v.template exec&lt;HEAD&gt;(a);
<a name="l00724"></a>00724             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00725"></a>00725         }
<a name="l00726"></a>00726         <span class="keywordflow">else</span>
<a name="l00727"></a>00727         {
<a name="l00728"></a>00728             <span class="keywordflow">return</span> ApplyVisitorToTag&lt;TAIL&gt;::exec(a, tag, v);
<a name="l00729"></a>00729         }
<a name="l00730"></a>00730     }
<a name="l00731"></a>00731 };
<a name="l00732"></a>00732 
<a name="l00733"></a>00733 <span class="keyword">template</span> &lt;&gt;
<a name="l00734"></a>00734 <span class="keyword">struct </span>ApplyVisitorToTag&lt;void&gt;
<a name="l00735"></a>00735 {
<a name="l00736"></a>00736     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Accu, <span class="keyword">class</span> Visitor&gt;
<a name="l00737"></a>00737     <span class="keyword">static</span> <span class="keywordtype">bool</span> exec(Accu &amp; a, std::string <span class="keyword">const</span> &amp; tag, Visitor <span class="keyword">const</span> &amp; v)
<a name="l00738"></a>00738     {
<a name="l00739"></a>00739         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00740"></a>00740     }
<a name="l00741"></a>00741 };
<a name="l00742"></a>00742 
<a name="l00743"></a>00743 <span class="keyword">struct </span>ActivateTag_Visitor
<a name="l00744"></a>00744 {
<a name="l00745"></a>00745     <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG, <span class="keyword">class</span> Accu&gt;
<a name="l00746"></a>00746     <span class="keywordtype">void</span> exec(Accu &amp; a)<span class="keyword"> const</span>
<a name="l00747"></a>00747 <span class="keyword">    </span>{
<a name="l00748"></a>00748         a.template activate&lt;TAG&gt;();
<a name="l00749"></a>00749     }
<a name="l00750"></a>00750 };
<a name="l00751"></a>00751 
<a name="l00752"></a>00752 <span class="keyword">struct </span>TagIsActive_Visitor
<a name="l00753"></a>00753 {
<a name="l00754"></a>00754     <span class="keyword">mutable</span> <span class="keywordtype">bool</span> result;
<a name="l00755"></a>00755     
<a name="l00756"></a>00756     <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG, <span class="keyword">class</span> Accu&gt;
<a name="l00757"></a>00757     <span class="keywordtype">void</span> exec(Accu &amp; a)<span class="keyword"> const</span>
<a name="l00758"></a>00758 <span class="keyword">    </span>{
<a name="l00759"></a>00759         result = a.template isActive&lt;TAG&gt;();
<a name="l00760"></a>00760     }
<a name="l00761"></a>00761 };
<a name="l00762"></a>00762 
<a name="l00763"></a>00763 <span class="comment">/****************************************************************************/</span>
<a name="l00764"></a>00764 <span class="comment">/*                                                                          */</span>
<a name="l00765"></a>00765 <span class="comment">/*                    histogram initialization functors                     */</span>
<a name="l00766"></a>00766 <span class="comment">/*                                                                          */</span>
<a name="l00767"></a>00767 <span class="comment">/****************************************************************************/</span>
<a name="l00768"></a>00768 
<a name="l00769"></a>00769 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG&gt;
<a name="l00770"></a>00770 <span class="keyword">struct </span>SetHistogramBincount
<a name="l00771"></a>00771 {
<a name="l00772"></a>00772     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Accu&gt;
<a name="l00773"></a>00773     <span class="keyword">static</span> <span class="keywordtype">void</span> exec(Accu &amp; a, HistogramOptions <span class="keyword">const</span> &amp; options)
<a name="l00774"></a>00774     {}
<a name="l00775"></a>00775 };
<a name="l00776"></a>00776 
<a name="l00777"></a>00777 <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keywordtype">int</span>&gt; <span class="keyword">class </span>Histogram&gt;
<a name="l00778"></a>00778 <span class="keyword">struct </span>SetHistogramBincount&lt;Histogram&lt;0&gt; &gt;
<a name="l00779"></a>00779 {
<a name="l00780"></a>00780     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Accu&gt;
<a name="l00781"></a>00781     <span class="keyword">static</span> <span class="keywordtype">void</span> exec(Accu &amp; a, HistogramOptions <span class="keyword">const</span> &amp; options)
<a name="l00782"></a>00782     {
<a name="l00783"></a>00783         a.setBinCount(options.binCount);
<a name="l00784"></a>00784     }
<a name="l00785"></a>00785 };
<a name="l00786"></a>00786 
<a name="l00787"></a>00787 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG&gt;
<a name="l00788"></a>00788 <span class="keyword">struct </span>ApplyHistogramOptions
<a name="l00789"></a>00789 {
<a name="l00790"></a>00790     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Accu&gt;
<a name="l00791"></a>00791     <span class="keyword">static</span> <span class="keywordtype">void</span> exec(Accu &amp; a, HistogramOptions <span class="keyword">const</span> &amp; options)
<a name="l00792"></a>00792     {}
<a name="l00793"></a>00793 };
<a name="l00794"></a>00794 
<a name="l00795"></a>00795 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG&gt;
<a name="l00796"></a>00796 <span class="keyword">struct </span>ApplyHistogramOptions&lt;StandardQuantiles&lt;TAG&gt; &gt;
<a name="l00797"></a>00797 {
<a name="l00798"></a>00798     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Accu&gt;
<a name="l00799"></a>00799     <span class="keyword">static</span> <span class="keywordtype">void</span> exec(Accu &amp; a, HistogramOptions <span class="keyword">const</span> &amp; options)
<a name="l00800"></a>00800     {}
<a name="l00801"></a>00801 };
<a name="l00802"></a>00802 
<a name="l00803"></a>00803 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG, <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>MODIFIER&gt;
<a name="l00804"></a>00804 <span class="keyword">struct </span>ApplyHistogramOptions&lt;MODIFIER&lt;TAG&gt; &gt;
<a name="l00805"></a>00805 : <span class="keyword">public</span> ApplyHistogramOptions&lt;TAG&gt;
<a name="l00806"></a>00806 {};
<a name="l00807"></a>00807 
<a name="l00808"></a>00808 <span class="keyword">template</span> &lt;&gt;
<a name="l00809"></a>00809 <span class="keyword">struct </span>ApplyHistogramOptions&lt;IntegerHistogram&lt;0&gt; &gt;
<a name="l00810"></a>00810 {
<a name="l00811"></a>00811     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Accu&gt;
<a name="l00812"></a>00812     <span class="keyword">static</span> <span class="keywordtype">void</span> exec(Accu &amp; a, HistogramOptions <span class="keyword">const</span> &amp; options)
<a name="l00813"></a>00813     {
<a name="l00814"></a>00814         SetHistogramBincount&lt;IntegerHistogram&lt;0&gt; &gt;::exec(a, options);
<a name="l00815"></a>00815     }
<a name="l00816"></a>00816 };
<a name="l00817"></a>00817 
<a name="l00818"></a>00818 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> BinCount&gt;
<a name="l00819"></a>00819 <span class="keyword">struct </span>ApplyHistogramOptions&lt;UserRangeHistogram&lt;BinCount&gt; &gt;
<a name="l00820"></a>00820 {
<a name="l00821"></a>00821     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Accu&gt;
<a name="l00822"></a>00822     <span class="keyword">static</span> <span class="keywordtype">void</span> exec(Accu &amp; a, HistogramOptions <span class="keyword">const</span> &amp; options)
<a name="l00823"></a>00823     {
<a name="l00824"></a>00824         SetHistogramBincount&lt;UserRangeHistogram&lt;BinCount&gt; &gt;::exec(a, options);
<a name="l00825"></a>00825         <span class="keywordflow">if</span>(a.scale_ == 0.0 &amp;&amp; options.validMinMax())
<a name="l00826"></a>00826             a.setMinMax(options.minimum, options.maximum);
<a name="l00827"></a>00827     }
<a name="l00828"></a>00828 };
<a name="l00829"></a>00829 
<a name="l00830"></a>00830 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> BinCount&gt;
<a name="l00831"></a>00831 <span class="keyword">struct </span>ApplyHistogramOptions&lt;AutoRangeHistogram&lt;BinCount&gt; &gt;
<a name="l00832"></a>00832 {
<a name="l00833"></a>00833     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Accu&gt;
<a name="l00834"></a>00834     <span class="keyword">static</span> <span class="keywordtype">void</span> exec(Accu &amp; a, HistogramOptions <span class="keyword">const</span> &amp; options)
<a name="l00835"></a>00835     {
<a name="l00836"></a>00836         SetHistogramBincount&lt;AutoRangeHistogram&lt;BinCount&gt; &gt;::exec(a, options);
<a name="l00837"></a>00837         <span class="keywordflow">if</span>(a.scale_ == 0.0 &amp;&amp; options.validMinMax())
<a name="l00838"></a>00838             a.setMinMax(options.minimum, options.maximum);
<a name="l00839"></a>00839     }
<a name="l00840"></a>00840 };
<a name="l00841"></a>00841 
<a name="l00842"></a>00842 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> BinCount&gt;
<a name="l00843"></a>00843 <span class="keyword">struct </span>ApplyHistogramOptions&lt;GlobalRangeHistogram&lt;BinCount&gt; &gt;
<a name="l00844"></a>00844 {
<a name="l00845"></a>00845     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Accu&gt;
<a name="l00846"></a>00846     <span class="keyword">static</span> <span class="keywordtype">void</span> exec(Accu &amp; a, HistogramOptions <span class="keyword">const</span> &amp; options)
<a name="l00847"></a>00847     {
<a name="l00848"></a>00848         SetHistogramBincount&lt;GlobalRangeHistogram&lt;BinCount&gt; &gt;::exec(a, options);
<a name="l00849"></a>00849         <span class="keywordflow">if</span>(a.scale_ == 0.0)
<a name="l00850"></a>00850         {
<a name="l00851"></a>00851             <span class="keywordflow">if</span>(options.validMinMax())
<a name="l00852"></a>00852                 a.setMinMax(options.minimum, options.maximum);
<a name="l00853"></a>00853             <span class="keywordflow">else</span>
<a name="l00854"></a>00854                 a.setRegionAutoInit(options.local_auto_init);
<a name="l00855"></a>00855         }
<a name="l00856"></a>00856     }
<a name="l00857"></a>00857 };
<a name="l00858"></a>00858 
<a name="l00859"></a>00859 <span class="comment">/****************************************************************************/</span>
<a name="l00860"></a>00860 <span class="comment">/*                                                                          */</span>
<a name="l00861"></a>00861 <span class="comment">/*                   internal accumulator chain classes                     */</span>
<a name="l00862"></a>00862 <span class="comment">/*                                                                          */</span>
<a name="l00863"></a>00863 <span class="comment">/****************************************************************************/</span>
<a name="l00864"></a>00864 
<a name="l00865"></a>00865     <span class="comment">// AccumulatorEndImpl has the following functionalities:</span>
<a name="l00866"></a>00866     <span class="comment">//  * marks end of accumulator chain by the AccumulatorEnd tag</span>
<a name="l00867"></a>00867     <span class="comment">//  * provides empty implementation of standard accumulator functions</span>
<a name="l00868"></a>00868     <span class="comment">//  * provides active_accumulators_ flags for run-time activation of dynamic accumulators</span>
<a name="l00869"></a>00869     <span class="comment">//  * provides is_dirty_ flags for caching accumulators</span>
<a name="l00870"></a>00870     <span class="comment">//  * hold the GlobalAccumulatorHandle for global accumulator lookup from region accumulators</span>
<a name="l00871"></a>00871 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> LEVEL, <span class="keyword">class</span> GlobalAccumulatorHandle&gt;
<a name="l00872"></a>00872 <span class="keyword">struct </span>AccumulatorEndImpl
<a name="l00873"></a>00873 {
<a name="l00874"></a>00874     <span class="keyword">typedef</span> <span class="keyword">typename</span> GlobalAccumulatorHandle::type  GlobalAccumulatorType;
<a name="l00875"></a>00875     
<a name="l00876"></a>00876     <span class="keyword">typedef</span> AccumulatorEnd     Tag;
<a name="l00877"></a>00877     <span class="keyword">typedef</span> <span class="keywordtype">void</span>               value_type;
<a name="l00878"></a>00878     <span class="keyword">typedef</span> <span class="keywordtype">bool</span>               result_type;
<a name="l00879"></a>00879     <span class="keyword">typedef</span> BitArray&lt;LEVEL&gt;    AccumulatorFlags;
<a name="l00880"></a>00880     
<a name="l00881"></a>00881     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  workInPass = 0; 
<a name="l00882"></a>00882     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span>           index = -1;
<a name="l00883"></a>00883     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span>      level = LEVEL;
<a name="l00884"></a>00884     
<a name="l00885"></a>00885     AccumulatorFlags            active_accumulators_;
<a name="l00886"></a>00886     <span class="keyword">mutable</span> AccumulatorFlags    is_dirty_;
<a name="l00887"></a>00887     GlobalAccumulatorHandle     globalAccumulator_;
<a name="l00888"></a>00888         
<a name="l00889"></a>00889     <span class="keyword">template</span> &lt;<span class="keyword">class</span> GlobalAccumulator&gt;
<a name="l00890"></a>00890     <span class="keywordtype">void</span> setGlobalAccumulator(GlobalAccumulator <span class="keyword">const</span> * a)
<a name="l00891"></a>00891     {
<a name="l00892"></a>00892         globalAccumulator_.pointer_ = a;
<a name="l00893"></a>00893     }
<a name="l00894"></a>00894 
<a name="l00895"></a>00895     <span class="keyword">static</span> std::string name()
<a name="l00896"></a>00896     {
<a name="l00897"></a>00897         <span class="keywordflow">return</span> <span class="stringliteral">&quot;AccumulatorEnd (internal)&quot;</span>;
<a name="l00898"></a>00898     }
<a name="l00899"></a>00899         
<a name="l00900"></a>00900     <span class="keywordtype">bool</span> operator()()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">false</span>; }
<a name="l00901"></a>00901     <span class="keywordtype">bool</span> <span class="keyword">get</span>() <span class="keyword">const</span> { <span class="keywordflow">return</span> <span class="keyword">false</span>; }
<a name="l00902"></a>00902     
<a name="l00903"></a>00903     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span>, <span class="keyword">class</span> U&gt;
<a name="l00904"></a>00904     <span class="keywordtype">void</span> pass(U <span class="keyword">const</span> &amp;) 
<a name="l00905"></a>00905     {}
<a name="l00906"></a>00906     
<a name="l00907"></a>00907     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span>, <span class="keyword">class</span> U&gt;
<a name="l00908"></a>00908     <span class="keywordtype">void</span> pass(U <span class="keyword">const</span> &amp;, <span class="keywordtype">double</span>) 
<a name="l00909"></a>00909     {}
<a name="l00910"></a>00910     
<a name="l00911"></a>00911     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt;
<a name="l00912"></a>00912     <span class="keywordtype">void</span> mergeImpl(U <span class="keyword">const</span> &amp;) 
<a name="l00913"></a>00913     {}
<a name="l00914"></a>00914     
<a name="l00915"></a>00915     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt;
<a name="l00916"></a>00916     <span class="keywordtype">void</span> resize(U <span class="keyword">const</span> &amp;) 
<a name="l00917"></a>00917     {}
<a name="l00918"></a>00918         
<a name="l00919"></a>00919     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt;
<a name="l00920"></a>00920     <span class="keywordtype">void</span> setCoordinateOffsetImpl(U <span class="keyword">const</span> &amp;)
<a name="l00921"></a>00921     {}
<a name="l00922"></a>00922     
<a name="l00923"></a>00923     <span class="keywordtype">void</span> <a class="code" href="namespacevigra_1_1acc.html#a762643ee2596a5426da54cc3009ebfeb">activate</a>() 
<a name="l00924"></a>00924     {}
<a name="l00925"></a>00925     
<a name="l00926"></a>00926     <span class="keywordtype">bool</span> <a class="code" href="namespacevigra_1_1acc.html#a2f179339abc93d5b58a1f4bf530c80dd">isActive</a>()<span class="keyword"> const </span>
<a name="l00927"></a>00927 <span class="keyword">    </span>{ 
<a name="l00928"></a>00928         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00929"></a>00929     }
<a name="l00930"></a>00930     
<a name="l00931"></a>00931     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Flags&gt;
<a name="l00932"></a>00932     <span class="keyword">static</span> <span class="keywordtype">void</span> activateImpl(Flags &amp;)
<a name="l00933"></a>00933     {}
<a name="l00934"></a>00934     
<a name="l00935"></a>00935     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Accu, <span class="keyword">class</span> Flags1, <span class="keyword">class</span> Flags2&gt;
<a name="l00936"></a>00936     <span class="keyword">static</span> <span class="keywordtype">void</span> activateImpl(Flags1 &amp;, Flags2 &amp;)
<a name="l00937"></a>00937     {}
<a name="l00938"></a>00938     
<a name="l00939"></a>00939     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Flags&gt;
<a name="l00940"></a>00940     <span class="keyword">static</span> <span class="keywordtype">bool</span> isActiveImpl(Flags <span class="keyword">const</span> &amp;)
<a name="l00941"></a>00941     {
<a name="l00942"></a>00942         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00943"></a>00943     }
<a name="l00944"></a>00944     
<a name="l00945"></a>00945     <span class="keywordtype">void</span> applyHistogramOptions(HistogramOptions <span class="keyword">const</span> &amp;)
<a name="l00946"></a>00946     {}
<a name="l00947"></a>00947     
<a name="l00948"></a>00948     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> passesRequired()
<a name="l00949"></a>00949     {
<a name="l00950"></a>00950         <span class="keywordflow">return</span> 0;
<a name="l00951"></a>00951     }
<a name="l00952"></a>00952     
<a name="l00953"></a>00953     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> passesRequired(AccumulatorFlags <span class="keyword">const</span> &amp;)
<a name="l00954"></a>00954     {
<a name="l00955"></a>00955         <span class="keywordflow">return</span> 0;
<a name="l00956"></a>00956     }
<a name="l00957"></a>00957 
<a name="l00958"></a>00958     <span class="keywordtype">void</span> reset()
<a name="l00959"></a>00959     {
<a name="l00960"></a>00960         active_accumulators_.clear();
<a name="l00961"></a>00961         is_dirty_.clear();
<a name="l00962"></a>00962     }
<a name="l00963"></a>00963         
<a name="l00964"></a>00964     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> which&gt;
<a name="l00965"></a>00965     <span class="keywordtype">void</span> setDirtyImpl()<span class="keyword"> const</span>
<a name="l00966"></a>00966 <span class="keyword">    </span>{
<a name="l00967"></a>00967         is_dirty_.template set&lt;which&gt;();
<a name="l00968"></a>00968     }
<a name="l00969"></a>00969     
<a name="l00970"></a>00970     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> which&gt;
<a name="l00971"></a>00971     <span class="keywordtype">void</span> setCleanImpl()<span class="keyword"> const</span>
<a name="l00972"></a>00972 <span class="keyword">    </span>{
<a name="l00973"></a>00973         is_dirty_.template reset&lt;which&gt;();
<a name="l00974"></a>00974     }
<a name="l00975"></a>00975     
<a name="l00976"></a>00976     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> which&gt;
<a name="l00977"></a>00977     <span class="keywordtype">bool</span> isDirtyImpl()<span class="keyword"> const</span>
<a name="l00978"></a>00978 <span class="keyword">    </span>{
<a name="l00979"></a>00979         <span class="keywordflow">return</span> is_dirty_.template test&lt;which&gt;();
<a name="l00980"></a>00980     }
<a name="l00981"></a>00981 };
<a name="l00982"></a>00982 
<a name="l00983"></a>00983     <span class="comment">// DecoratorImpl implement the functionality of Decorator below</span>
<a name="l00984"></a>00984 <span class="keyword">template</span> &lt;<span class="keyword">class</span> A, <span class="keywordtype">unsigned</span> CurrentPass, <span class="keywordtype">bool</span> allowRuntimeActivation, <span class="keywordtype">unsigned</span> WorkPass=A::workInPass&gt;
<a name="l00985"></a>00985 <span class="keyword">struct </span>DecoratorImpl
<a name="l00986"></a>00986 {
<a name="l00987"></a>00987     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00988"></a>00988     <span class="keyword">static</span> <span class="keywordtype">void</span> exec(A &amp; a, T <span class="keyword">const</span> &amp; t)
<a name="l00989"></a>00989     {}
<a name="l00990"></a>00990 
<a name="l00991"></a>00991     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00992"></a>00992     <span class="keyword">static</span> <span class="keywordtype">void</span> exec(A &amp; a, T <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l00993"></a>00993     {}
<a name="l00994"></a>00994 };
<a name="l00995"></a>00995 
<a name="l00996"></a>00996 <span class="keyword">template</span> &lt;<span class="keyword">class</span> A, <span class="keywordtype">unsigned</span> CurrentPass&gt;
<a name="l00997"></a>00997 <span class="keyword">struct </span>DecoratorImpl&lt;A, CurrentPass, false, CurrentPass&gt;
<a name="l00998"></a>00998 {
<a name="l00999"></a>00999     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01000"></a>01000     <span class="keyword">static</span> <span class="keywordtype">void</span> exec(A &amp; a, T <span class="keyword">const</span> &amp; t)
<a name="l01001"></a>01001     {
<a name="l01002"></a>01002         a.update(t);
<a name="l01003"></a>01003     }
<a name="l01004"></a>01004     
<a name="l01005"></a>01005     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01006"></a>01006     <span class="keyword">static</span> <span class="keywordtype">void</span> exec(A &amp; a, T <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l01007"></a>01007     {
<a name="l01008"></a>01008         a.update(t, weight);
<a name="l01009"></a>01009     }
<a name="l01010"></a>01010 
<a name="l01011"></a>01011     <span class="keyword">static</span> <span class="keyword">typename</span> A::result_type <span class="keyword">get</span>(A <span class="keyword">const</span> &amp; a)
<a name="l01012"></a>01012     {
<a name="l01013"></a>01013         <span class="keywordflow">return</span> a();
<a name="l01014"></a>01014     }
<a name="l01015"></a>01015 
<a name="l01016"></a>01016     <span class="keyword">static</span> <span class="keywordtype">void</span> mergeImpl(A &amp; a, A <span class="keyword">const</span> &amp; o)
<a name="l01017"></a>01017     {
<a name="l01018"></a>01018         a += o;
<a name="l01019"></a>01019     }
<a name="l01020"></a>01020 
<a name="l01021"></a>01021     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01022"></a>01022     <span class="keyword">static</span> <span class="keywordtype">void</span> resize(A &amp; a, T <span class="keyword">const</span> &amp; t)
<a name="l01023"></a>01023     {
<a name="l01024"></a>01024         a.reshape(t);
<a name="l01025"></a>01025     }
<a name="l01026"></a>01026     
<a name="l01027"></a>01027     <span class="keyword">static</span> <span class="keywordtype">void</span> applyHistogramOptions(A &amp; a, HistogramOptions <span class="keyword">const</span> &amp; options)
<a name="l01028"></a>01028     {
<a name="l01029"></a>01029         ApplyHistogramOptions&lt;typename A::Tag&gt;::exec(a, options);
<a name="l01030"></a>01030     }
<a name="l01031"></a>01031 
<a name="l01032"></a>01032     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> passesRequired()
<a name="l01033"></a>01033     {
<a name="l01034"></a>01034         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A_workInPass = A::workInPass;
<a name="l01035"></a>01035         <span class="keywordflow">return</span> std::max(A_workInPass, A::InternalBaseType::passesRequired());
<a name="l01036"></a>01036     }
<a name="l01037"></a>01037 };
<a name="l01038"></a>01038 
<a name="l01039"></a>01039 <span class="keyword">template</span> &lt;<span class="keyword">class</span> A, <span class="keywordtype">unsigned</span> CurrentPass&gt;
<a name="l01040"></a>01040 <span class="keyword">struct </span>DecoratorImpl&lt;A, CurrentPass, true, CurrentPass&gt;
<a name="l01041"></a>01041 {
<a name="l01042"></a>01042     <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="namespacevigra_1_1acc.html#a2f179339abc93d5b58a1f4bf530c80dd">isActive</a>(A <span class="keyword">const</span> &amp; a)
<a name="l01043"></a>01043     {
<a name="l01044"></a>01044         <span class="keywordflow">return</span> A::isActiveImpl(getAccumulator&lt;AccumulatorEnd&gt;(a).active_accumulators_);
<a name="l01045"></a>01045     }
<a name="l01046"></a>01046     
<a name="l01047"></a>01047     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01048"></a>01048     <span class="keyword">static</span> <span class="keywordtype">void</span> exec(A &amp; a, T <span class="keyword">const</span> &amp; t)
<a name="l01049"></a>01049     {
<a name="l01050"></a>01050         <span class="keywordflow">if</span>(<a class="code" href="namespacevigra_1_1acc.html#a2f179339abc93d5b58a1f4bf530c80dd">isActive</a>(a))
<a name="l01051"></a>01051             a.update(t);
<a name="l01052"></a>01052     }
<a name="l01053"></a>01053 
<a name="l01054"></a>01054     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01055"></a>01055     <span class="keyword">static</span> <span class="keywordtype">void</span> exec(A &amp; a, T <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l01056"></a>01056     {
<a name="l01057"></a>01057         <span class="keywordflow">if</span>(<a class="code" href="namespacevigra_1_1acc.html#a2f179339abc93d5b58a1f4bf530c80dd">isActive</a>(a))
<a name="l01058"></a>01058             a.update(t, weight);
<a name="l01059"></a>01059     }
<a name="l01060"></a>01060 
<a name="l01061"></a>01061     <span class="keyword">static</span> <span class="keyword">typename</span> A::result_type <span class="keyword">get</span>(A <span class="keyword">const</span> &amp; a)
<a name="l01062"></a>01062     {
<a name="l01063"></a>01063         <span class="keywordflow">if</span>(!<a class="code" href="namespacevigra_1_1acc.html#a2f179339abc93d5b58a1f4bf530c80dd">isActive</a>(a))
<a name="l01064"></a>01064         {
<a name="l01065"></a>01065             std::string message = std::string(<span class="stringliteral">&quot;get(accumulator): attempt to access inactive statistic &#39;&quot;</span>) +
<a name="l01066"></a>01066                                               A::Tag::name() + <span class="stringliteral">&quot;&#39;.&quot;</span>;
<a name="l01067"></a>01067             vigra_precondition(<span class="keyword">false</span>, message);
<a name="l01068"></a>01068         }
<a name="l01069"></a>01069         <span class="keywordflow">return</span> a();
<a name="l01070"></a>01070     }
<a name="l01071"></a>01071 
<a name="l01072"></a>01072     <span class="keyword">static</span> <span class="keywordtype">void</span> mergeImpl(A &amp; a, A <span class="keyword">const</span> &amp; o)
<a name="l01073"></a>01073     {
<a name="l01074"></a>01074         <span class="keywordflow">if</span>(<a class="code" href="namespacevigra_1_1acc.html#a2f179339abc93d5b58a1f4bf530c80dd">isActive</a>(a))
<a name="l01075"></a>01075             a += o;
<a name="l01076"></a>01076     }
<a name="l01077"></a>01077 
<a name="l01078"></a>01078     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01079"></a>01079     <span class="keyword">static</span> <span class="keywordtype">void</span> resize(A &amp; a, T <span class="keyword">const</span> &amp; t)
<a name="l01080"></a>01080     {
<a name="l01081"></a>01081         <span class="keywordflow">if</span>(<a class="code" href="namespacevigra_1_1acc.html#a2f179339abc93d5b58a1f4bf530c80dd">isActive</a>(a))
<a name="l01082"></a>01082             a.reshape(t);
<a name="l01083"></a>01083     }
<a name="l01084"></a>01084     
<a name="l01085"></a>01085     <span class="keyword">static</span> <span class="keywordtype">void</span> applyHistogramOptions(A &amp; a, HistogramOptions <span class="keyword">const</span> &amp; options)
<a name="l01086"></a>01086     {
<a name="l01087"></a>01087         <span class="keywordflow">if</span>(<a class="code" href="namespacevigra_1_1acc.html#a2f179339abc93d5b58a1f4bf530c80dd">isActive</a>(a))
<a name="l01088"></a>01088             ApplyHistogramOptions&lt;typename A::Tag&gt;::exec(a, options);
<a name="l01089"></a>01089     }
<a name="l01090"></a>01090     
<a name="l01091"></a>01091     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ActiveFlags&gt;
<a name="l01092"></a>01092     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> passesRequired(ActiveFlags <span class="keyword">const</span> &amp; flags)
<a name="l01093"></a>01093     {
<a name="l01094"></a>01094         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A_workInPass = A::workInPass;
<a name="l01095"></a>01095         <span class="keywordflow">return</span> A::isActiveImpl(flags)
<a name="l01096"></a>01096                    ? std::max(A_workInPass, A::InternalBaseType::passesRequired(flags))
<a name="l01097"></a>01097                    : A::InternalBaseType::passesRequired(flags);
<a name="l01098"></a>01098     }
<a name="l01099"></a>01099 };
<a name="l01100"></a>01100 
<a name="l01101"></a>01101     <span class="comment">// Generic reshape function (expands to a no-op when T has fixed shape, and to</span>
<a name="l01102"></a>01102     <span class="comment">// the appropriate specialized call otherwise). Shape is an instance of MultiArrayShape&lt;N&gt;::type.</span>
<a name="l01103"></a>01103 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Shape&gt;
<a name="l01104"></a>01104 <span class="keywordtype">void</span> reshapeImpl(T &amp;, Shape <span class="keyword">const</span> &amp;)
<a name="l01105"></a>01105 {}
<a name="l01106"></a>01106 
<a name="l01107"></a>01107 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Shape, <span class="keyword">class</span> Initial&gt;
<a name="l01108"></a>01108 <span class="keywordtype">void</span> reshapeImpl(T &amp;, Shape <span class="keyword">const</span> &amp;, Initial <span class="keyword">const</span> &amp; = T())
<a name="l01109"></a>01109 {}
<a name="l01110"></a>01110 
<a name="l01111"></a>01111 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">class</span> Shape&gt;
<a name="l01112"></a>01112 <span class="keywordtype">void</span> reshapeImpl(MultiArray&lt;N, T, Alloc&gt; &amp; a, Shape <span class="keyword">const</span> &amp; s, T <span class="keyword">const</span> &amp; initial = T())
<a name="l01113"></a>01113 {
<a name="l01114"></a>01114     MultiArray&lt;N, T, Alloc&gt;(s, initial).swap(a);
<a name="l01115"></a>01115 }
<a name="l01116"></a>01116 
<a name="l01117"></a>01117 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">class</span> Shape&gt;
<a name="l01118"></a>01118 <span class="keywordtype">void</span> reshapeImpl(Matrix&lt;T, Alloc&gt; &amp; a, Shape <span class="keyword">const</span> &amp; s, T <span class="keyword">const</span> &amp; initial = T())
<a name="l01119"></a>01119 {
<a name="l01120"></a>01120     Matrix&lt;T, Alloc&gt;(s, initial).swap(a);
<a name="l01121"></a>01121 }
<a name="l01122"></a>01122 
<a name="l01123"></a>01123 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt;
<a name="l01124"></a>01124 <span class="keywordtype">void</span> copyShapeImpl(T <span class="keyword">const</span> &amp;, U <span class="keyword">const</span> &amp;)   <span class="comment">// to be used for scalars and static arrays</span>
<a name="l01125"></a>01125 {}
<a name="l01126"></a>01126 
<a name="l01127"></a>01127 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">class</span> U&gt;
<a name="l01128"></a>01128 <span class="keywordtype">void</span> copyShapeImpl(MultiArray&lt;N, T, Alloc&gt; <span class="keyword">const</span> &amp; from, U &amp; to) 
<a name="l01129"></a>01129 {
<a name="l01130"></a>01130     to.reshape(from.shape());
<a name="l01131"></a>01131 }
<a name="l01132"></a>01132 
<a name="l01133"></a>01133 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">class</span> U&gt;
<a name="l01134"></a>01134 <span class="keywordtype">void</span> copyShapeImpl(Matrix&lt;T, Alloc&gt; <span class="keyword">const</span> &amp; from, U &amp; to) 
<a name="l01135"></a>01135 {
<a name="l01136"></a>01136     to.reshape(from.shape());
<a name="l01137"></a>01137 }
<a name="l01138"></a>01138 
<a name="l01139"></a>01139 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt;
<a name="l01140"></a>01140 <span class="keywordtype">bool</span> hasDataImpl(T <span class="keyword">const</span> &amp;)   <span class="comment">// to be used for scalars and static arrays</span>
<a name="l01141"></a>01141 {
<a name="l01142"></a>01142     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01143"></a>01143 }
<a name="l01144"></a>01144 
<a name="l01145"></a>01145 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> T, <span class="keyword">class</span> Str<span class="keywordtype">id</span>e&gt;
<a name="l01146"></a>01146 <span class="keywordtype">bool</span> hasDataImpl(MultiArrayView&lt;N, T, Stride&gt; <span class="keyword">const</span> &amp; a) 
<a name="l01147"></a>01147 {
<a name="l01148"></a>01148     <span class="keywordflow">return</span> a.hasData();
<a name="l01149"></a>01149 }
<a name="l01150"></a>01150 
<a name="l01151"></a>01151     <span class="comment">// generic functions to create suitable shape objects from various input data types </span>
<a name="l01152"></a>01152 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> T, <span class="keyword">class</span> Str<span class="keywordtype">id</span>e&gt;
<a name="l01153"></a>01153 <span class="keyword">inline</span> <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type
<a name="l01154"></a>01154 shapeOf(MultiArrayView&lt;N, T, Stride&gt; <span class="keyword">const</span> &amp; a)
<a name="l01155"></a>01155 {
<a name="l01156"></a>01156     <span class="keywordflow">return</span> a.shape();
<a name="l01157"></a>01157 }
<a name="l01158"></a>01158 
<a name="l01159"></a>01159 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">int</span> N&gt;
<a name="l01160"></a>01160 <span class="keyword">inline</span> <a class="code" href="group__MultiIteratorGroup.html#gaf6799170bf47f30c42a3f164f6ccf8ce" title="shape type for MultiArray&lt;1, T&gt;">Shape1</a>
<a name="l01161"></a>01161 shapeOf(TinyVector&lt;T, N&gt; <span class="keyword">const</span> &amp;)
<a name="l01162"></a>01162 {
<a name="l01163"></a>01163     <span class="keywordflow">return</span> <a class="code" href="group__MultiIteratorGroup.html#gaf6799170bf47f30c42a3f164f6ccf8ce" title="shape type for MultiArray&lt;1, T&gt;">Shape1</a>(N);
<a name="l01164"></a>01164 }
<a name="l01165"></a>01165 
<a name="l01166"></a>01166 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> NEXT&gt;
<a name="l01167"></a>01167 <span class="keyword">inline</span> CoupledHandle&lt;T, NEXT&gt; <span class="keyword">const</span> &amp;
<a name="l01168"></a>01168 shapeOf(CoupledHandle&lt;T, NEXT&gt; <span class="keyword">const</span> &amp; t)
<a name="l01169"></a>01169 {
<a name="l01170"></a>01170     <span class="keywordflow">return</span> t;
<a name="l01171"></a>01171 }
<a name="l01172"></a>01172 
<a name="l01173"></a>01173 <span class="preprocessor">#define VIGRA_SHAPE_OF(type) \</span>
<a name="l01174"></a>01174 <span class="preprocessor">inline Shape1 \</span>
<a name="l01175"></a>01175 <span class="preprocessor">shapeOf(type) \</span>
<a name="l01176"></a>01176 <span class="preprocessor">{ \</span>
<a name="l01177"></a>01177 <span class="preprocessor">    return Shape1(1); \</span>
<a name="l01178"></a>01178 <span class="preprocessor">}</span>
<a name="l01179"></a>01179 <span class="preprocessor"></span>
<a name="l01180"></a>01180 VIGRA_SHAPE_OF(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)
<a name="l01181"></a>01181 VIGRA_SHAPE_OF(<span class="keywordtype">signed</span> <span class="keywordtype">char</span>)
<a name="l01182"></a>01182 VIGRA_SHAPE_OF(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>)
<a name="l01183"></a>01183 VIGRA_SHAPE_OF(<span class="keywordtype">short</span>)
<a name="l01184"></a>01184 VIGRA_SHAPE_OF(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)
<a name="l01185"></a>01185 VIGRA_SHAPE_OF(<span class="keywordtype">int</span>)
<a name="l01186"></a>01186 VIGRA_SHAPE_OF(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)
<a name="l01187"></a>01187 VIGRA_SHAPE_OF(<span class="keywordtype">long</span>)
<a name="l01188"></a>01188 VIGRA_SHAPE_OF(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)
<a name="l01189"></a>01189 VIGRA_SHAPE_OF(<span class="keywordtype">long</span> <span class="keywordtype">long</span>)
<a name="l01190"></a>01190 VIGRA_SHAPE_OF(<span class="keywordtype">float</span>)
<a name="l01191"></a>01191 VIGRA_SHAPE_OF(<span class="keywordtype">double</span>)
<a name="l01192"></a>01192 VIGRA_SHAPE_OF(<span class="keywordtype">long</span> <span class="keywordtype">double</span>)
<a name="l01193"></a>01193 
<a name="l01194"></a>01194 <span class="preprocessor">#undef VIGRA_SHAPE_OF</span>
<a name="l01195"></a>01195 <span class="preprocessor"></span>
<a name="l01196"></a>01196     <span class="comment">// LabelDispatch is only used in AccumulatorChainArrays and has the following functionalities:</span>
<a name="l01197"></a>01197     <span class="comment">//  * hold an accumulator chain for global statistics</span>
<a name="l01198"></a>01198     <span class="comment">//  * hold an array of accumulator chains (one per region) for region statistics</span>
<a name="l01199"></a>01199     <span class="comment">//  * forward data to the appropriate chains</span>
<a name="l01200"></a>01200     <span class="comment">//  * allocate the region array with appropriate size</span>
<a name="l01201"></a>01201     <span class="comment">//  * store and forward activation requests</span>
<a name="l01202"></a>01202     <span class="comment">//  * compute required number of passes as maximum from global and region accumulators</span>
<a name="l01203"></a>01203 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> GlobalAccumulators, <span class="keyword">class</span> RegionAccumulators&gt;
<a name="l01204"></a>01204 <span class="keyword">struct </span>LabelDispatch
<a name="l01205"></a>01205 {
<a name="l01206"></a>01206     <span class="keyword">typedef</span> LabelDispatchTag Tag;
<a name="l01207"></a>01207     <span class="keyword">typedef</span> GlobalAccumulators GlobalAccumulatorChain;
<a name="l01208"></a>01208     <span class="keyword">typedef</span> RegionAccumulators RegionAccumulatorChain;
<a name="l01209"></a>01209     <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupTag&lt;AccumulatorEnd, RegionAccumulatorChain&gt;::type::AccumulatorFlags ActiveFlagsType;
<a name="l01210"></a>01210     <span class="keyword">typedef</span> ArrayVector&lt;RegionAccumulatorChain&gt; RegionAccumulatorArray;
<a name="l01211"></a>01211         
<a name="l01212"></a>01212     <span class="keyword">typedef</span> LabelDispatch type;
<a name="l01213"></a>01213     <span class="keyword">typedef</span> LabelDispatch &amp; reference;
<a name="l01214"></a>01214     <span class="keyword">typedef</span> LabelDispatch <span class="keyword">const</span> &amp; const_reference;
<a name="l01215"></a>01215     <span class="keyword">typedef</span> GlobalAccumulatorChain InternalBaseType;
<a name="l01216"></a>01216     
<a name="l01217"></a>01217     <span class="keyword">typedef</span> T <span class="keyword">const</span> &amp; argument_type;
<a name="l01218"></a>01218     <span class="keyword">typedef</span> argument_type first_argument_type;
<a name="l01219"></a>01219     <span class="keyword">typedef</span> <span class="keywordtype">double</span> second_argument_type;
<a name="l01220"></a>01220     <span class="keyword">typedef</span> RegionAccumulatorChain &amp; result_type;
<a name="l01221"></a>01221     
<a name="l01222"></a>01222     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> index = GlobalAccumulatorChain::index + 1;
<a name="l01223"></a>01223     
<a name="l01224"></a>01224     <span class="keyword">template</span> &lt;<span class="keyword">class</span> IndexDefinition, <span class="keyword">class</span> TagFound=<span class="keyword">typename</span> IndexDefinition::Tag&gt;
<a name="l01225"></a>01225     <span class="keyword">struct </span>CoordIndexSelector
<a name="l01226"></a>01226     {
<a name="l01227"></a>01227         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> value = 0; <span class="comment">// default: CoupledHandle holds coordinates at index 0 </span>
<a name="l01228"></a>01228     };
<a name="l01229"></a>01229     
<a name="l01230"></a>01230     <span class="keyword">template</span> &lt;<span class="keyword">class</span> IndexDefinition&gt;
<a name="l01231"></a>01231     <span class="keyword">struct </span>CoordIndexSelector&lt;IndexDefinition, CoordArgTag&gt;
<a name="l01232"></a>01232     {
<a name="l01233"></a>01233         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> value = IndexDefinition::value;
<a name="l01234"></a>01234     };
<a name="l01235"></a>01235     
<a name="l01236"></a>01236     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> coordIndex = CoordIndexSelector&lt;typename LookupTag&lt;CoordArgTag, GlobalAccumulatorChain&gt;::type&gt;::value;
<a name="l01237"></a>01237     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> coordSize  = CoupledHandleCast&lt;coordIndex, T&gt;::type::value_type::static_size;
<a name="l01238"></a>01238     <span class="keyword">typedef</span> TinyVector&lt;double, coordSize&gt; CoordinateType;
<a name="l01239"></a>01239     
<a name="l01240"></a>01240     GlobalAccumulatorChain next_;
<a name="l01241"></a>01241     RegionAccumulatorArray regions_;
<a name="l01242"></a>01242     HistogramOptions region_histogram_options_;
<a name="l01243"></a>01243     <a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a> ignore_label_;
<a name="l01244"></a>01244     ActiveFlagsType active_region_accumulators_;
<a name="l01245"></a>01245     CoordinateType coordinateOffset_;
<a name="l01246"></a>01246     
<a name="l01247"></a>01247     <span class="keyword">template</span> &lt;<span class="keyword">class</span> IndexDefinition, <span class="keyword">class</span> TagFound=<span class="keyword">typename</span> IndexDefinition::Tag&gt;
<a name="l01248"></a>01248     <span class="keyword">struct </span>LabelIndexSelector
<a name="l01249"></a>01249     {
<a name="l01250"></a>01250         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> value = 2; <span class="comment">// default: CoupledHandle holds labels at index 2</span>
<a name="l01251"></a>01251 
<a name="l01252"></a>01252         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> NEXT&gt;
<a name="l01253"></a>01253         <span class="keyword">static</span> <a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a> exec(CoupledHandle&lt;U, NEXT&gt; <span class="keyword">const</span> &amp; t)
<a name="l01254"></a>01254         {
<a name="l01255"></a>01255             <span class="keywordflow">return</span> (<a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a>)get&lt;value&gt;(t); 
<a name="l01256"></a>01256         }
<a name="l01257"></a>01257     };
<a name="l01258"></a>01258     
<a name="l01259"></a>01259     <span class="keyword">template</span> &lt;<span class="keyword">class</span> IndexDefinition&gt;
<a name="l01260"></a>01260     <span class="keyword">struct </span>LabelIndexSelector&lt;IndexDefinition, LabelArgTag&gt;
<a name="l01261"></a>01261     {
<a name="l01262"></a>01262         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> value = IndexDefinition::value;
<a name="l01263"></a>01263 
<a name="l01264"></a>01264         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> NEXT&gt;
<a name="l01265"></a>01265         <span class="keyword">static</span> <a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a> exec(CoupledHandle&lt;U, NEXT&gt; <span class="keyword">const</span> &amp; t)
<a name="l01266"></a>01266         {
<a name="l01267"></a>01267             <span class="keywordflow">return</span> (<a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a>)get&lt;value&gt;(t);
<a name="l01268"></a>01268         }
<a name="l01269"></a>01269     };
<a name="l01270"></a>01270     
<a name="l01271"></a>01271     <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG&gt;
<a name="l01272"></a>01272     <span class="keyword">struct </span>ActivateImpl
<a name="l01273"></a>01273     {
<a name="l01274"></a>01274         <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupTag&lt;TAG, type&gt;::type TargetAccumulator;
<a name="l01275"></a>01275         
<a name="l01276"></a>01276         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="namespacevigra_1_1acc.html#a762643ee2596a5426da54cc3009ebfeb">activate</a>(GlobalAccumulatorChain &amp; globals, RegionAccumulatorArray &amp; regions, 
<a name="l01277"></a>01277                              ActiveFlagsType &amp; flags)
<a name="l01278"></a>01278         {
<a name="l01279"></a>01279             TargetAccumulator::template activateImpl&lt;LabelDispatch&gt;(
<a name="l01280"></a>01280                       flags, getAccumulator&lt;AccumulatorEnd&gt;(globals).active_accumulators_);
<a name="l01281"></a>01281             <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;regions.size(); ++k)
<a name="l01282"></a>01282                 getAccumulator&lt;AccumulatorEnd&gt;(regions[k]).active_accumulators_ = flags;
<a name="l01283"></a>01283         }
<a name="l01284"></a>01284         
<a name="l01285"></a>01285         <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="namespacevigra_1_1acc.html#a2f179339abc93d5b58a1f4bf530c80dd">isActive</a>(GlobalAccumulatorChain <span class="keyword">const</span> &amp;, ActiveFlagsType <span class="keyword">const</span> &amp; flags)
<a name="l01286"></a>01286         {
<a name="l01287"></a>01287             <span class="keywordflow">return</span> TargetAccumulator::isActiveImpl(flags);
<a name="l01288"></a>01288         }
<a name="l01289"></a>01289     };
<a name="l01290"></a>01290     
<a name="l01291"></a>01291     <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG&gt;
<a name="l01292"></a>01292     <span class="keyword">struct </span>ActivateImpl&lt;Global&lt;TAG&gt; &gt;
<a name="l01293"></a>01293     {
<a name="l01294"></a>01294         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="namespacevigra_1_1acc.html#a762643ee2596a5426da54cc3009ebfeb">activate</a>(GlobalAccumulatorChain &amp; globals, RegionAccumulatorArray &amp;, ActiveFlagsType &amp;)
<a name="l01295"></a>01295         {
<a name="l01296"></a>01296             LookupTag&lt;TAG, GlobalAccumulatorChain&gt;::type::activateImpl(getAccumulator&lt;AccumulatorEnd&gt;(globals).active_accumulators_);
<a name="l01297"></a>01297         }
<a name="l01298"></a>01298         
<a name="l01299"></a>01299         <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="namespacevigra_1_1acc.html#a2f179339abc93d5b58a1f4bf530c80dd">isActive</a>(GlobalAccumulatorChain <span class="keyword">const</span> &amp; globals, ActiveFlagsType <span class="keyword">const</span> &amp;)
<a name="l01300"></a>01300         {
<a name="l01301"></a>01301             <span class="keywordflow">return</span> LookupTag&lt;TAG, GlobalAccumulatorChain&gt;::type::isActiveImpl(getAccumulator&lt;AccumulatorEnd&gt;(globals).active_accumulators_);
<a name="l01302"></a>01302         }
<a name="l01303"></a>01303     };
<a name="l01304"></a>01304     
<a name="l01305"></a>01305     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> INDEX&gt;
<a name="l01306"></a>01306     <span class="keyword">struct </span>ActivateImpl&lt;LabelArg&lt;INDEX&gt; &gt;
<a name="l01307"></a>01307     {
<a name="l01308"></a>01308         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="namespacevigra_1_1acc.html#a762643ee2596a5426da54cc3009ebfeb">activate</a>(GlobalAccumulatorChain &amp;, RegionAccumulatorArray &amp;, ActiveFlagsType &amp;)
<a name="l01309"></a>01309         {}
<a name="l01310"></a>01310         
<a name="l01311"></a>01311         <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="namespacevigra_1_1acc.html#a2f179339abc93d5b58a1f4bf530c80dd">isActive</a>(GlobalAccumulatorChain <span class="keyword">const</span> &amp; globals, ActiveFlagsType <span class="keyword">const</span> &amp;)
<a name="l01312"></a>01312         {
<a name="l01313"></a>01313             <span class="keywordflow">return</span> getAccumulator&lt;LabelArg&lt;INDEX&gt; &gt;(globals).<a class="code" href="namespacevigra_1_1acc.html#a2f179339abc93d5b58a1f4bf530c80dd">isActive</a>();
<a name="l01314"></a>01314         }
<a name="l01315"></a>01315     };
<a name="l01316"></a>01316     
<a name="l01317"></a>01317     <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupTag&lt;LabelArgTag, GlobalAccumulatorChain&gt;::type FindLabelIndex;
<a name="l01318"></a>01318     
<a name="l01319"></a>01319     LabelDispatch()
<a name="l01320"></a>01320     : next_(),
<a name="l01321"></a>01321       regions_(),
<a name="l01322"></a>01322       region_histogram_options_(),
<a name="l01323"></a>01323       ignore_label_(-1),
<a name="l01324"></a>01324       active_region_accumulators_()
<a name="l01325"></a>01325     {}
<a name="l01326"></a>01326     
<a name="l01327"></a>01327     LabelDispatch(LabelDispatch <span class="keyword">const</span> &amp; o)
<a name="l01328"></a>01328     : next_(o.next_),
<a name="l01329"></a>01329       regions_(o.regions_),
<a name="l01330"></a>01330       region_histogram_options_(o.region_histogram_options_),
<a name="l01331"></a>01331       ignore_label_(o.ignore_label_),
<a name="l01332"></a>01332       active_region_accumulators_(o.active_region_accumulators_)
<a name="l01333"></a>01333     {
<a name="l01334"></a>01334         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;regions_.size(); ++k)
<a name="l01335"></a>01335         {
<a name="l01336"></a>01336             getAccumulator&lt;AccumulatorEnd&gt;(regions_[k]).setGlobalAccumulator(&amp;next_);
<a name="l01337"></a>01337         }
<a name="l01338"></a>01338     }
<a name="l01339"></a>01339     
<a name="l01340"></a>01340     <a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a> maxRegionLabel()<span class="keyword"> const</span>
<a name="l01341"></a>01341 <span class="keyword">    </span>{
<a name="l01342"></a>01342         <span class="keywordflow">return</span> (<a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a>)regions_.size() - 1;
<a name="l01343"></a>01343     }
<a name="l01344"></a>01344     
<a name="l01345"></a>01345     <span class="keywordtype">void</span> setMaxRegionLabel(<span class="keywordtype">unsigned</span> maxlabel)
<a name="l01346"></a>01346     {
<a name="l01347"></a>01347         <span class="keywordflow">if</span>(maxRegionLabel() == (<a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a>)maxlabel)
<a name="l01348"></a>01348             <span class="keywordflow">return</span>;
<a name="l01349"></a>01349         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oldSize = regions_.size();
<a name="l01350"></a>01350         regions_.resize(maxlabel + 1);
<a name="l01351"></a>01351         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=oldSize; k&lt;regions_.size(); ++k)
<a name="l01352"></a>01352         {
<a name="l01353"></a>01353             getAccumulator&lt;AccumulatorEnd&gt;(regions_[k]).setGlobalAccumulator(&amp;next_);
<a name="l01354"></a>01354             getAccumulator&lt;AccumulatorEnd&gt;(regions_[k]).active_accumulators_ = active_region_accumulators_;
<a name="l01355"></a>01355             regions_[k].applyHistogramOptions(region_histogram_options_);
<a name="l01356"></a>01356             regions_[k].setCoordinateOffsetImpl(coordinateOffset_);
<a name="l01357"></a>01357         }
<a name="l01358"></a>01358     }
<a name="l01359"></a>01359     
<a name="l01360"></a>01360     <span class="keywordtype">void</span> ignoreLabel(<a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a> l)
<a name="l01361"></a>01361     {
<a name="l01362"></a>01362         ignore_label_ = l;
<a name="l01363"></a>01363     }
<a name="l01364"></a>01364     
<a name="l01365"></a>01365     <span class="keywordtype">void</span> applyHistogramOptions(HistogramOptions <span class="keyword">const</span> &amp; options)
<a name="l01366"></a>01366     {
<a name="l01367"></a>01367         applyHistogramOptions(options, options);
<a name="l01368"></a>01368     }
<a name="l01369"></a>01369     
<a name="l01370"></a>01370     <span class="keywordtype">void</span> applyHistogramOptions(HistogramOptions <span class="keyword">const</span> &amp; regionoptions, HistogramOptions <span class="keyword">const</span> &amp; globaloptions)
<a name="l01371"></a>01371     {
<a name="l01372"></a>01372         region_histogram_options_ = regionoptions;
<a name="l01373"></a>01373         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;regions_.size(); ++k)
<a name="l01374"></a>01374         {
<a name="l01375"></a>01375             regions_[k].applyHistogramOptions(region_histogram_options_);
<a name="l01376"></a>01376         }
<a name="l01377"></a>01377         next_.applyHistogramOptions(globaloptions);
<a name="l01378"></a>01378     }
<a name="l01379"></a>01379     
<a name="l01380"></a>01380     <span class="keywordtype">void</span> setCoordinateOffsetImpl(CoordinateType <span class="keyword">const</span> &amp; offset)
<a name="l01381"></a>01381     {
<a name="l01382"></a>01382         coordinateOffset_ = offset;
<a name="l01383"></a>01383         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;regions_.size(); ++k)
<a name="l01384"></a>01384         {
<a name="l01385"></a>01385             regions_[k].setCoordinateOffsetImpl(coordinateOffset_);
<a name="l01386"></a>01386         }
<a name="l01387"></a>01387         next_.setCoordinateOffsetImpl(coordinateOffset_);
<a name="l01388"></a>01388     }
<a name="l01389"></a>01389     
<a name="l01390"></a>01390     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt;
<a name="l01391"></a>01391     <span class="keywordtype">void</span> resize(U <span class="keyword">const</span> &amp; t)
<a name="l01392"></a>01392     {
<a name="l01393"></a>01393         <span class="keywordflow">if</span>(regions_.size() == 0)
<a name="l01394"></a>01394         {
<a name="l01395"></a>01395             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> labelIndex = LabelIndexSelector&lt;FindLabelIndex&gt;::value;
<a name="l01396"></a>01396             <span class="keyword">typedef</span> <span class="keyword">typename</span> CoupledHandleCast&lt;labelIndex, T&gt;::type LabelHandle;
<a name="l01397"></a>01397             <span class="keyword">typedef</span> <span class="keyword">typename</span> LabelHandle::value_type LabelType;
<a name="l01398"></a>01398             <span class="keyword">typedef</span> MultiArrayView&lt;LabelHandle::dimensions, LabelType, StridedArrayTag&gt; LabelArray;
<a name="l01399"></a>01399             LabelArray labelArray(t.shape(), cast&lt;labelIndex&gt;(t).strides(), <span class="keyword">const_cast&lt;</span>LabelType *<span class="keyword">&gt;</span>(cast&lt;labelIndex&gt;(t).ptr()));
<a name="l01400"></a>01400             
<a name="l01401"></a>01401             LabelType minimum, maximum;
<a name="l01402"></a>01402             labelArray.minmax(&amp;minimum, &amp;maximum);
<a name="l01403"></a>01403             setMaxRegionLabel(maximum);
<a name="l01404"></a>01404         }
<a name="l01405"></a>01405         next_.resize(t);
<a name="l01406"></a>01406         <span class="comment">// FIXME: only call resize when label k actually exists?</span>
<a name="l01407"></a>01407         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;regions_.size(); ++k)
<a name="l01408"></a>01408             regions_[k].resize(t);
<a name="l01409"></a>01409     }
<a name="l01410"></a>01410     
<a name="l01411"></a>01411     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> N&gt;
<a name="l01412"></a>01412     <span class="keywordtype">void</span> pass(T <span class="keyword">const</span> &amp; t)
<a name="l01413"></a>01413     {
<a name="l01414"></a>01414         <span class="keywordflow">if</span>(LabelIndexSelector&lt;FindLabelIndex&gt;::exec(t) != ignore_label_)
<a name="l01415"></a>01415         {
<a name="l01416"></a>01416             next_.template pass&lt;N&gt;(t);
<a name="l01417"></a>01417             regions_[LabelIndexSelector&lt;FindLabelIndex&gt;::exec(t)].template pass&lt;N&gt;(t);
<a name="l01418"></a>01418         }
<a name="l01419"></a>01419     }
<a name="l01420"></a>01420     
<a name="l01421"></a>01421     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> N&gt;
<a name="l01422"></a>01422     <span class="keywordtype">void</span> pass(T <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l01423"></a>01423     {
<a name="l01424"></a>01424         <span class="keywordflow">if</span>(LabelIndexSelector&lt;FindLabelIndex&gt;::exec(t) != ignore_label_)
<a name="l01425"></a>01425         {
<a name="l01426"></a>01426             next_.template pass&lt;N&gt;(t, weight);
<a name="l01427"></a>01427             regions_[LabelIndexSelector&lt;FindLabelIndex&gt;::exec(t)].template pass&lt;N&gt;(t, weight);
<a name="l01428"></a>01428         }
<a name="l01429"></a>01429     }
<a name="l01430"></a>01430     
<a name="l01431"></a>01431     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> passesRequired()
<a name="l01432"></a>01432     {
<a name="l01433"></a>01433         <span class="keywordflow">return</span> std::max(GlobalAccumulatorChain::passesRequired(), RegionAccumulatorChain::passesRequired());
<a name="l01434"></a>01434     }
<a name="l01435"></a>01435     
<a name="l01436"></a>01436     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> passesRequiredDynamic()<span class="keyword"> const</span>
<a name="l01437"></a>01437 <span class="keyword">    </span>{
<a name="l01438"></a>01438         <span class="keywordflow">return</span> std::max(GlobalAccumulatorChain::passesRequired(getAccumulator&lt;AccumulatorEnd&gt;(next_).active_accumulators_), 
<a name="l01439"></a>01439                         RegionAccumulatorChain::passesRequired(active_region_accumulators_));
<a name="l01440"></a>01440     }
<a name="l01441"></a>01441     
<a name="l01442"></a>01442     <span class="keywordtype">void</span> reset()
<a name="l01443"></a>01443     {
<a name="l01444"></a>01444         next_.reset();
<a name="l01445"></a>01445         
<a name="l01446"></a>01446         active_region_accumulators_.clear();
<a name="l01447"></a>01447         RegionAccumulatorArray().swap(regions_);
<a name="l01448"></a>01448         <span class="comment">// FIXME: or is it better to just reset the region accumulators?</span>
<a name="l01449"></a>01449         <span class="comment">// for(unsigned int k=0; k&lt;regions_.size(); ++k)</span>
<a name="l01450"></a>01450             <span class="comment">// regions_[k].reset();</span>
<a name="l01451"></a>01451     }
<a name="l01452"></a>01452     
<a name="l01453"></a>01453     <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG&gt;
<a name="l01454"></a>01454     <span class="keywordtype">void</span> <a class="code" href="namespacevigra_1_1acc.html#a762643ee2596a5426da54cc3009ebfeb">activate</a>()
<a name="l01455"></a>01455     {
<a name="l01456"></a>01456         <a class="code" href="namespacevigra_1_1acc.html#a762643ee2596a5426da54cc3009ebfeb">ActivateImpl&lt;TAG&gt;::activate</a>(next_, regions_, active_region_accumulators_);
<a name="l01457"></a>01457     }
<a name="l01458"></a>01458     
<a name="l01459"></a>01459     <span class="keywordtype">void</span> activateAll()
<a name="l01460"></a>01460     {
<a name="l01461"></a>01461         getAccumulator&lt;AccumulatorEnd&gt;(next_).active_accumulators_.set();
<a name="l01462"></a>01462         active_region_accumulators_.set();
<a name="l01463"></a>01463         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;regions_.size(); ++k)
<a name="l01464"></a>01464             getAccumulator&lt;AccumulatorEnd&gt;(regions_[k]).active_accumulators_.set();
<a name="l01465"></a>01465     }
<a name="l01466"></a>01466     
<a name="l01467"></a>01467     <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG&gt;
<a name="l01468"></a>01468     <span class="keywordtype">bool</span> <a class="code" href="namespacevigra_1_1acc.html#a2f179339abc93d5b58a1f4bf530c80dd">isActive</a>()<span class="keyword"> const</span>
<a name="l01469"></a>01469 <span class="keyword">    </span>{
<a name="l01470"></a>01470         <span class="keywordflow">return</span> <a class="code" href="namespacevigra_1_1acc.html#a2f179339abc93d5b58a1f4bf530c80dd">ActivateImpl&lt;TAG&gt;::isActive</a>(next_, active_region_accumulators_);
<a name="l01471"></a>01471     }
<a name="l01472"></a>01472     
<a name="l01473"></a>01473     <span class="keywordtype">void</span> mergeImpl(LabelDispatch <span class="keyword">const</span> &amp; o)
<a name="l01474"></a>01474     {
<a name="l01475"></a>01475         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;regions_.size(); ++k)
<a name="l01476"></a>01476             regions_[k].mergeImpl(o.regions_[k]);
<a name="l01477"></a>01477         next_.mergeImpl(o.next_);
<a name="l01478"></a>01478     }
<a name="l01479"></a>01479     
<a name="l01480"></a>01480     <span class="keywordtype">void</span> mergeImpl(<span class="keywordtype">unsigned</span> i, <span class="keywordtype">unsigned</span> j)
<a name="l01481"></a>01481     {
<a name="l01482"></a>01482         regions_[i].mergeImpl(regions_[j]);
<a name="l01483"></a>01483         regions_[j].reset();
<a name="l01484"></a>01484         getAccumulator&lt;AccumulatorEnd&gt;(regions_[j]).active_accumulators_ = active_region_accumulators_;
<a name="l01485"></a>01485     }
<a name="l01486"></a>01486     
<a name="l01487"></a>01487     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ArrayLike&gt;
<a name="l01488"></a>01488     <span class="keywordtype">void</span> mergeImpl(LabelDispatch <span class="keyword">const</span> &amp; o, ArrayLike <span class="keyword">const</span> &amp; labelMapping)
<a name="l01489"></a>01489     {
<a name="l01490"></a>01490         <a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a> newMaxLabel = std::max&lt;MultiArrayIndex&gt;(maxRegionLabel(), *<a class="code" href="group__MathFunctions.html#gaf658d43400902a049a289c4e5ded84d9" title="Find the maximum element in a sequence.">argMax</a>(labelMapping.begin(), labelMapping.end()));
<a name="l01491"></a>01491         setMaxRegionLabel(newMaxLabel);
<a name="l01492"></a>01492         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;labelMapping.size(); ++k)
<a name="l01493"></a>01493             regions_[labelMapping[k]].mergeImpl(o.regions_[k]);
<a name="l01494"></a>01494         next_.mergeImpl(o.next_);
<a name="l01495"></a>01495     }
<a name="l01496"></a>01496 };
<a name="l01497"></a>01497 
<a name="l01498"></a>01498 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TargetTag, <span class="keyword">class</span> TagList&gt;
<a name="l01499"></a>01499 <span class="keyword">struct </span>FindNextTag;
<a name="l01500"></a>01500 
<a name="l01501"></a>01501 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TargetTag, <span class="keyword">class</span> HEAD, <span class="keyword">class</span> TAIL&gt;
<a name="l01502"></a>01502 <span class="keyword">struct </span>FindNextTag&lt;TargetTag, TypeList&lt;HEAD, TAIL&gt; &gt;
<a name="l01503"></a>01503 {
<a name="l01504"></a>01504     <span class="keyword">typedef</span> <span class="keyword">typename</span> FindNextTag&lt;TargetTag, TAIL&gt;::type type;
<a name="l01505"></a>01505 };
<a name="l01506"></a>01506 
<a name="l01507"></a>01507 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TargetTag, <span class="keyword">class</span> TAIL&gt;
<a name="l01508"></a>01508 <span class="keyword">struct </span>FindNextTag&lt;TargetTag, TypeList&lt;TargetTag, TAIL&gt; &gt;
<a name="l01509"></a>01509 {
<a name="l01510"></a>01510     <span class="keyword">typedef</span> <span class="keyword">typename</span> TAIL::Head type;
<a name="l01511"></a>01511 };
<a name="l01512"></a>01512 
<a name="l01513"></a>01513 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TargetTag&gt;
<a name="l01514"></a>01514 <span class="keyword">struct </span>FindNextTag&lt;TargetTag, TypeList&lt;TargetTag, void&gt; &gt;
<a name="l01515"></a>01515 {
<a name="l01516"></a>01516     <span class="keyword">typedef</span> <span class="keywordtype">void</span> type;
<a name="l01517"></a>01517 };
<a name="l01518"></a>01518 
<a name="l01519"></a>01519 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TargetTag&gt;
<a name="l01520"></a>01520 <span class="keyword">struct </span>FindNextTag&lt;TargetTag, void&gt;
<a name="l01521"></a>01521 {
<a name="l01522"></a>01522     <span class="keyword">typedef</span> <span class="keywordtype">void</span> type;
<a name="l01523"></a>01523 };
<a name="l01524"></a>01524 
<a name="l01525"></a>01525     <span class="comment">// AccumulatorFactory creates the decorator hierarchy for the given TAG and configuration CONFIG</span>
<a name="l01526"></a>01526 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG, <span class="keyword">class</span> CONFIG, <span class="keywordtype">unsigned</span> LEVEL=0&gt;
<a name="l01527"></a>01527 <span class="keyword">struct </span>AccumulatorFactory
<a name="l01528"></a>01528 {
<a name="l01529"></a>01529     <span class="keyword">typedef</span> <span class="keyword">typename</span> FindNextTag&lt;TAG, typename CONFIG::TagList&gt;::type NextTag;
<a name="l01530"></a>01530     <span class="keyword">typedef</span> <span class="keyword">typename</span> AccumulatorFactory&lt;NextTag, CONFIG, LEVEL+1&gt;::type NextType;
<a name="l01531"></a>01531     <span class="keyword">typedef</span> <span class="keyword">typename</span> CONFIG::InputType InputType;
<a name="l01532"></a>01532     
<a name="l01533"></a>01533     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01534"></a>01534     <span class="keyword">struct </span>ConfigureTag
<a name="l01535"></a>01535     {
<a name="l01536"></a>01536         <span class="keyword">typedef</span> TAG type;
<a name="l01537"></a>01537     };
<a name="l01538"></a>01538     
<a name="l01539"></a>01539         <span class="comment">// When InputType is a CoupledHandle, some tags need to be wrapped into </span>
<a name="l01540"></a>01540         <span class="comment">// DataFromHandle&lt;&gt; and/or Weighted&lt;&gt; modifiers. The following code does</span>
<a name="l01541"></a>01541         <span class="comment">// this when appropriate.</span>
<a name="l01542"></a>01542     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> NEXT&gt;
<a name="l01543"></a>01543     <span class="keyword">struct </span>ConfigureTag&lt;CoupledHandle&lt;T, NEXT&gt; &gt;
<a name="l01544"></a>01544     {
<a name="l01545"></a>01545         <span class="keyword">typedef</span> <span class="keyword">typename</span> StandardizeTag&lt;DataFromHandle&lt;TAG&gt; &gt;::type WrappedTag;
<a name="l01546"></a>01546         <span class="keyword">typedef</span> <span class="keyword">typename</span> IfBool&lt;(!HasModifierPriority&lt;WrappedTag, WeightingPriority&gt;::value &amp;&amp; ShouldBeWeighted&lt;WrappedTag&gt;::value),
<a name="l01547"></a>01547                                  Weighted&lt;WrappedTag&gt;, WrappedTag&gt;::type type;
<a name="l01548"></a>01548     };
<a name="l01549"></a>01549     
<a name="l01550"></a>01550     <span class="keyword">typedef</span> <span class="keyword">typename</span> ConfigureTag&lt;InputType&gt;::type UseTag;
<a name="l01551"></a>01551     
<a name="l01552"></a>01552         <span class="comment">// base class of the decorator hierarchy: default (possibly empty) </span>
<a name="l01553"></a>01553         <span class="comment">// implementations of all members</span>
<a name="l01554"></a>01554     <span class="keyword">struct </span>AccumulatorBase
<a name="l01555"></a>01555     {
<a name="l01556"></a>01556         <span class="keyword">typedef</span> AccumulatorBase              ThisType;
<a name="l01557"></a>01557         <span class="keyword">typedef</span> TAG                          Tag;
<a name="l01558"></a>01558         <span class="keyword">typedef</span> NextType                     InternalBaseType;
<a name="l01559"></a>01559         <span class="keyword">typedef</span> InputType                    input_type;
<a name="l01560"></a>01560         <span class="keyword">typedef</span> input_type <span class="keyword">const</span> &amp;           argument_type;
<a name="l01561"></a>01561         <span class="keyword">typedef</span> argument_type                first_argument_type;
<a name="l01562"></a>01562         <span class="keyword">typedef</span> <span class="keywordtype">double</span>                       second_argument_type;
<a name="l01563"></a>01563         <span class="keyword">typedef</span> <span class="keywordtype">void</span>                         result_type;
<a name="l01564"></a>01564         
<a name="l01565"></a>01565         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            workInPass = 1;
<a name="l01566"></a>01566         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span>                     index = InternalBaseType::index + 1;
<a name="l01567"></a>01567         
<a name="l01568"></a>01568         InternalBaseType next_;
<a name="l01569"></a>01569         
<a name="l01570"></a>01570         <span class="keyword">static</span> std::string name()
<a name="l01571"></a>01571         {
<a name="l01572"></a>01572             <span class="keywordflow">return</span> TAG::name();
<a name="l01573"></a>01573         }
<a name="l01574"></a>01574         
<a name="l01575"></a>01575         <span class="keyword">template</span> &lt;<span class="keyword">class</span> ActiveFlags&gt;
<a name="l01576"></a>01576         <span class="keyword">static</span> <span class="keywordtype">void</span> activateImpl(ActiveFlags &amp; flags)
<a name="l01577"></a>01577         {
<a name="l01578"></a>01578             flags.template set&lt;index&gt;();
<a name="l01579"></a>01579             <span class="keyword">typedef</span> <span class="keyword">typename</span> StandardizeDependencies&lt;Tag&gt;::type StdDeps;
<a name="l01580"></a>01580             acc_detail::ActivateDependencies&lt;StdDeps&gt;::template exec&lt;ThisType&gt;(flags);
<a name="l01581"></a>01581         }
<a name="l01582"></a>01582         
<a name="l01583"></a>01583         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Accu, <span class="keyword">class</span> ActiveFlags, <span class="keyword">class</span> GlobalFlags&gt;
<a name="l01584"></a>01584         <span class="keyword">static</span> <span class="keywordtype">void</span> activateImpl(ActiveFlags &amp; flags, GlobalFlags &amp; gflags)
<a name="l01585"></a>01585         {
<a name="l01586"></a>01586             flags.template set&lt;index&gt;();
<a name="l01587"></a>01587             <span class="keyword">typedef</span> <span class="keyword">typename</span> StandardizeDependencies&lt;Tag&gt;::type StdDeps;
<a name="l01588"></a>01588             acc_detail::ActivateDependencies&lt;StdDeps&gt;::template exec&lt;Accu&gt;(flags, gflags);
<a name="l01589"></a>01589         }
<a name="l01590"></a>01590         
<a name="l01591"></a>01591         <span class="keyword">template</span> &lt;<span class="keyword">class</span> ActiveFlags&gt;
<a name="l01592"></a>01592         <span class="keyword">static</span> <span class="keywordtype">bool</span> isActiveImpl(ActiveFlags &amp; flags)
<a name="l01593"></a>01593         {
<a name="l01594"></a>01594             <span class="keywordflow">return</span> flags.template test&lt;index&gt;();
<a name="l01595"></a>01595         }
<a name="l01596"></a>01596         
<a name="l01597"></a>01597         <span class="keywordtype">void</span> setDirty()<span class="keyword"> const</span>
<a name="l01598"></a>01598 <span class="keyword">        </span>{
<a name="l01599"></a>01599             next_.template setDirtyImpl&lt;index&gt;();
<a name="l01600"></a>01600         }
<a name="l01601"></a>01601         
<a name="l01602"></a>01602         <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> INDEX&gt;
<a name="l01603"></a>01603         <span class="keywordtype">void</span> setDirtyImpl()<span class="keyword"> const</span>
<a name="l01604"></a>01604 <span class="keyword">        </span>{
<a name="l01605"></a>01605             next_.template setDirtyImpl&lt;INDEX&gt;();
<a name="l01606"></a>01606         }
<a name="l01607"></a>01607         
<a name="l01608"></a>01608         <span class="keywordtype">void</span> setClean()<span class="keyword"> const</span>
<a name="l01609"></a>01609 <span class="keyword">        </span>{
<a name="l01610"></a>01610             next_.template setCleanImpl&lt;index&gt;();
<a name="l01611"></a>01611         }
<a name="l01612"></a>01612         
<a name="l01613"></a>01613         <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> INDEX&gt;
<a name="l01614"></a>01614         <span class="keywordtype">void</span> setCleanImpl()<span class="keyword"> const</span>
<a name="l01615"></a>01615 <span class="keyword">        </span>{
<a name="l01616"></a>01616             next_.template setCleanImpl&lt;INDEX&gt;();
<a name="l01617"></a>01617         }
<a name="l01618"></a>01618         
<a name="l01619"></a>01619         <span class="keywordtype">bool</span> isDirty()<span class="keyword"> const</span>
<a name="l01620"></a>01620 <span class="keyword">        </span>{
<a name="l01621"></a>01621             <span class="keywordflow">return</span> next_.template isDirtyImpl&lt;index&gt;();
<a name="l01622"></a>01622         }
<a name="l01623"></a>01623         
<a name="l01624"></a>01624         <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> INDEX&gt;
<a name="l01625"></a>01625         <span class="keywordtype">bool</span> isDirtyImpl()<span class="keyword"> const</span>
<a name="l01626"></a>01626 <span class="keyword">        </span>{
<a name="l01627"></a>01627             <span class="keywordflow">return</span> next_.template isDirtyImpl&lt;INDEX&gt;();
<a name="l01628"></a>01628         }
<a name="l01629"></a>01629         
<a name="l01630"></a>01630         <span class="keywordtype">void</span> reset()
<a name="l01631"></a>01631         {}
<a name="l01632"></a>01632         
<a name="l01633"></a>01633         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Shape&gt;
<a name="l01634"></a>01634         <span class="keywordtype">void</span> setCoordinateOffset(Shape <span class="keyword">const</span> &amp;)
<a name="l01635"></a>01635         {}
<a name="l01636"></a>01636         
<a name="l01637"></a>01637         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Shape&gt;
<a name="l01638"></a>01638         <span class="keywordtype">void</span> reshape(Shape <span class="keyword">const</span> &amp;)
<a name="l01639"></a>01639         {}
<a name="l01640"></a>01640         
<a name="l01641"></a>01641         <span class="keywordtype">void</span> <a class="code" href="group__FFTWComplexOperators.html#ga23c9113f38123caf2ae30a59a1a5cfc5" title="add-assignment">operator+=</a>(AccumulatorBase <span class="keyword">const</span> &amp;)
<a name="l01642"></a>01642         {}
<a name="l01643"></a>01643         
<a name="l01644"></a>01644         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt;
<a name="l01645"></a>01645         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp;)
<a name="l01646"></a>01646         {}
<a name="l01647"></a>01647         
<a name="l01648"></a>01648         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt;
<a name="l01649"></a>01649         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp;, <span class="keywordtype">double</span>)
<a name="l01650"></a>01650         {}
<a name="l01651"></a>01651         
<a name="l01652"></a>01652         <span class="keyword">template</span> &lt;<span class="keyword">class</span> TargetTag&gt;
<a name="l01653"></a>01653         <span class="keyword">typename</span> LookupDependency&lt;TargetTag, ThisType&gt;::result_type
<a name="l01654"></a>01654         call_getDependency()<span class="keyword"> const</span>
<a name="l01655"></a>01655 <span class="keyword">        </span>{
<a name="l01656"></a>01656             <span class="keywordflow">return</span> getDependency&lt;TargetTag&gt;(*this);
<a name="l01657"></a>01657         }
<a name="l01658"></a>01658     };
<a name="l01659"></a>01659 
<a name="l01660"></a>01660         <span class="comment">// The middle class(es) of the decorator hierarchy implement the actual feature computation.</span>
<a name="l01661"></a>01661     <span class="keyword">typedef</span> <span class="keyword">typename</span> UseTag::template Impl&lt;InputType, AccumulatorBase&gt; AccumulatorImpl;
<a name="l01662"></a>01662     
<a name="l01663"></a>01663         <span class="comment">// outer class of the decorator hierarchy. It has the following functionalities</span>
<a name="l01664"></a>01664         <span class="comment">//  * ensure that only active accumulators are called in a dynamic accumulator chain</span>
<a name="l01665"></a>01665         <span class="comment">//  * ensure that each accumulator is only called in its desired pass as defined in A::workInPass</span>
<a name="l01666"></a>01666         <span class="comment">//  * determine how many passes through the data are required</span>
<a name="l01667"></a>01667     <span class="keyword">struct </span>Accumulator
<a name="l01668"></a>01668     : <span class="keyword">public</span> AccumulatorImpl
<a name="l01669"></a>01669     {
<a name="l01670"></a>01670         <span class="keyword">typedef</span> Accumulator type;
<a name="l01671"></a>01671         <span class="keyword">typedef</span> Accumulator &amp; reference;
<a name="l01672"></a>01672         <span class="keyword">typedef</span> Accumulator <span class="keyword">const</span> &amp; const_reference;
<a name="l01673"></a>01673         <span class="keyword">typedef</span> AccumulatorImpl A;
<a name="l01674"></a>01674         
<a name="l01675"></a>01675         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> workInPass = A::workInPass;
<a name="l01676"></a>01676         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> allowRuntimeActivation = CONFIG::allowRuntimeActivation;
<a name="l01677"></a>01677         
<a name="l01678"></a>01678         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01679"></a>01679         <span class="keywordtype">void</span> resize(T <span class="keyword">const</span> &amp; t)
<a name="l01680"></a>01680         {
<a name="l01681"></a>01681             this-&gt;next_.resize(t);
<a name="l01682"></a>01682             DecoratorImpl&lt;Accumulator, workInPass, allowRuntimeActivation&gt;::resize(*<span class="keyword">this</span>, t);
<a name="l01683"></a>01683         }
<a name="l01684"></a>01684         
<a name="l01685"></a>01685         <span class="keywordtype">void</span> reset()
<a name="l01686"></a>01686         {
<a name="l01687"></a>01687             this-&gt;next_.reset();
<a name="l01688"></a>01688             A::reset();
<a name="l01689"></a>01689         }
<a name="l01690"></a>01690         
<a name="l01691"></a>01691         <span class="keyword">typename</span> A::result_type <span class="keyword">get</span>() <span class="keyword">const</span>
<a name="l01692"></a>01692         {
<a name="l01693"></a>01693             <span class="keywordflow">return</span> <a class="code" href="namespacevigra_1_1acc.html#ae1dae7352beb92b0f5b64b44d4fca420">DecoratorImpl&lt;A, workInPass, allowRuntimeActivation&gt;::get</a>(*<span class="keyword">this</span>);
<a name="l01694"></a>01694         }
<a name="l01695"></a>01695         
<a name="l01696"></a>01696         <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> N, <span class="keyword">class</span> T&gt;
<a name="l01697"></a>01697         <span class="keywordtype">void</span> pass(T <span class="keyword">const</span> &amp; t)
<a name="l01698"></a>01698         {
<a name="l01699"></a>01699             this-&gt;next_.template pass&lt;N&gt;(t);
<a name="l01700"></a>01700             DecoratorImpl&lt;Accumulator, N, allowRuntimeActivation&gt;::exec(*<span class="keyword">this</span>, t);
<a name="l01701"></a>01701         }
<a name="l01702"></a>01702         
<a name="l01703"></a>01703         <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> N, <span class="keyword">class</span> T&gt;
<a name="l01704"></a>01704         <span class="keywordtype">void</span> pass(T <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l01705"></a>01705         {
<a name="l01706"></a>01706             this-&gt;next_.template pass&lt;N&gt;(t, weight);
<a name="l01707"></a>01707             DecoratorImpl&lt;Accumulator, N, allowRuntimeActivation&gt;::exec(*<span class="keyword">this</span>, t, weight);
<a name="l01708"></a>01708         }
<a name="l01709"></a>01709         
<a name="l01710"></a>01710         <span class="keywordtype">void</span> mergeImpl(Accumulator <span class="keyword">const</span> &amp; o)
<a name="l01711"></a>01711         {
<a name="l01712"></a>01712             DecoratorImpl&lt;Accumulator, Accumulator::workInPass, allowRuntimeActivation&gt;::mergeImpl(*<span class="keyword">this</span>, o);
<a name="l01713"></a>01713             this-&gt;next_.mergeImpl(o.next_);
<a name="l01714"></a>01714         }
<a name="l01715"></a>01715         
<a name="l01716"></a>01716         <span class="keywordtype">void</span> applyHistogramOptions(HistogramOptions <span class="keyword">const</span> &amp; options)
<a name="l01717"></a>01717         {
<a name="l01718"></a>01718             DecoratorImpl&lt;Accumulator, workInPass, allowRuntimeActivation&gt;::applyHistogramOptions(*<span class="keyword">this</span>, options);
<a name="l01719"></a>01719             this-&gt;next_.applyHistogramOptions(options);
<a name="l01720"></a>01720         }
<a name="l01721"></a>01721         
<a name="l01722"></a>01722         <span class="keyword">template</span> &lt;<span class="keyword">class</span> SHAPE&gt;
<a name="l01723"></a>01723         <span class="keywordtype">void</span> setCoordinateOffsetImpl(SHAPE <span class="keyword">const</span> &amp; offset)
<a name="l01724"></a>01724         {
<a name="l01725"></a>01725             this-&gt;setCoordinateOffset(offset);
<a name="l01726"></a>01726             this-&gt;next_.setCoordinateOffsetImpl(offset);
<a name="l01727"></a>01727         }
<a name="l01728"></a>01728         
<a name="l01729"></a>01729         <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> passesRequired()
<a name="l01730"></a>01730         {
<a name="l01731"></a>01731             <span class="keywordflow">return</span> DecoratorImpl&lt;Accumulator, workInPass, allowRuntimeActivation&gt;::passesRequired();
<a name="l01732"></a>01732         }
<a name="l01733"></a>01733         
<a name="l01734"></a>01734         <span class="keyword">template</span> &lt;<span class="keyword">class</span> ActiveFlags&gt;
<a name="l01735"></a>01735         <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> passesRequired(ActiveFlags <span class="keyword">const</span> &amp; flags)
<a name="l01736"></a>01736         {
<a name="l01737"></a>01737             <span class="keywordflow">return</span> DecoratorImpl&lt;Accumulator, workInPass, allowRuntimeActivation&gt;::passesRequired(flags);
<a name="l01738"></a>01738         }
<a name="l01739"></a>01739     };
<a name="l01740"></a>01740 
<a name="l01741"></a>01741     <span class="keyword">typedef</span> Accumulator type;
<a name="l01742"></a>01742 };
<a name="l01743"></a>01743 
<a name="l01744"></a>01744 <span class="keyword">template</span> &lt;<span class="keyword">class</span> CONFIG, <span class="keywordtype">unsigned</span> LEVEL&gt;
<a name="l01745"></a>01745 <span class="keyword">struct </span>AccumulatorFactory&lt;void, CONFIG, LEVEL&gt;
<a name="l01746"></a>01746 {
<a name="l01747"></a>01747     <span class="keyword">typedef</span> AccumulatorEndImpl&lt;LEVEL, typename CONFIG::GlobalAccumulatorHandle&gt; type;
<a name="l01748"></a>01748 };
<a name="l01749"></a>01749 
<a name="l01750"></a>01750 <span class="keyword">struct </span>InvalidGlobalAccumulatorHandle
<a name="l01751"></a>01751 {
<a name="l01752"></a>01752     <span class="keyword">typedef</span> Error__Global_statistics_are_only_defined_for_AccumulatorChainArray type;
<a name="l01753"></a>01753     
<a name="l01754"></a>01754     InvalidGlobalAccumulatorHandle()
<a name="l01755"></a>01755     : pointer_(0)
<a name="l01756"></a>01756     {}
<a name="l01757"></a>01757     
<a name="l01758"></a>01758     type <span class="keyword">const</span> * pointer_;
<a name="l01759"></a>01759 };
<a name="l01760"></a>01760 
<a name="l01761"></a>01761     <span class="comment">// helper classes to create an accumulator chain from a TypeList</span>
<a name="l01762"></a>01762     <span class="comment">// if dynamic=true,  a dynamic accumulator will be created</span>
<a name="l01763"></a>01763     <span class="comment">// if dynamic=false, a plain accumulator will be created</span>
<a name="l01764"></a>01764 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Selected, <span class="keywordtype">bool</span> dynamic=false, <span class="keyword">class</span> GlobalHandle=Inval<span class="keywordtype">id</span>GlobalAccumulatorHandle&gt;
<a name="l01765"></a>01765 <span class="keyword">struct </span>ConfigureAccumulatorChain
<a name="l01766"></a>01766 #ifndef DOXYGEN
<a name="l01767"></a>01767 : <span class="keyword">public</span> ConfigureAccumulatorChain&lt;T, typename AddDependencies&lt;typename Selected::type&gt;::type, dynamic&gt;
<a name="l01768"></a>01768 <span class="preprocessor">#endif</span>
<a name="l01769"></a>01769 <span class="preprocessor"></span>{};
<a name="l01770"></a>01770 
<a name="l01771"></a>01771 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> HEAD, <span class="keyword">class</span> TAIL, <span class="keywordtype">bool</span> dynamic, <span class="keyword">class</span> GlobalHandle&gt;
<a name="l01772"></a>01772 <span class="keyword">struct </span>ConfigureAccumulatorChain&lt;T, TypeList&lt;HEAD, TAIL&gt;, dynamic, GlobalHandle&gt;
<a name="l01773"></a>01773 {
<a name="l01774"></a>01774     <span class="keyword">typedef</span> TypeList&lt;HEAD, TAIL&gt; TagList;
<a name="l01775"></a>01775     <span class="keyword">typedef</span> T InputType;
<a name="l01776"></a>01776     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> allowRuntimeActivation = dynamic;
<a name="l01777"></a>01777     <span class="keyword">typedef</span> GlobalHandle GlobalAccumulatorHandle;
<a name="l01778"></a>01778  
<a name="l01779"></a>01779     <span class="keyword">typedef</span> <span class="keyword">typename</span> AccumulatorFactory&lt;HEAD, ConfigureAccumulatorChain&gt;::type type;
<a name="l01780"></a>01780 };
<a name="l01781"></a>01781 
<a name="l01782"></a>01782 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Selected, <span class="keywordtype">bool</span> dynamic=false&gt;
<a name="l01783"></a>01783 <span class="keyword">struct </span>ConfigureAccumulatorChainArray
<a name="l01784"></a>01784 #ifndef DOXYGEN
<a name="l01785"></a>01785 : <span class="keyword">public</span> ConfigureAccumulatorChainArray&lt;T, typename AddDependencies&lt;typename Selected::type&gt;::type, dynamic&gt;
<a name="l01786"></a>01786 <span class="preprocessor">#endif</span>
<a name="l01787"></a>01787 <span class="preprocessor"></span>{};
<a name="l01788"></a>01788 
<a name="l01789"></a>01789 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> HEAD, <span class="keyword">class</span> TAIL, <span class="keywordtype">bool</span> dynamic&gt;
<a name="l01790"></a>01790 <span class="keyword">struct </span>ConfigureAccumulatorChainArray&lt;T, TypeList&lt;HEAD, TAIL&gt;, dynamic&gt;
<a name="l01791"></a>01791 {
<a name="l01792"></a>01792     <span class="keyword">typedef</span> TypeList&lt;HEAD, TAIL&gt; TagList;
<a name="l01793"></a>01793     <span class="keyword">typedef</span> SeparateGlobalAndRegionTags&lt;TagList&gt; TagSeparator;
<a name="l01794"></a>01794     <span class="keyword">typedef</span> <span class="keyword">typename</span> TagSeparator::GlobalTags GlobalTags;
<a name="l01795"></a>01795     <span class="keyword">typedef</span> <span class="keyword">typename</span> TagSeparator::RegionTags RegionTags;
<a name="l01796"></a>01796     <span class="keyword">typedef</span> <span class="keyword">typename</span> ConfigureAccumulatorChain&lt;T, GlobalTags, dynamic&gt;::type GlobalAccumulatorChain;
<a name="l01797"></a>01797 
<a name="l01798"></a>01798     <span class="keyword">struct </span>GlobalAccumulatorHandle
<a name="l01799"></a>01799     {
<a name="l01800"></a>01800         <span class="keyword">typedef</span> GlobalAccumulatorChain type;
<a name="l01801"></a>01801         
<a name="l01802"></a>01802         GlobalAccumulatorHandle()
<a name="l01803"></a>01803         : pointer_(0)
<a name="l01804"></a>01804         {}
<a name="l01805"></a>01805         
<a name="l01806"></a>01806         type <span class="keyword">const</span> * pointer_;
<a name="l01807"></a>01807     };
<a name="l01808"></a>01808     
<a name="l01809"></a>01809     <span class="keyword">typedef</span> <span class="keyword">typename</span> ConfigureAccumulatorChain&lt;T, RegionTags, dynamic, GlobalAccumulatorHandle&gt;::type RegionAccumulatorChain;
<a name="l01810"></a>01810     
<a name="l01811"></a>01811     <span class="keyword">typedef</span> LabelDispatch&lt;T, GlobalAccumulatorChain, RegionAccumulatorChain&gt; type;
<a name="l01812"></a>01812 };
<a name="l01813"></a>01813 
<a name="l01814"></a>01814 } <span class="comment">// namespace acc_detail </span>
<a name="l01815"></a>01815 
<a name="l01816"></a>01816 <span class="comment">/****************************************************************************/</span>
<a name="l01817"></a>01817 <span class="comment">/*                                                                          */</span>
<a name="l01818"></a>01818 <span class="comment">/*                            accumulator chain                             */</span>
<a name="l01819"></a>01819 <span class="comment">/*                                                                          */</span>
<a name="l01820"></a>01820 <span class="comment">/****************************************************************************/</span>
<a name="l01821"></a>01821 
<a name="l01822"></a>01822 <span class="comment">// Implement the high-level interface of an accumulator chain</span>
<a name="l01823"></a>01823 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> NEXT&gt;
<a name="l01824"></a>01824 <span class="keyword">class </span>AccumulatorChainImpl
<a name="l01825"></a>01825 {
<a name="l01826"></a>01826   <span class="keyword">public</span>:
<a name="l01827"></a>01827     <span class="keyword">typedef</span> NEXT                                             InternalBaseType;
<a name="l01828"></a>01828     <span class="keyword">typedef</span> AccumulatorBegin                                 Tag;
<a name="l01829"></a>01829     <span class="keyword">typedef</span> <span class="keyword">typename</span> InternalBaseType::argument_type         argument_type;
<a name="l01830"></a>01830     <span class="keyword">typedef</span> <span class="keyword">typename</span> InternalBaseType::first_argument_type   first_argument_type;
<a name="l01831"></a>01831     <span class="keyword">typedef</span> <span class="keyword">typename</span> InternalBaseType::second_argument_type  second_argument_type;
<a name="l01832"></a>01832     <span class="keyword">typedef</span> <span class="keywordtype">void</span>                                             value_type;
<a name="l01833"></a>01833     <span class="keyword">typedef</span> <span class="keyword">typename</span> InternalBaseType::result_type           result_type;
<a name="l01834"></a>01834     
<a name="l01835"></a>01835     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> staticSize = InternalBaseType::index;
<a name="l01836"></a>01836 
<a name="l01837"></a>01837     InternalBaseType next_;
<a name="l01838"></a>01838 <span class="comment"></span>
<a name="l01839"></a>01839 <span class="comment">    /** \brief Current pass of the accumulator chain.</span>
<a name="l01840"></a>01840 <span class="comment">    */</span>
<a name="l01841"></a>01841     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_pass_;
<a name="l01842"></a>01842     
<a name="l01843"></a>01843     AccumulatorChainImpl()
<a name="l01844"></a>01844     : current_pass_(0)
<a name="l01845"></a>01845     {}
<a name="l01846"></a>01846 <span class="comment"></span>
<a name="l01847"></a>01847 <span class="comment">    /** Set options for all histograms in the accumulator chain. See histogram accumulators for possible options. The function is ignored if there is no histogram in the accumulator chain.</span>
<a name="l01848"></a>01848 <span class="comment">    */</span>
<a name="l01849"></a>01849     <span class="keywordtype">void</span> setHistogramOptions(HistogramOptions <span class="keyword">const</span> &amp; options)
<a name="l01850"></a>01850     {
<a name="l01851"></a>01851         next_.applyHistogramOptions(options);
<a name="l01852"></a>01852     }
<a name="l01853"></a>01853     
<a name="l01854"></a>01854 <span class="comment"></span>
<a name="l01855"></a>01855 <span class="comment">    /** Set regional and global options for all histograms in the accumulator chain.</span>
<a name="l01856"></a>01856 <span class="comment">    */</span>
<a name="l01857"></a>01857     <span class="keywordtype">void</span> setHistogramOptions(HistogramOptions <span class="keyword">const</span> &amp; regionoptions, HistogramOptions <span class="keyword">const</span> &amp; globaloptions)
<a name="l01858"></a>01858     {
<a name="l01859"></a>01859         next_.applyHistogramOptions(regionoptions, globaloptions);
<a name="l01860"></a>01860     }
<a name="l01861"></a>01861     <span class="comment"></span>
<a name="l01862"></a>01862 <span class="comment">    /** Set an offset for &lt;tt&gt;Coord&lt;...&gt;&lt;/tt&gt; statistics.</span>
<a name="l01863"></a>01863 <span class="comment">    </span>
<a name="l01864"></a>01864 <span class="comment">        If the offset is non-zero, coordinate statistics such as &lt;tt&gt;RegionCenter&lt;/tt&gt; are computed</span>
<a name="l01865"></a>01865 <span class="comment">        in the global coordinate system defined by the \a offset. Without an offset, these statistics</span>
<a name="l01866"></a>01866 <span class="comment">        are computed in the local coordinate system of the current region of interest.</span>
<a name="l01867"></a>01867 <span class="comment">    */</span>    
<a name="l01868"></a>01868     <span class="keyword">template</span> &lt;<span class="keyword">class</span> SHAPE&gt;
<a name="l01869"></a>01869     <span class="keywordtype">void</span> setCoordinateOffset(SHAPE <span class="keyword">const</span> &amp; offset)
<a name="l01870"></a>01870     {
<a name="l01871"></a>01871         next_.setCoordinateOffsetImpl(offset);
<a name="l01872"></a>01872     }
<a name="l01873"></a>01873     <span class="comment"></span>
<a name="l01874"></a>01874 <span class="comment">    /** Reset current_pass_ of the accumulator chain to &#39;reset_to_pass&#39;.</span>
<a name="l01875"></a>01875 <span class="comment">    */</span>
<a name="l01876"></a>01876     <span class="keywordtype">void</span> reset(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> reset_to_pass = 0)
<a name="l01877"></a>01877     {
<a name="l01878"></a>01878         current_pass_ = reset_to_pass;
<a name="l01879"></a>01879         <span class="keywordflow">if</span>(reset_to_pass == 0)
<a name="l01880"></a>01880             next_.reset();
<a name="l01881"></a>01881     }
<a name="l01882"></a>01882     
<a name="l01883"></a>01883     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> N&gt;
<a name="l01884"></a>01884     <span class="keywordtype">void</span> update(T <span class="keyword">const</span> &amp; t)
<a name="l01885"></a>01885     {
<a name="l01886"></a>01886         <span class="keywordflow">if</span>(current_pass_ == N)
<a name="l01887"></a>01887         {
<a name="l01888"></a>01888             next_.template pass&lt;N&gt;(t);
<a name="l01889"></a>01889         }
<a name="l01890"></a>01890         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(current_pass_ &lt; N)
<a name="l01891"></a>01891         {
<a name="l01892"></a>01892             current_pass_ = N;
<a name="l01893"></a>01893             <span class="keywordflow">if</span>(N == 1)
<a name="l01894"></a>01894                 next_.resize(acc_detail::shapeOf(t));
<a name="l01895"></a>01895             next_.template pass&lt;N&gt;(t);
<a name="l01896"></a>01896         }
<a name="l01897"></a>01897         <span class="keywordflow">else</span>
<a name="l01898"></a>01898         {
<a name="l01899"></a>01899             std::string message(<span class="stringliteral">&quot;AccumulatorChain::update(): cannot return to pass &quot;</span>);
<a name="l01900"></a>01900             message &lt;&lt; N &lt;&lt; <span class="stringliteral">&quot; after working on pass &quot;</span> &lt;&lt; current_pass_ &lt;&lt; <span class="stringliteral">&quot;.&quot;</span>;
<a name="l01901"></a>01901             vigra_precondition(<span class="keyword">false</span>, message);
<a name="l01902"></a>01902         }
<a name="l01903"></a>01903     }
<a name="l01904"></a>01904     
<a name="l01905"></a>01905     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> N&gt;
<a name="l01906"></a>01906     <span class="keywordtype">void</span> update(T <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l01907"></a>01907     {
<a name="l01908"></a>01908         <span class="keywordflow">if</span>(current_pass_ == N)
<a name="l01909"></a>01909         {
<a name="l01910"></a>01910             next_.template pass&lt;N&gt;(t, weight);
<a name="l01911"></a>01911         }
<a name="l01912"></a>01912         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(current_pass_ &lt; N)
<a name="l01913"></a>01913         {
<a name="l01914"></a>01914             current_pass_ = N;
<a name="l01915"></a>01915             <span class="keywordflow">if</span>(N == 1)
<a name="l01916"></a>01916                 next_.resize(acc_detail::shapeOf(t));
<a name="l01917"></a>01917             next_.template pass&lt;N&gt;(t, weight);
<a name="l01918"></a>01918         }
<a name="l01919"></a>01919         <span class="keywordflow">else</span>
<a name="l01920"></a>01920         {
<a name="l01921"></a>01921             std::string message(<span class="stringliteral">&quot;AccumulatorChain::update(): cannot return to pass &quot;</span>);
<a name="l01922"></a>01922             message &lt;&lt; N &lt;&lt; <span class="stringliteral">&quot; after working on pass &quot;</span> &lt;&lt; current_pass_ &lt;&lt; <span class="stringliteral">&quot;.&quot;</span>;
<a name="l01923"></a>01923             vigra_precondition(<span class="keyword">false</span>, message);
<a name="l01924"></a>01924        }
<a name="l01925"></a>01925     }
<a name="l01926"></a>01926     <span class="comment"></span>
<a name="l01927"></a>01927 <span class="comment">    /** Equivalent to merge(o) .</span>
<a name="l01928"></a>01928 <span class="comment">    */</span>
<a name="l01929"></a>01929     <span class="keywordtype">void</span> <a class="code" href="group__FFTWComplexOperators.html#ga23c9113f38123caf2ae30a59a1a5cfc5" title="add-assignment">operator+=</a>(AccumulatorChainImpl <span class="keyword">const</span> &amp; o)
<a name="l01930"></a>01930     {
<a name="l01931"></a>01931         merge(o);
<a name="l01932"></a>01932     }
<a name="l01933"></a>01933     <span class="comment"></span>
<a name="l01934"></a>01934 <span class="comment">    /** Merge the accumulator chain with accumulator chain &#39;o&#39;. This only works if all selected statistics in the accumulator chain support the &#39;+=&#39; operator. See the documentations of the particular statistics for support information.</span>
<a name="l01935"></a>01935 <span class="comment">    */</span>
<a name="l01936"></a>01936     <span class="keywordtype">void</span> merge(AccumulatorChainImpl <span class="keyword">const</span> &amp; o)
<a name="l01937"></a>01937     {
<a name="l01938"></a>01938         next_.mergeImpl(o.next_);
<a name="l01939"></a>01939     }
<a name="l01940"></a>01940 
<a name="l01941"></a>01941     result_type operator()()<span class="keyword"> const</span>
<a name="l01942"></a>01942 <span class="keyword">    </span>{
<a name="l01943"></a>01943         <span class="keywordflow">return</span> next_.get();
<a name="l01944"></a>01944     }
<a name="l01945"></a>01945 
<a name="l01946"></a>01946     <span class="keywordtype">void</span> operator()(T <span class="keyword">const</span> &amp; t)
<a name="l01947"></a>01947     {
<a name="l01948"></a>01948         update&lt;1&gt;(t);
<a name="l01949"></a>01949     }
<a name="l01950"></a>01950     
<a name="l01951"></a>01951     <span class="keywordtype">void</span> operator()(T <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l01952"></a>01952     {
<a name="l01953"></a>01953         update&lt;1&gt;(t, weight);
<a name="l01954"></a>01954     }
<a name="l01955"></a>01955 
<a name="l01956"></a>01956     <span class="keywordtype">void</span> updatePass2(T <span class="keyword">const</span> &amp; t)
<a name="l01957"></a>01957     {
<a name="l01958"></a>01958         update&lt;2&gt;(t);
<a name="l01959"></a>01959     }
<a name="l01960"></a>01960     
<a name="l01961"></a>01961     <span class="keywordtype">void</span> updatePass2(T <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l01962"></a>01962     {
<a name="l01963"></a>01963         update&lt;2&gt;(t, weight);
<a name="l01964"></a>01964     }
<a name="l01965"></a>01965 <span class="comment"></span>
<a name="l01966"></a>01966 <span class="comment">    /** Upate all accumulators in the accumulator chain that work in pass N with data t. Requirement: 0 &lt; N &lt; 6 and N &gt;= current_pass_ . If N &lt; current_pass_ call reset() first.  </span>
<a name="l01967"></a>01967 <span class="comment">    */</span>
<a name="l01968"></a>01968     <span class="keywordtype">void</span> updatePassN(T <span class="keyword">const</span> &amp; t, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N)
<a name="l01969"></a>01969     {
<a name="l01970"></a>01970         <span class="keywordflow">switch</span> (N)
<a name="l01971"></a>01971         {
<a name="l01972"></a>01972             <span class="keywordflow">case</span> 1: update&lt;1&gt;(t); <span class="keywordflow">break</span>;
<a name="l01973"></a>01973             <span class="keywordflow">case</span> 2: update&lt;2&gt;(t); <span class="keywordflow">break</span>;
<a name="l01974"></a>01974             <span class="keywordflow">case</span> 3: update&lt;3&gt;(t); <span class="keywordflow">break</span>;
<a name="l01975"></a>01975             <span class="keywordflow">case</span> 4: update&lt;4&gt;(t); <span class="keywordflow">break</span>;
<a name="l01976"></a>01976             <span class="keywordflow">case</span> 5: update&lt;5&gt;(t); <span class="keywordflow">break</span>;
<a name="l01977"></a>01977             <span class="keywordflow">default</span>:
<a name="l01978"></a>01978                 vigra_precondition(<span class="keyword">false</span>,
<a name="l01979"></a>01979                      <span class="stringliteral">&quot;AccumulatorChain::updatePassN(): 0 &lt; N &lt; 6 required.&quot;</span>);
<a name="l01980"></a>01980         }
<a name="l01981"></a>01981     }
<a name="l01982"></a>01982     <span class="comment"></span>
<a name="l01983"></a>01983 <span class="comment">    /** Upate all accumulators in the accumulator chain that work in pass N with data t and weight. Requirement: 0 &lt; N &lt; 6 and N &gt;= current_pass_ . If N &lt; current_pass_ call reset() first. </span>
<a name="l01984"></a>01984 <span class="comment">    */</span>
<a name="l01985"></a>01985     <span class="keywordtype">void</span> updatePassN(T <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N)
<a name="l01986"></a>01986     {
<a name="l01987"></a>01987         <span class="keywordflow">switch</span> (N)
<a name="l01988"></a>01988         {
<a name="l01989"></a>01989             <span class="keywordflow">case</span> 1: update&lt;1&gt;(t, weight); <span class="keywordflow">break</span>;
<a name="l01990"></a>01990             <span class="keywordflow">case</span> 2: update&lt;2&gt;(t, weight); <span class="keywordflow">break</span>;
<a name="l01991"></a>01991             <span class="keywordflow">case</span> 3: update&lt;3&gt;(t, weight); <span class="keywordflow">break</span>;
<a name="l01992"></a>01992             <span class="keywordflow">case</span> 4: update&lt;4&gt;(t, weight); <span class="keywordflow">break</span>;
<a name="l01993"></a>01993             <span class="keywordflow">case</span> 5: update&lt;5&gt;(t, weight); <span class="keywordflow">break</span>;
<a name="l01994"></a>01994             <span class="keywordflow">default</span>:
<a name="l01995"></a>01995                 vigra_precondition(<span class="keyword">false</span>,
<a name="l01996"></a>01996                      <span class="stringliteral">&quot;AccumulatorChain::updatePassN(): 0 &lt; N &lt; 6 required.&quot;</span>);
<a name="l01997"></a>01997         }
<a name="l01998"></a>01998     }
<a name="l01999"></a>01999   <span class="comment"></span>
<a name="l02000"></a>02000 <span class="comment">    /** Return the number of passes required to compute all statistics in the accumulator chain.</span>
<a name="l02001"></a>02001 <span class="comment">    */</span>
<a name="l02002"></a>02002     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> passesRequired()<span class="keyword"> const</span>
<a name="l02003"></a>02003 <span class="keyword">    </span>{
<a name="l02004"></a>02004         <span class="keywordflow">return</span> InternalBaseType::passesRequired();
<a name="l02005"></a>02005     }
<a name="l02006"></a>02006 };
<a name="l02007"></a>02007 
<a name="l02008"></a>02008 
<a name="l02009"></a>02009 
<a name="l02010"></a>02010    <span class="comment">// Create an accumulator chain containing the Selected statistics and their dependencies.</span>
<a name="l02011"></a>02011 <span class="comment"></span>
<a name="l02012"></a>02012 <span class="comment">/** \brief Create an accumulator chain containing the selected statistics and their dependencies.</span>
<a name="l02013"></a>02013 <span class="comment"></span>
<a name="l02014"></a>02014 <span class="comment">    AccumulatorChain is used to compute global statistics which have to be selected at compile time. </span>
<a name="l02015"></a>02015 <span class="comment"></span>
<a name="l02016"></a>02016 <span class="comment">    The template parameters are as follows:</span>
<a name="l02017"></a>02017 <span class="comment">    - T: The input type</span>
<a name="l02018"></a>02018 <span class="comment">        - either element type of the data(e.g. double, int, RGBValue, ...)</span>
<a name="l02019"></a>02019 <span class="comment">        - or type of CoupledHandle (for simultaneous access to coordinates and/or weights)</span>
<a name="l02020"></a>02020 <span class="comment">    - Selected: statistics to be computed and index specifier for the CoupledHandle, wrapped with Select</span>
<a name="l02021"></a>02021 <span class="comment">    </span>
<a name="l02022"></a>02022 <span class="comment">    Usage:</span>
<a name="l02023"></a>02023 <span class="comment">    \code</span>
<a name="l02024"></a>02024 <span class="comment">    typedef double DataType;</span>
<a name="l02025"></a>02025 <span class="comment">    AccumulatorChain&lt;DataType, Select&lt;Variance, Mean, Minimum, ...&gt; &gt; accumulator;</span>
<a name="l02026"></a>02026 <span class="comment">    \endcode</span>
<a name="l02027"></a>02027 <span class="comment"></span>
<a name="l02028"></a>02028 <span class="comment">    Usage, using CoupledHandle:</span>
<a name="l02029"></a>02029 <span class="comment">    \code</span>
<a name="l02030"></a>02030 <span class="comment">    const int dim = 3; //dimension of MultiArray</span>
<a name="l02031"></a>02031 <span class="comment">    typedef double DataType;</span>
<a name="l02032"></a>02032 <span class="comment">    typedef double WeightType;</span>
<a name="l02033"></a>02033 <span class="comment">    typedef vigra::CoupledIteratorType&lt;dim, DataType, WeightType&gt;::HandleType Handle;</span>
<a name="l02034"></a>02034 <span class="comment">    AccumulatorChain&lt;Handle, Select&lt;DataArg&lt;1&gt;, WeightArg&lt;2&gt;, Mean,...&gt; &gt; a;</span>
<a name="l02035"></a>02035 <span class="comment">    \endcode</span>
<a name="l02036"></a>02036 <span class="comment"></span>
<a name="l02037"></a>02037 <span class="comment">    See \ref FeatureAccumulators for more information and examples of use.</span>
<a name="l02038"></a>02038 <span class="comment"> */</span>
<a name="l02039"></a>02039 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Selected, <span class="keywordtype">bool</span> dynamic=false&gt;
<a name="l02040"></a><a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html">02040</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html" title="Create an accumulator chain containing the selected statistics and their dependencies.">AccumulatorChain</a>
<a name="l02041"></a>02041 #ifndef DOXYGEN <span class="comment">// hide AccumulatorChainImpl from documentation</span>
<a name="l02042"></a>02042 : <span class="keyword">public</span> AccumulatorChainImpl&lt;T, typename acc_detail::ConfigureAccumulatorChain&lt;T, Selected, dynamic&gt;::type&gt;
<a name="l02043"></a>02043 <span class="preprocessor">#endif</span>
<a name="l02044"></a>02044 <span class="preprocessor"></span>{
<a name="l02045"></a>02045   <span class="keyword">public</span>:
<a name="l02046"></a>02046   <span class="comment">// \brief TypeList of Tags in the accumulator chain (?).</span>
<a name="l02047"></a>02047     <span class="keyword">typedef</span> <span class="keyword">typename</span> acc_detail::ConfigureAccumulatorChain&lt;T, Selected, dynamic&gt;::TagList AccumulatorTags;
<a name="l02048"></a>02048   <span class="comment"></span>
<a name="l02049"></a>02049 <span class="comment">    /** Before having seen data (current_pass_==0), the shape of the data can be changed... (?)</span>
<a name="l02050"></a>02050 <span class="comment">    */</span>
<a name="l02051"></a>02051     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keywordtype">int</span> N&gt;
<a name="l02052"></a><a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html#a767b7484ef8805415dca8a7108d7d0b5">02052</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html#a767b7484ef8805415dca8a7108d7d0b5">reshape</a>(<a class="code" href="classvigra_1_1TinyVector.html" title="Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE...">TinyVector&lt;U, N&gt;</a> <span class="keyword">const</span> &amp; s)
<a name="l02053"></a>02053     {
<a name="l02054"></a>02054         vigra_precondition(this-&gt;current_pass_ == 0,
<a name="l02055"></a>02055              <span class="stringliteral">&quot;AccumulatorChain::reshape(): cannot reshape after seeing data. Call AccumulatorChain::reset() first.&quot;</span>);
<a name="l02056"></a>02056         this-&gt;next_.resize(s);
<a name="l02057"></a>02057         this-&gt;current_pass_ = 1;
<a name="l02058"></a>02058     }
<a name="l02059"></a>02059      <span class="comment"></span>
<a name="l02060"></a>02060 <span class="comment">    /** Return the names of all tags in the accumulator chain (selected statistics and their dependencies).</span>
<a name="l02061"></a>02061 <span class="comment">    */</span>
<a name="l02062"></a><a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html#a40bc528dbf2f0d32cc6a743a33a78a44">02062</a>     <span class="keyword">static</span> <a class="code" href="classvigra_1_1ArrayVector.html">ArrayVector&lt;std::string&gt;</a> <span class="keyword">const</span> &amp; <a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html#a40bc528dbf2f0d32cc6a743a33a78a44">tagNames</a>()
<a name="l02063"></a>02063     {
<a name="l02064"></a>02064         <span class="keyword">static</span> <a class="code" href="classvigra_1_1ArrayVector.html">ArrayVector&lt;std::string&gt;</a> * n = VIGRA_SAFE_STATIC(n, <span class="keyword">new</span> <a class="code" href="classvigra_1_1ArrayVector.html">ArrayVector&lt;std::string&gt;</a>(collectTagNames()));
<a name="l02065"></a>02065         <span class="keywordflow">return</span> *n;
<a name="l02066"></a>02066     }
<a name="l02067"></a>02067 
<a name="l02068"></a>02068 
<a name="l02069"></a>02069 <span class="preprocessor">#ifdef DOXYGEN // hide AccumulatorChainImpl from documentation</span>
<a name="l02070"></a>02070 <span class="preprocessor"></span>  <span class="comment"></span>
<a name="l02071"></a>02071 <span class="comment">  /** Set options for all histograms in the accumulator chain. See histogram accumulators for possible options. The function is ignored if there is no histogram in the accumulator chain.</span>
<a name="l02072"></a>02072 <span class="comment">   */</span>
<a name="l02073"></a>02073   <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html#a75d998533052d60bef9bb39f10d8a623">setHistogramOptions</a>(<a class="code" href="classvigra_1_1HistogramOptions.html" title="Set histogram options.">HistogramOptions</a> <span class="keyword">const</span> &amp; options);
<a name="l02074"></a>02074     <span class="comment"></span>
<a name="l02075"></a>02075 <span class="comment">  /** Set an offset for &lt;tt&gt;Coord&lt;...&gt;&lt;/tt&gt; statistics.</span>
<a name="l02076"></a>02076 <span class="comment">  </span>
<a name="l02077"></a>02077 <span class="comment">      If the offset is non-zero, coordinate statistics such as &lt;tt&gt;RegionCenter&lt;/tt&gt; are computed</span>
<a name="l02078"></a>02078 <span class="comment">      in the global coordinate system defined by the \a offset. Without an offset, these statistics</span>
<a name="l02079"></a>02079 <span class="comment">      are computed in the local coordinate system of the current region of interest.</span>
<a name="l02080"></a>02080 <span class="comment">  */</span>    
<a name="l02081"></a>02081   <span class="keyword">template</span> &lt;<span class="keyword">class</span> SHAPE&gt;
<a name="l02082"></a>02082   <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html#a2e382163721ad28be3656d3e816b0543">setCoordinateOffset</a>(SHAPE <span class="keyword">const</span> &amp; offset);
<a name="l02083"></a>02083     <span class="comment"></span>
<a name="l02084"></a>02084 <span class="comment">  /** Reset current_pass_ of the accumulator chain to &#39;reset_to_pass&#39;. */</span>
<a name="l02085"></a>02085   <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html#acdba289c69fa6da0533ef7a93c417705">reset</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> reset_to_pass = 0);
<a name="l02086"></a>02086 <span class="comment"></span>
<a name="l02087"></a>02087 <span class="comment">  /** Equivalent to merge(o) . */</span>
<a name="l02088"></a>02088   <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html#aaabbc1a840d357b8308de9ef4fa133c1">operator+=</a>(AccumulatorChainImpl <span class="keyword">const</span> &amp; o);
<a name="l02089"></a>02089   <span class="comment"></span>
<a name="l02090"></a>02090 <span class="comment">  /** Merge the accumulator chain with accumulator chain &#39;o&#39;. This only works if all selected statistics in the accumulator chain support the &#39;+=&#39; operator. See the documentations of the particular statistics for support information.</span>
<a name="l02091"></a>02091 <span class="comment">   */</span>
<a name="l02092"></a>02092   <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html#a99b6ae4cf0fdc2d4a33f3a05f77b058e">merge</a>(AccumulatorChainImpl <span class="keyword">const</span> &amp; o);
<a name="l02093"></a>02093   <span class="comment"></span>
<a name="l02094"></a>02094 <span class="comment">  /** Upate all accumulators in the accumulator chain that work in pass N with data t. Requirement: 0 &lt; N &lt; 6 and N &gt;= current_pass_ . If N &lt; current_pass_ call reset first.  </span>
<a name="l02095"></a>02095 <span class="comment">   */</span>
<a name="l02096"></a>02096   <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html#a26d54a15d24e445b88b83f882972e46d">updatePassN</a>(T <span class="keyword">const</span> &amp; t, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N);
<a name="l02097"></a>02097   <span class="comment"></span>
<a name="l02098"></a>02098 <span class="comment">  /** Upate all accumulators in the accumulator chain that work in pass N with data t and weight. Requirement: 0 &lt; N &lt; 6 and N &gt;= current_pass_ . If N &lt; current_pass_ call reset first. </span>
<a name="l02099"></a>02099 <span class="comment">   */</span>
<a name="l02100"></a>02100   <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html#a26d54a15d24e445b88b83f882972e46d">updatePassN</a>(T <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N);
<a name="l02101"></a>02101   <span class="comment"></span>
<a name="l02102"></a>02102 <span class="comment">  /** Return the number of passes required to compute all statistics in the accumulator chain.</span>
<a name="l02103"></a>02103 <span class="comment">   */</span>
<a name="l02104"></a>02104   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html#a59d54352fe534a555cee5dea27c7d304">passesRequired</a>() <span class="keyword">const</span>;
<a name="l02105"></a>02105   
<a name="l02106"></a>02106 <span class="preprocessor">#endif   </span>
<a name="l02107"></a>02107 <span class="preprocessor"></span> 
<a name="l02108"></a>02108   <span class="keyword">private</span>:
<a name="l02109"></a>02109     <span class="keyword">static</span> <a class="code" href="classvigra_1_1ArrayVector.html">ArrayVector&lt;std::string&gt;</a> collectTagNames()
<a name="l02110"></a>02110     {
<a name="l02111"></a>02111         <a class="code" href="classvigra_1_1ArrayVector.html">ArrayVector&lt;std::string&gt;</a> n;
<a name="l02112"></a>02112         acc_detail::CollectAccumulatorNames&lt;AccumulatorTags&gt;::exec(n);
<a name="l02113"></a>02113         std::sort(n.<a class="code" href="classvigra_1_1ArrayVectorView.html#aa4b02d4f1a8500fb07a551069060709f">begin</a>(), n.<a class="code" href="classvigra_1_1ArrayVectorView.html#a350132543d80a1c1e5be844e6d2878ea">end</a>());
<a name="l02114"></a>02114         <span class="keywordflow">return</span> n;
<a name="l02115"></a>02115     }
<a name="l02116"></a>02116 }; 
<a name="l02117"></a>02117 
<a name="l02118"></a>02118 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keyword">class</span> T3, <span class="keyword">class</span> T4, <span class="keyword">class</span> T5, <span class="keyword">class</span> Selected, <span class="keywordtype">bool</span> dynamic&gt;
<a name="l02119"></a>02119 <span class="keyword">class </span>AccumulatorChain&lt;CoupledArrays&lt;N, T1, T2, T3, T4, T5&gt;, Selected, dynamic&gt;
<a name="l02120"></a>02120 : <span class="keyword">public</span> AccumulatorChain&lt;typename CoupledArrays&lt;N, T1, T2, T3, T4, T5&gt;::HandleType, Selected, dynamic&gt;
<a name="l02121"></a>02121 {};
<a name="l02122"></a>02122 
<a name="l02123"></a>02123 
<a name="l02124"></a>02124     <span class="comment">// Create a dynamic accumulator chain containing the Selected statistics and their dependencies.</span>
<a name="l02125"></a>02125     <span class="comment">// Statistics will only be computed if activate&lt;Tag&gt;() is called at runtime.</span><span class="comment"></span>
<a name="l02126"></a>02126 <span class="comment">/** \brief Create a dynamic accumulator chain containing the selected statistics and their dependencies.</span>
<a name="l02127"></a>02127 <span class="comment"></span>
<a name="l02128"></a>02128 <span class="comment">    DynamicAccumulatorChain is used to compute global statistics with run-time activation. A set of statistics is selected at run-time and from this set statistics can be activated at run-time by calling activate&lt;stat&gt;() or activate(std::string stat).</span>
<a name="l02129"></a>02129 <span class="comment"></span>
<a name="l02130"></a>02130 <span class="comment">    The template parameters are as follows:</span>
<a name="l02131"></a>02131 <span class="comment">    - T: The input type</span>
<a name="l02132"></a>02132 <span class="comment">        - either element type of the data(e.g. double, int, RGBValue, ...)</span>
<a name="l02133"></a>02133 <span class="comment">        - or type of CoupledHandle (for access to coordinates and/or weights)</span>
<a name="l02134"></a>02134 <span class="comment">    - Selected: statistics to be computed and index specifier for the CoupledHandle, wrapped with Select</span>
<a name="l02135"></a>02135 <span class="comment">    </span>
<a name="l02136"></a>02136 <span class="comment">    Usage:</span>
<a name="l02137"></a>02137 <span class="comment">    \code</span>
<a name="l02138"></a>02138 <span class="comment">    typedef double DataType;</span>
<a name="l02139"></a>02139 <span class="comment">    DynamicAccumulatorChain&lt;DataType, Select&lt;Variance, Mean, Minimum, ...&gt; &gt; accumulator;</span>
<a name="l02140"></a>02140 <span class="comment">    \endcode</span>
<a name="l02141"></a>02141 <span class="comment"></span>
<a name="l02142"></a>02142 <span class="comment">    Usage, using CoupledHandle:</span>
<a name="l02143"></a>02143 <span class="comment">    \code</span>
<a name="l02144"></a>02144 <span class="comment">    const int dim = 3; //dimension of MultiArray</span>
<a name="l02145"></a>02145 <span class="comment">    typedef double DataType;</span>
<a name="l02146"></a>02146 <span class="comment">    typedef double WeightType;</span>
<a name="l02147"></a>02147 <span class="comment">    typedef vigra::CoupledIteratorType&lt;dim, DataType, WeightType&gt;::HandleType Handle;</span>
<a name="l02148"></a>02148 <span class="comment">    DynamicAccumulatorChain&lt;Handle, Select&lt;DataArg&lt;1&gt;, WeightArg&lt;2&gt;, Mean,...&gt; &gt; a;</span>
<a name="l02149"></a>02149 <span class="comment">    \endcode</span>
<a name="l02150"></a>02150 <span class="comment"></span>
<a name="l02151"></a>02151 <span class="comment">    See \ref FeatureAccumulators for more information and examples of use.</span>
<a name="l02152"></a>02152 <span class="comment"> */</span>
<a name="l02153"></a>02153 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Selected&gt;
<a name="l02154"></a><a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChain.html">02154</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChain.html" title="Create a dynamic accumulator chain containing the selected statistics and their dependencies.">DynamicAccumulatorChain</a>
<a name="l02155"></a>02155 : <span class="keyword">public</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html" title="Create an accumulator chain containing the selected statistics and their dependencies.">AccumulatorChain</a>&lt;T, Selected, true&gt;
<a name="l02156"></a>02156 {
<a name="l02157"></a>02157   <span class="keyword">public</span>:
<a name="l02158"></a>02158     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html" title="Create an accumulator chain containing the selected statistics and their dependencies.">AccumulatorChain&lt;T, Selected, true&gt;::InternalBaseType</a> InternalBaseType;
<a name="l02159"></a>02159     <span class="keyword">typedef</span> <span class="keyword">typename</span> DynamicAccumulatorChain::AccumulatorTags AccumulatorTags;
<a name="l02160"></a>02160        <span class="comment"></span>
<a name="l02161"></a>02161 <span class="comment">    /** Activate statistic &#39;tag&#39;. Alias names are not recognized. If the statistic is not in the accumulator chain a PreconditionViolation is thrown.</span>
<a name="l02162"></a>02162 <span class="comment">    */</span>
<a name="l02163"></a><a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChain.html#a5bd1d05096902d88b887048257526404">02163</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChain.html#a7cd630295d4a20bcb714422ba64a16df">activate</a>(std::string tag)
<a name="l02164"></a>02164     {
<a name="l02165"></a>02165         vigra_precondition(activateImpl(tag),
<a name="l02166"></a>02166             std::string(<span class="stringliteral">&quot;DynamicAccumulatorChain::activate(): Tag &#39;&quot;</span>) + tag + <span class="stringliteral">&quot;&#39; not found.&quot;</span>);
<a name="l02167"></a>02167     }
<a name="l02168"></a>02168     <span class="comment"></span>
<a name="l02169"></a>02169 <span class="comment">    /** %activate&lt;TAG&gt;() activates statistic &#39;TAG&#39;. If the statistic is not in the accumulator chain it is ignored. (?)</span>
<a name="l02170"></a>02170 <span class="comment">    */</span>
<a name="l02171"></a>02171     <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG&gt;
<a name="l02172"></a><a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChain.html#a7cd630295d4a20bcb714422ba64a16df">02172</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChain.html#a7cd630295d4a20bcb714422ba64a16df">activate</a>()
<a name="l02173"></a>02173     {
<a name="l02174"></a>02174         LookupTag&lt;TAG, DynamicAccumulatorChain&gt;::type::activateImpl(getAccumulator&lt;AccumulatorEnd&gt;(*this).active_accumulators_);
<a name="l02175"></a>02175     }
<a name="l02176"></a>02176     <span class="comment"></span>
<a name="l02177"></a>02177 <span class="comment">    /** Activate all statistics in the accumulator chain.</span>
<a name="l02178"></a>02178 <span class="comment">    */</span>
<a name="l02179"></a><a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChain.html#a9022e4f28cb69187a5dcc53bb5df6dc8">02179</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChain.html#a9022e4f28cb69187a5dcc53bb5df6dc8">activateAll</a>()
<a name="l02180"></a>02180     {
<a name="l02181"></a>02181         getAccumulator&lt;AccumulatorEnd&gt;(*this).active_accumulators_.set();
<a name="l02182"></a>02182     }<span class="comment"></span>
<a name="l02183"></a>02183 <span class="comment">    /** Return true if the statistic &#39;tag&#39; is active, i.e. activate(std::string tag) or activate&lt;TAG&gt;() has been called. If the statistic is not in the accumulator chain a PreconditionViolation is thrown. (Note that alias names are not recognized.)</span>
<a name="l02184"></a>02184 <span class="comment">    */</span>
<a name="l02185"></a><a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChain.html#ab011d6be64cc5bbbcca176f42c0a6829">02185</a>     <span class="keywordtype">bool</span> <a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChain.html#a16fd1b677a8d61959f5531d8d1a5836b">isActive</a>(std::string tag)<span class="keyword"> const</span>
<a name="l02186"></a>02186 <span class="keyword">    </span>{
<a name="l02187"></a>02187         acc_detail::TagIsActive_Visitor v;
<a name="l02188"></a>02188         vigra_precondition(isActiveImpl(tag, v),
<a name="l02189"></a>02189             std::string(<span class="stringliteral">&quot;DynamicAccumulatorChain::isActive(): Tag &#39;&quot;</span>) + tag + <span class="stringliteral">&quot;&#39; not found.&quot;</span>);
<a name="l02190"></a>02190         <span class="keywordflow">return</span> v.result;
<a name="l02191"></a>02191     }
<a name="l02192"></a>02192     <span class="comment"></span>
<a name="l02193"></a>02193 <span class="comment">    /** %isActive&lt;TAG&gt;() returns true if statistic &#39;TAG&#39; is active, i.e. activate(std::string tag) or activate&lt;TAG&gt;() has been called. If the statistic is not in the accumulator chain, true is returned. (?)</span>
<a name="l02194"></a>02194 <span class="comment">    */</span>
<a name="l02195"></a>02195     <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG&gt;
<a name="l02196"></a><a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChain.html#a16fd1b677a8d61959f5531d8d1a5836b">02196</a>     <span class="keywordtype">bool</span> <a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChain.html#a16fd1b677a8d61959f5531d8d1a5836b">isActive</a>()<span class="keyword"> const</span>
<a name="l02197"></a>02197 <span class="keyword">    </span>{
<a name="l02198"></a>02198         <span class="keywordflow">return</span> LookupTag&lt;TAG, DynamicAccumulatorChain&gt;::type::isActiveImpl(getAccumulator&lt;AccumulatorEnd&gt;(*this).active_accumulators_);
<a name="l02199"></a>02199     }
<a name="l02200"></a>02200 <span class="comment"></span>
<a name="l02201"></a>02201 <span class="comment">    /** Return names of all statistics in the accumulator chain that are active.</span>
<a name="l02202"></a>02202 <span class="comment">    */</span>
<a name="l02203"></a><a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChain.html#aee4db7ed5a21be62f6c8154e57bc139b">02203</a>     <a class="code" href="classvigra_1_1ArrayVector.html">ArrayVector&lt;std::string&gt;</a> <a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChain.html#aee4db7ed5a21be62f6c8154e57bc139b">activeNames</a>()<span class="keyword"> const</span>
<a name="l02204"></a>02204 <span class="keyword">    </span>{
<a name="l02205"></a>02205         <a class="code" href="classvigra_1_1ArrayVector.html">ArrayVector&lt;std::string&gt;</a> res;
<a name="l02206"></a>02206         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> k=0; k&lt;<a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html#a40bc528dbf2f0d32cc6a743a33a78a44">DynamicAccumulatorChain::tagNames</a>().size(); ++k)
<a name="l02207"></a>02207             <span class="keywordflow">if</span>(<a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChain.html#a16fd1b677a8d61959f5531d8d1a5836b">isActive</a>(<a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html#a40bc528dbf2f0d32cc6a743a33a78a44">DynamicAccumulatorChain::tagNames</a>()[k]))
<a name="l02208"></a>02208                 res.push_back(<a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html#a40bc528dbf2f0d32cc6a743a33a78a44">DynamicAccumulatorChain::tagNames</a>()[k]);
<a name="l02209"></a>02209         <span class="keywordflow">return</span> res;
<a name="l02210"></a>02210     }
<a name="l02211"></a>02211     <span class="comment"></span>
<a name="l02212"></a>02212 <span class="comment">    /** Return number of passes required to compute the active statistics in the accumulator chain.</span>
<a name="l02213"></a>02213 <span class="comment">    */</span>
<a name="l02214"></a><a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChain.html#a59d54352fe534a555cee5dea27c7d304">02214</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChain.html#a59d54352fe534a555cee5dea27c7d304">passesRequired</a>()<span class="keyword"> const</span>
<a name="l02215"></a>02215 <span class="keyword">    </span>{
<a name="l02216"></a>02216         <span class="keywordflow">return</span> <a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChain.html#a59d54352fe534a555cee5dea27c7d304">InternalBaseType::passesRequired</a>(getAccumulator&lt;AccumulatorEnd&gt;(*this).active_accumulators_);
<a name="l02217"></a>02217     }
<a name="l02218"></a>02218     
<a name="l02219"></a>02219   <span class="keyword">protected</span>:
<a name="l02220"></a>02220   
<a name="l02221"></a>02221     <span class="keywordtype">bool</span> activateImpl(std::string tag)
<a name="l02222"></a>02222     {
<a name="l02223"></a>02223         <span class="keywordflow">return</span> acc_detail::ApplyVisitorToTag&lt;AccumulatorTags&gt;::exec(*<span class="keyword">this</span>, 
<a name="l02224"></a>02224                                          <a class="code" href="namespacevigra.html#a9e4131b7743b5801ce7122df2c63a9ba">normalizeString</a>(tag), acc_detail::ActivateTag_Visitor());
<a name="l02225"></a>02225     }
<a name="l02226"></a>02226     
<a name="l02227"></a>02227     <span class="keywordtype">bool</span> isActiveImpl(std::string tag, acc_detail::TagIsActive_Visitor &amp; v)<span class="keyword"> const</span>
<a name="l02228"></a>02228 <span class="keyword">    </span>{
<a name="l02229"></a>02229         <span class="keywordflow">return</span> acc_detail::ApplyVisitorToTag&lt;AccumulatorTags&gt;::exec(*<span class="keyword">this</span>, <a class="code" href="namespacevigra.html#a9e4131b7743b5801ce7122df2c63a9ba">normalizeString</a>(tag), v);
<a name="l02230"></a>02230     }
<a name="l02231"></a>02231 };
<a name="l02232"></a>02232 
<a name="l02233"></a>02233 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keyword">class</span> T3, <span class="keyword">class</span> T4, <span class="keyword">class</span> T5, <span class="keyword">class</span> Selected&gt;
<a name="l02234"></a>02234 <span class="keyword">class </span>DynamicAccumulatorChain&lt;CoupledArrays&lt;N, T1, T2, T3, T4, T5&gt;, Selected&gt;
<a name="l02235"></a>02235 : <span class="keyword">public</span> DynamicAccumulatorChain&lt;typename CoupledArrays&lt;N, T1, T2, T3, T4, T5&gt;::HandleType, Selected&gt;
<a name="l02236"></a>02236 {};
<a name="l02237"></a>02237 
<a name="l02238"></a>02238 
<a name="l02239"></a>02239 <span class="comment"></span>
<a name="l02240"></a>02240 <span class="comment">/** \brief Create an array of accumulator chains containing the selected per-region and global statistics and their dependencies.</span>
<a name="l02241"></a>02241 <span class="comment"></span>
<a name="l02242"></a>02242 <span class="comment">    AccumulatorChainArray is used to compute per-region statistics (as well as global statistics). The statistics are selected at compile-time. An array of accumulator chains (one per region) for region statistics is created and one accumulator chain for global statistics. The region labels always start at 0. Use the Global modifier to compute global statistics (by default per-region statistics are computed). </span>
<a name="l02243"></a>02243 <span class="comment"></span>
<a name="l02244"></a>02244 <span class="comment">    The template parameters are as follows:</span>
<a name="l02245"></a>02245 <span class="comment">    - T: The input type, type of CoupledHandle (for access to coordinates, labels and weights)</span>
<a name="l02246"></a>02246 <span class="comment">    - Selected: statistics to be computed and index specifier for the CoupledHandle, wrapped with Select</span>
<a name="l02247"></a>02247 <span class="comment"></span>
<a name="l02248"></a>02248 <span class="comment">    Usage:</span>
<a name="l02249"></a>02249 <span class="comment">    \code</span>
<a name="l02250"></a>02250 <span class="comment">    const int dim = 3; //dimension of MultiArray</span>
<a name="l02251"></a>02251 <span class="comment">    typedef double DataType;</span>
<a name="l02252"></a>02252 <span class="comment">    typedef double WeightType;</span>
<a name="l02253"></a>02253 <span class="comment">    typedef unsigned int LabelType;</span>
<a name="l02254"></a>02254 <span class="comment">    typedef vigra::CoupledIteratorType&lt;dim, DataType, WeightType, LabelType&gt;::HandleType Handle;</span>
<a name="l02255"></a>02255 <span class="comment">    AccumulatorChainArray&lt;Handle, Select&lt;DataArg&lt;1&gt;, WeightArg&lt;2&gt;, LabelArg&lt;3&gt;, Mean, Variance, ...&gt; &gt; a;</span>
<a name="l02256"></a>02256 <span class="comment">    \endcode</span>
<a name="l02257"></a>02257 <span class="comment"></span>
<a name="l02258"></a>02258 <span class="comment">    See \ref FeatureAccumulators for more information and examples of use.</span>
<a name="l02259"></a>02259 <span class="comment">*/</span>
<a name="l02260"></a>02260 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Selected, <span class="keywordtype">bool</span> dynamic=false&gt;
<a name="l02261"></a><a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html">02261</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html" title="Create an array of accumulator chains containing the selected per-region and global statistics and th...">AccumulatorChainArray</a>
<a name="l02262"></a>02262 #ifndef DOXYGEN <span class="comment">//hide AccumulatorChainImpl vom documentation</span>
<a name="l02263"></a>02263 : <span class="keyword">public</span> AccumulatorChainImpl&lt;T, typename acc_detail::ConfigureAccumulatorChainArray&lt;T, Selected, dynamic&gt;::type&gt;
<a name="l02264"></a>02264 <span class="preprocessor">#endif</span>
<a name="l02265"></a>02265 <span class="preprocessor"></span>{
<a name="l02266"></a>02266   <span class="keyword">public</span>:
<a name="l02267"></a>02267     <span class="keyword">typedef</span> <span class="keyword">typename</span> acc_detail::ConfigureAccumulatorChainArray&lt;T, Selected, dynamic&gt; Creator;
<a name="l02268"></a>02268     <span class="keyword">typedef</span> <span class="keyword">typename</span> Creator::TagList AccumulatorTags;
<a name="l02269"></a>02269     <span class="keyword">typedef</span> <span class="keyword">typename</span> Creator::GlobalTags GlobalTags;
<a name="l02270"></a>02270     <span class="keyword">typedef</span> <span class="keyword">typename</span> Creator::RegionTags RegionTags;
<a name="l02271"></a>02271     <span class="comment"></span>
<a name="l02272"></a>02272 <span class="comment">    /** Statistics will not be computed for label l. Note that only one label can be ignored.</span>
<a name="l02273"></a>02273 <span class="comment">    */</span>
<a name="l02274"></a><a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#a58ade89315a1a3fef27d86c8f6de3122">02274</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#a58ade89315a1a3fef27d86c8f6de3122">ignoreLabel</a>(<a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a> l)
<a name="l02275"></a>02275     {
<a name="l02276"></a>02276         this-&gt;next_.ignoreLabel(l);
<a name="l02277"></a>02277     }
<a name="l02278"></a>02278     <span class="comment"></span>
<a name="l02279"></a>02279 <span class="comment">    /** Set the maximum region label (e.g. for merging two accumulator chains).</span>
<a name="l02280"></a>02280 <span class="comment">    */</span>
<a name="l02281"></a><a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#ab29799c505288b0b5c3325587c85546b">02281</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#ab29799c505288b0b5c3325587c85546b">setMaxRegionLabel</a>(<span class="keywordtype">unsigned</span> label)
<a name="l02282"></a>02282     {
<a name="l02283"></a>02283         this-&gt;next_.setMaxRegionLabel(label);
<a name="l02284"></a>02284     }
<a name="l02285"></a>02285     <span class="comment"></span>
<a name="l02286"></a>02286 <span class="comment">    /** %Maximum region label. (equal to regionCount() - 1)</span>
<a name="l02287"></a>02287 <span class="comment">    */</span>
<a name="l02288"></a><a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#aa9ecd1822a0ea605d89ef5763d03e820">02288</a>     <a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#aa9ecd1822a0ea605d89ef5763d03e820">maxRegionLabel</a>()<span class="keyword"> const</span>
<a name="l02289"></a>02289 <span class="keyword">    </span>{
<a name="l02290"></a>02290         <span class="keywordflow">return</span> this-&gt;next_.maxRegionLabel();
<a name="l02291"></a>02291     }
<a name="l02292"></a>02292     <span class="comment"></span>
<a name="l02293"></a>02293 <span class="comment">    /** Number of Regions. (equal to maxRegionLabel() + 1)</span>
<a name="l02294"></a>02294 <span class="comment">    */</span>
<a name="l02295"></a><a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#a6aade1064e12f48eb5f636a2fbe8e034">02295</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#a6aade1064e12f48eb5f636a2fbe8e034">regionCount</a>()<span class="keyword"> const</span>
<a name="l02296"></a>02296 <span class="keyword">    </span>{
<a name="l02297"></a>02297         <span class="keywordflow">return</span> this-&gt;next_.regions_.size();
<a name="l02298"></a>02298     }
<a name="l02299"></a>02299     <span class="comment"></span>
<a name="l02300"></a>02300 <span class="comment">    /** Equivalent to &lt;tt&gt;merge(o)&lt;/tt&gt;.</span>
<a name="l02301"></a>02301 <span class="comment">    */</span>
<a name="l02302"></a><a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#aefb94bc62209303354795bb5ee851e97">02302</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#aefb94bc62209303354795bb5ee851e97">operator+=</a>(<a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html" title="Create an array of accumulator chains containing the selected per-region and global statistics and th...">AccumulatorChainArray</a> <span class="keyword">const</span> &amp; o)
<a name="l02303"></a>02303     {
<a name="l02304"></a>02304         <a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#aa46fb4d0cbfec2d421bcc6747fc932ab">merge</a>(o);
<a name="l02305"></a>02305     }
<a name="l02306"></a>02306     <span class="comment"></span>
<a name="l02307"></a>02307 <span class="comment">    /** Merge region i with region j. </span>
<a name="l02308"></a>02308 <span class="comment">    */</span>
<a name="l02309"></a><a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#aa46fb4d0cbfec2d421bcc6747fc932ab">02309</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#aa46fb4d0cbfec2d421bcc6747fc932ab">merge</a>(<span class="keywordtype">unsigned</span> i, <span class="keywordtype">unsigned</span> j)
<a name="l02310"></a>02310     {
<a name="l02311"></a>02311         vigra_precondition(i &lt;= <a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#aa9ecd1822a0ea605d89ef5763d03e820">maxRegionLabel</a>() &amp;&amp; j &lt;= <a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#aa9ecd1822a0ea605d89ef5763d03e820">maxRegionLabel</a>(),
<a name="l02312"></a>02312             <span class="stringliteral">&quot;AccumulatorChainArray::merge(): region labels out of range.&quot;</span>);
<a name="l02313"></a>02313         this-&gt;next_.mergeImpl(i, j);
<a name="l02314"></a>02314     }
<a name="l02315"></a>02315     <span class="comment"></span>
<a name="l02316"></a>02316 <span class="comment">    /** Merge with accumulator chain o. maxRegionLabel() of the two accumulators must be equal.</span>
<a name="l02317"></a>02317 <span class="comment">    */</span>
<a name="l02318"></a><a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#a315219a9eb9310d17673d937ecc2e80a">02318</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#aa46fb4d0cbfec2d421bcc6747fc932ab">merge</a>(<a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html" title="Create an array of accumulator chains containing the selected per-region and global statistics and th...">AccumulatorChainArray</a> <span class="keyword">const</span> &amp; o)
<a name="l02319"></a>02319     {
<a name="l02320"></a>02320         <span class="keywordflow">if</span>(<a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#aa9ecd1822a0ea605d89ef5763d03e820">maxRegionLabel</a>() == -1)
<a name="l02321"></a>02321             <a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#ab29799c505288b0b5c3325587c85546b">setMaxRegionLabel</a>(o.<a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#aa9ecd1822a0ea605d89ef5763d03e820">maxRegionLabel</a>());
<a name="l02322"></a>02322         vigra_precondition(<a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#aa9ecd1822a0ea605d89ef5763d03e820">maxRegionLabel</a>() == o.<a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#aa9ecd1822a0ea605d89ef5763d03e820">maxRegionLabel</a>(),
<a name="l02323"></a>02323             <span class="stringliteral">&quot;AccumulatorChainArray::merge(): maxRegionLabel must be equal.&quot;</span>);
<a name="l02324"></a>02324         this-&gt;next_.mergeImpl(o.next_);
<a name="l02325"></a>02325     }
<a name="l02326"></a>02326 <span class="comment"></span>
<a name="l02327"></a>02327 <span class="comment">    /** Merge with accumulator chain o using a mapping between labels of the two accumulators. Label l of accumulator chain o is mapped to labelMapping[l]. Hence, all elements of labelMapping must be &lt;= maxRegionLabel() and size of labelMapping must match o.regionCount().</span>
<a name="l02328"></a>02328 <span class="comment">    */</span>
<a name="l02329"></a>02329     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ArrayLike&gt;
<a name="l02330"></a><a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#a5547b3c205831e8a474d2fc68a61b51a">02330</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#aa46fb4d0cbfec2d421bcc6747fc932ab">merge</a>(<a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html" title="Create an array of accumulator chains containing the selected per-region and global statistics and th...">AccumulatorChainArray</a> <span class="keyword">const</span> &amp; o, ArrayLike <span class="keyword">const</span> &amp; labelMapping)
<a name="l02331"></a>02331     {
<a name="l02332"></a>02332         vigra_precondition(labelMapping.size() == o.<a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#a6aade1064e12f48eb5f636a2fbe8e034">regionCount</a>(),
<a name="l02333"></a>02333             <span class="stringliteral">&quot;AccumulatorChainArray::merge(): labelMapping.size() must match regionCount() of RHS.&quot;</span>);
<a name="l02334"></a>02334         this-&gt;next_.mergeImpl(o.next_, labelMapping);
<a name="l02335"></a>02335     }
<a name="l02336"></a>02336 <span class="comment"></span>
<a name="l02337"></a>02337 <span class="comment">    /** Return names of all tags in the accumulator chain (selected statistics and their dependencies).</span>
<a name="l02338"></a>02338 <span class="comment">    */</span>
<a name="l02339"></a><a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#a40bc528dbf2f0d32cc6a743a33a78a44">02339</a>     <span class="keyword">static</span> <a class="code" href="classvigra_1_1ArrayVector.html">ArrayVector&lt;std::string&gt;</a> <span class="keyword">const</span> &amp; <a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#a40bc528dbf2f0d32cc6a743a33a78a44">tagNames</a>()
<a name="l02340"></a>02340     {
<a name="l02341"></a>02341         <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classvigra_1_1ArrayVector.html">ArrayVector&lt;std::string&gt;</a> n = collectTagNames();
<a name="l02342"></a>02342         <span class="keywordflow">return</span> n;
<a name="l02343"></a>02343     }
<a name="l02344"></a>02344 
<a name="l02345"></a>02345 
<a name="l02346"></a>02346 <span class="preprocessor">#ifdef DOXYGEN // hide AccumulatorChainImpl from documentation</span>
<a name="l02347"></a>02347 <span class="preprocessor"></span><span class="comment"></span>
<a name="l02348"></a>02348 <span class="comment">  /** \copydoc vigra::acc::AccumulatorChain::setHistogramOptions(HistogramOptions const &amp;) */</span>
<a name="l02349"></a>02349   <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#a75d998533052d60bef9bb39f10d8a623">setHistogramOptions</a>(<a class="code" href="classvigra_1_1HistogramOptions.html" title="Set histogram options.">HistogramOptions</a> <span class="keyword">const</span> &amp; options);
<a name="l02350"></a>02350 <span class="comment"></span>
<a name="l02351"></a>02351 <span class="comment">  /** Set regional and global options for all histograms in the accumulator chain.</span>
<a name="l02352"></a>02352 <span class="comment">   */</span>
<a name="l02353"></a>02353   <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#a75d998533052d60bef9bb39f10d8a623">setHistogramOptions</a>(<a class="code" href="classvigra_1_1HistogramOptions.html" title="Set histogram options.">HistogramOptions</a> <span class="keyword">const</span> &amp; regionoptions, <a class="code" href="classvigra_1_1HistogramOptions.html" title="Set histogram options.">HistogramOptions</a> <span class="keyword">const</span> &amp; globaloptions);
<a name="l02354"></a>02354     <span class="comment"></span>
<a name="l02355"></a>02355 <span class="comment">  /** \copydoc vigra::acc::AccumulatorChain::setCoordinateOffset(SHAPE const &amp;)</span>
<a name="l02356"></a>02356 <span class="comment">  */</span>    
<a name="l02357"></a>02357   <span class="keyword">template</span> &lt;<span class="keyword">class</span> SHAPE&gt;
<a name="l02358"></a>02358   <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#ad3f783cada527c1e8c44f9639ea75361">setCoordinateOffset</a>(SHAPE <span class="keyword">const</span> &amp; offset)
<a name="l02359"></a>02359   
<a name="l02360"></a>02360   <span class="comment">/** \copydoc vigra::acc::AccumulatorChain::reset() */</span>
<a name="l02361"></a>02361   <span class="keywordtype">void</span> reset(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> reset_to_pass = 0);
<a name="l02362"></a>02362 <span class="comment"></span>
<a name="l02363"></a>02363 <span class="comment">  /** \copydoc vigra::acc::AccumulatorChain::operator+=() */</span>
<a name="l02364"></a>02364   <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#aefb94bc62209303354795bb5ee851e97">operator+=</a>(AccumulatorChainImpl <span class="keyword">const</span> &amp; o);
<a name="l02365"></a>02365     <span class="comment"></span>
<a name="l02366"></a>02366 <span class="comment">  /** \copydoc vigra::acc::AccumulatorChain::updatePassN(T const &amp;,unsigned int) */</span>
<a name="l02367"></a>02367   <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#a26d54a15d24e445b88b83f882972e46d">updatePassN</a>(T <span class="keyword">const</span> &amp; t, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N);
<a name="l02368"></a>02368   <span class="comment"></span>
<a name="l02369"></a>02369 <span class="comment">  /** \copydoc vigra::acc::AccumulatorChain::updatePassN(T const &amp;,double,unsigned int) */</span>
<a name="l02370"></a>02370   <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#a26d54a15d24e445b88b83f882972e46d">updatePassN</a>(T <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N);
<a name="l02371"></a>02371   
<a name="l02372"></a>02372 <span class="preprocessor">#endif</span>
<a name="l02373"></a>02373 <span class="preprocessor"></span>    
<a name="l02374"></a>02374   <span class="keyword">private</span>:
<a name="l02375"></a>02375     <span class="keyword">static</span> <a class="code" href="classvigra_1_1ArrayVector.html">ArrayVector&lt;std::string&gt;</a> collectTagNames()
<a name="l02376"></a>02376     {
<a name="l02377"></a>02377         <a class="code" href="classvigra_1_1ArrayVector.html">ArrayVector&lt;std::string&gt;</a> n;
<a name="l02378"></a>02378         acc_detail::CollectAccumulatorNames&lt;AccumulatorTags&gt;::exec(n);
<a name="l02379"></a>02379         std::sort(n.<a class="code" href="classvigra_1_1ArrayVectorView.html#aa4b02d4f1a8500fb07a551069060709f">begin</a>(), n.<a class="code" href="classvigra_1_1ArrayVectorView.html#a350132543d80a1c1e5be844e6d2878ea">end</a>());
<a name="l02380"></a>02380         <span class="keywordflow">return</span> n;
<a name="l02381"></a>02381     }
<a name="l02382"></a>02382 };
<a name="l02383"></a>02383 
<a name="l02384"></a>02384 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keyword">class</span> T3, <span class="keyword">class</span> T4, <span class="keyword">class</span> T5, <span class="keyword">class</span> Selected, <span class="keywordtype">bool</span> dynamic&gt;
<a name="l02385"></a>02385 <span class="keyword">class </span>AccumulatorChainArray&lt;CoupledArrays&lt;N, T1, T2, T3, T4, T5&gt;, Selected, dynamic&gt;
<a name="l02386"></a>02386 : <span class="keyword">public</span> AccumulatorChainArray&lt;typename CoupledArrays&lt;N, T1, T2, T3, T4, T5&gt;::HandleType, Selected, dynamic&gt;
<a name="l02387"></a>02387 {};
<a name="l02388"></a>02388 <span class="comment"></span>
<a name="l02389"></a>02389 <span class="comment">/** \brief Create an array of dynamic accumulator chains containing the selected per-region and global statistics and their dependencies.</span>
<a name="l02390"></a>02390 <span class="comment"></span>
<a name="l02391"></a>02391 <span class="comment"></span>
<a name="l02392"></a>02392 <span class="comment">    DynamicAccumulatorChainArray is used to compute per-region statistics (as well as global statistics) with run-time activation. A set of statistics is selected at run-time and from this set statistics can be activated at run-time by calling activate&lt;stat&gt;() or activate(std::string stat).</span>
<a name="l02393"></a>02393 <span class="comment"></span>
<a name="l02394"></a>02394 <span class="comment">     The template parameters are as follows:</span>
<a name="l02395"></a>02395 <span class="comment">    - T: The input type, type of CoupledHandle (for access to coordinates, labels and weights)</span>
<a name="l02396"></a>02396 <span class="comment">    - Selected: statistics to be computed and index specifier for the CoupledHandle, wrapped with Select</span>
<a name="l02397"></a>02397 <span class="comment"></span>
<a name="l02398"></a>02398 <span class="comment">    Usage:</span>
<a name="l02399"></a>02399 <span class="comment">    \code</span>
<a name="l02400"></a>02400 <span class="comment">    const int dim = 3; //dimension of MultiArray</span>
<a name="l02401"></a>02401 <span class="comment">    typedef double DataType;</span>
<a name="l02402"></a>02402 <span class="comment">    typedef double WeightType;</span>
<a name="l02403"></a>02403 <span class="comment">    typedef unsigned int LabelType;</span>
<a name="l02404"></a>02404 <span class="comment">    typedef vigra::CoupledIteratorType&lt;dim, DataType, WeightType, LabelType&gt;::HandleType Handle;</span>
<a name="l02405"></a>02405 <span class="comment">    DynamicAccumulatorChainArray&lt;Handle, Select&lt;DataArg&lt;1&gt;, WeightArg&lt;2&gt;, LabelArg&lt;3&gt;, Mean, Variance, ...&gt; &gt; a;</span>
<a name="l02406"></a>02406 <span class="comment">    \endcode</span>
<a name="l02407"></a>02407 <span class="comment"></span>
<a name="l02408"></a>02408 <span class="comment">    See \ref FeatureAccumulators for more information and examples of use.</span>
<a name="l02409"></a>02409 <span class="comment">*/</span>
<a name="l02410"></a>02410 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Selected&gt;
<a name="l02411"></a><a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChainArray.html">02411</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChainArray.html" title="Create an array of dynamic accumulator chains containing the selected per-region and global statistic...">DynamicAccumulatorChainArray</a>
<a name="l02412"></a>02412 : <span class="keyword">public</span> <a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html" title="Create an array of accumulator chains containing the selected per-region and global statistics and th...">AccumulatorChainArray</a>&lt;T, Selected, true&gt;
<a name="l02413"></a>02413 {
<a name="l02414"></a>02414   <span class="keyword">public</span>:
<a name="l02415"></a>02415     <span class="keyword">typedef</span> <span class="keyword">typename</span> DynamicAccumulatorChainArray::AccumulatorTags AccumulatorTags;
<a name="l02416"></a>02416 <span class="comment"></span>
<a name="l02417"></a>02417 <span class="comment">    /** \copydoc DynamicAccumulatorChain::activate(std::string tag) */</span>
<a name="l02418"></a><a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChainArray.html#a5bd1d05096902d88b887048257526404">02418</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChainArray.html#a7cd630295d4a20bcb714422ba64a16df">activate</a>(std::string tag)
<a name="l02419"></a>02419     {
<a name="l02420"></a>02420         vigra_precondition(activateImpl(tag),
<a name="l02421"></a>02421             std::string(<span class="stringliteral">&quot;DynamicAccumulatorChainArray::activate(): Tag &#39;&quot;</span>) + tag + <span class="stringliteral">&quot;&#39; not found.&quot;</span>);
<a name="l02422"></a>02422     }
<a name="l02423"></a>02423     <span class="comment"></span>
<a name="l02424"></a>02424 <span class="comment">    /** \copydoc DynamicAccumulatorChain::activate() */</span>
<a name="l02425"></a>02425     <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG&gt;
<a name="l02426"></a><a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChainArray.html#a7cd630295d4a20bcb714422ba64a16df">02426</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChainArray.html#a7cd630295d4a20bcb714422ba64a16df">activate</a>()
<a name="l02427"></a>02427     {
<a name="l02428"></a>02428         this-&gt;next_.template activate&lt;TAG&gt;();
<a name="l02429"></a>02429     }
<a name="l02430"></a>02430     <span class="comment"></span>
<a name="l02431"></a>02431 <span class="comment">    /** \copydoc DynamicAccumulatorChain::activateAll() */</span>
<a name="l02432"></a><a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChainArray.html#a9022e4f28cb69187a5dcc53bb5df6dc8">02432</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChainArray.html#a9022e4f28cb69187a5dcc53bb5df6dc8">activateAll</a>()
<a name="l02433"></a>02433     {
<a name="l02434"></a>02434         this-&gt;next_.activateAll();
<a name="l02435"></a>02435     }
<a name="l02436"></a>02436     <span class="comment"></span>
<a name="l02437"></a>02437 <span class="comment">    /** Return true if the statistic &#39;tag&#39; is active, i.e. activate(std::string tag) or activate&lt;TAG&gt;() has been called. If the statistic is not in the accumulator chain a PreconditionViolation is thrown. (Note that alias names are not recognized.)</span>
<a name="l02438"></a>02438 <span class="comment">     */</span>
<a name="l02439"></a><a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChainArray.html#ab011d6be64cc5bbbcca176f42c0a6829">02439</a>     <span class="keywordtype">bool</span> <a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChainArray.html#a16fd1b677a8d61959f5531d8d1a5836b">isActive</a>(std::string tag)<span class="keyword"> const</span>
<a name="l02440"></a>02440 <span class="keyword">    </span>{
<a name="l02441"></a>02441         acc_detail::TagIsActive_Visitor v;
<a name="l02442"></a>02442         vigra_precondition(isActiveImpl(tag, v),
<a name="l02443"></a>02443             std::string(<span class="stringliteral">&quot;DynamicAccumulatorChainArray::isActive(): Tag &#39;&quot;</span>) + tag + <span class="stringliteral">&quot;&#39; not found.&quot;</span>);
<a name="l02444"></a>02444         <span class="keywordflow">return</span> v.result;
<a name="l02445"></a>02445     }
<a name="l02446"></a>02446     <span class="comment"></span>
<a name="l02447"></a>02447 <span class="comment">    /** %isActive&lt;TAG&gt;() returns true if statistic &#39;TAG&#39; is active, i.e. activate(std::string tag) or activate&lt;TAG&gt;() has been called. If the statistic is not in the accumulator chain, true is returned. (?)</span>
<a name="l02448"></a>02448 <span class="comment">     */</span>
<a name="l02449"></a>02449     <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG&gt;
<a name="l02450"></a><a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChainArray.html#a16fd1b677a8d61959f5531d8d1a5836b">02450</a>     <span class="keywordtype">bool</span> <a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChainArray.html#a16fd1b677a8d61959f5531d8d1a5836b">isActive</a>()<span class="keyword"> const</span>
<a name="l02451"></a>02451 <span class="keyword">    </span>{
<a name="l02452"></a>02452         <span class="keywordflow">return</span> this-&gt;next_.template isActive&lt;TAG&gt;();
<a name="l02453"></a>02453     }
<a name="l02454"></a>02454     <span class="comment"></span>
<a name="l02455"></a>02455 <span class="comment">    /** \copydoc DynamicAccumulatorChain::activeNames() */</span>
<a name="l02456"></a><a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChainArray.html#aee4db7ed5a21be62f6c8154e57bc139b">02456</a>     <a class="code" href="classvigra_1_1ArrayVector.html">ArrayVector&lt;std::string&gt;</a> <a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChainArray.html#aee4db7ed5a21be62f6c8154e57bc139b">activeNames</a>()<span class="keyword"> const</span>
<a name="l02457"></a>02457 <span class="keyword">    </span>{
<a name="l02458"></a>02458         <a class="code" href="classvigra_1_1ArrayVector.html">ArrayVector&lt;std::string&gt;</a> res;
<a name="l02459"></a>02459         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> k=0; k&lt;<a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#a40bc528dbf2f0d32cc6a743a33a78a44">DynamicAccumulatorChainArray::tagNames</a>().size(); ++k)
<a name="l02460"></a>02460             <span class="keywordflow">if</span>(<a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChainArray.html#a16fd1b677a8d61959f5531d8d1a5836b">isActive</a>(<a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#a40bc528dbf2f0d32cc6a743a33a78a44">DynamicAccumulatorChainArray::tagNames</a>()[k]))
<a name="l02461"></a>02461                 res.push_back(<a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html#a40bc528dbf2f0d32cc6a743a33a78a44">DynamicAccumulatorChainArray::tagNames</a>()[k]);
<a name="l02462"></a>02462         <span class="keywordflow">return</span> res;
<a name="l02463"></a>02463     }
<a name="l02464"></a>02464     <span class="comment"></span>
<a name="l02465"></a>02465 <span class="comment">    /** \copydoc DynamicAccumulatorChain::passesRequired() */</span>
<a name="l02466"></a><a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChainArray.html#a59d54352fe534a555cee5dea27c7d304">02466</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChainArray.html#a59d54352fe534a555cee5dea27c7d304">passesRequired</a>()<span class="keyword"> const</span>
<a name="l02467"></a>02467 <span class="keyword">    </span>{
<a name="l02468"></a>02468         <span class="keywordflow">return</span> this-&gt;next_.passesRequiredDynamic();
<a name="l02469"></a>02469     }
<a name="l02470"></a>02470 
<a name="l02471"></a>02471   <span class="keyword">protected</span>:
<a name="l02472"></a>02472   
<a name="l02473"></a>02473     <span class="keywordtype">bool</span> activateImpl(std::string tag)
<a name="l02474"></a>02474     {
<a name="l02475"></a>02475         <span class="keywordflow">return</span> acc_detail::ApplyVisitorToTag&lt;AccumulatorTags&gt;::exec(this-&gt;next_, 
<a name="l02476"></a>02476                                          <a class="code" href="namespacevigra.html#a9e4131b7743b5801ce7122df2c63a9ba">normalizeString</a>(tag), acc_detail::ActivateTag_Visitor());
<a name="l02477"></a>02477     }
<a name="l02478"></a>02478     
<a name="l02479"></a>02479     <span class="keywordtype">bool</span> isActiveImpl(std::string tag, acc_detail::TagIsActive_Visitor &amp; v)<span class="keyword"> const</span>
<a name="l02480"></a>02480 <span class="keyword">    </span>{
<a name="l02481"></a>02481         <span class="keywordflow">return</span> acc_detail::ApplyVisitorToTag&lt;AccumulatorTags&gt;::exec(this-&gt;next_, <a class="code" href="namespacevigra.html#a9e4131b7743b5801ce7122df2c63a9ba">normalizeString</a>(tag), v);
<a name="l02482"></a>02482     }
<a name="l02483"></a>02483 };
<a name="l02484"></a>02484 
<a name="l02485"></a>02485 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keyword">class</span> T3, <span class="keyword">class</span> T4, <span class="keyword">class</span> T5, <span class="keyword">class</span> Selected&gt;
<a name="l02486"></a>02486 <span class="keyword">class </span>DynamicAccumulatorChainArray&lt;CoupledArrays&lt;N, T1, T2, T3, T4, T5&gt;, Selected&gt;
<a name="l02487"></a>02487 : <span class="keyword">public</span> DynamicAccumulatorChainArray&lt;typename CoupledArrays&lt;N, T1, T2, T3, T4, T5&gt;::HandleType, Selected&gt;
<a name="l02488"></a>02488 {};
<a name="l02489"></a>02489 
<a name="l02490"></a>02490 <span class="comment">/****************************************************************************/</span>
<a name="l02491"></a>02491 <span class="comment">/*                                                                          */</span>
<a name="l02492"></a>02492 <span class="comment">/*                        generic access functions                          */</span>
<a name="l02493"></a>02493 <span class="comment">/*                                                                          */</span>
<a name="l02494"></a>02494 <span class="comment">/****************************************************************************/</span>
<a name="l02495"></a>02495 
<a name="l02496"></a>02496 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG&gt;
<a name="l02497"></a>02497 <span class="keyword">struct </span>Error__Attempt_to_access_inactive_statistic;
<a name="l02498"></a>02498 
<a name="l02499"></a>02499 <span class="keyword">namespace </span>acc_detail {
<a name="l02500"></a>02500 
<a name="l02501"></a>02501     <span class="comment">// accumulator lookup rules: find the accumulator that implements TAG</span>
<a name="l02502"></a>02502     
<a name="l02503"></a>02503     <span class="comment">// When A does not implement TAG, continue search in A::InternalBaseType.</span>
<a name="l02504"></a>02504 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG, <span class="keyword">class</span> A, <span class="keyword">class</span> FromTag=<span class="keyword">typename</span> A::Tag&gt;
<a name="l02505"></a>02505 <span class="keyword">struct </span>LookupTagImpl
<a name="l02506"></a>02506 #ifndef DOXYGEN
<a name="l02507"></a>02507 : <span class="keyword">public</span> LookupTagImpl&lt;TAG, typename A::InternalBaseType&gt;
<a name="l02508"></a>02508 <span class="preprocessor">#endif</span>
<a name="l02509"></a>02509 <span class="preprocessor"></span>{};
<a name="l02510"></a>02510 
<a name="l02511"></a>02511     <span class="comment">// &#39;const A&#39; is treated like A, except that the reference member is now const.</span>
<a name="l02512"></a>02512 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG, <span class="keyword">class</span> A, <span class="keyword">class</span> FromTag&gt;
<a name="l02513"></a>02513 <span class="keyword">struct </span>LookupTagImpl&lt;TAG, A const, FromTag&gt;
<a name="l02514"></a>02514 : <span class="keyword">public</span> LookupTagImpl&lt;TAG, A&gt;
<a name="l02515"></a>02515 {
<a name="l02516"></a>02516     <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupTagImpl&lt;TAG, A&gt;::type <span class="keyword">const</span> &amp; reference;
<a name="l02517"></a>02517     <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupTagImpl&lt;TAG, A&gt;::type <span class="keyword">const</span> * pointer;
<a name="l02518"></a>02518 };
<a name="l02519"></a>02519 
<a name="l02520"></a>02520     <span class="comment">// When A implements TAG, report its type and associated information.</span>
<a name="l02521"></a>02521 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG, <span class="keyword">class</span> A&gt;
<a name="l02522"></a>02522 <span class="keyword">struct </span>LookupTagImpl&lt;TAG, A, TAG&gt;
<a name="l02523"></a>02523 {
<a name="l02524"></a>02524     <span class="keyword">typedef</span> TAG Tag;
<a name="l02525"></a>02525     <span class="keyword">typedef</span> A type;
<a name="l02526"></a>02526     <span class="keyword">typedef</span> A &amp; reference;
<a name="l02527"></a>02527     <span class="keyword">typedef</span> A * pointer;
<a name="l02528"></a>02528     <span class="keyword">typedef</span> <span class="keyword">typename</span> A::value_type value_type;
<a name="l02529"></a>02529     <span class="keyword">typedef</span> <span class="keyword">typename</span> A::result_type result_type;
<a name="l02530"></a>02530 };
<a name="l02531"></a>02531 
<a name="l02532"></a>02532     <span class="comment">// Again, &#39;const A&#39; is treated like A, except that the reference member is now const.</span>
<a name="l02533"></a>02533 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG, <span class="keyword">class</span> A&gt;
<a name="l02534"></a>02534 <span class="keyword">struct </span>LookupTagImpl&lt;TAG, A const, TAG&gt;
<a name="l02535"></a>02535 : <span class="keyword">public</span> LookupTagImpl&lt;TAG, A, TAG&gt;
<a name="l02536"></a>02536 {
<a name="l02537"></a>02537     <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupTagImpl&lt;TAG, A, TAG&gt;::type <span class="keyword">const</span> &amp; reference;
<a name="l02538"></a>02538     <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupTagImpl&lt;TAG, A, TAG&gt;::type <span class="keyword">const</span> * pointer;
<a name="l02539"></a>02539 };
<a name="l02540"></a>02540 
<a name="l02541"></a>02541     <span class="comment">// Recursion termination: when we end up in AccumulatorEnd without finding a </span>
<a name="l02542"></a>02542     <span class="comment">// suitable A, we stop and report an error</span>
<a name="l02543"></a>02543 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG, <span class="keyword">class</span> A&gt;
<a name="l02544"></a>02544 <span class="keyword">struct </span>LookupTagImpl&lt;TAG, A, AccumulatorEnd&gt;
<a name="l02545"></a>02545 {
<a name="l02546"></a>02546     <span class="keyword">typedef</span> TAG Tag;
<a name="l02547"></a>02547     <span class="keyword">typedef</span> A type;
<a name="l02548"></a>02548     <span class="keyword">typedef</span> A &amp; reference;
<a name="l02549"></a>02549     <span class="keyword">typedef</span> A * pointer;
<a name="l02550"></a>02550     <span class="keyword">typedef</span> Error__Attempt_to_access_inactive_statistic&lt;TAG&gt; value_type;
<a name="l02551"></a>02551     <span class="keyword">typedef</span> Error__Attempt_to_access_inactive_statistic&lt;TAG&gt; result_type;
<a name="l02552"></a>02552 };
<a name="l02553"></a>02553 
<a name="l02554"></a>02554     <span class="comment">// ... except when we are actually looking for AccumulatorEnd</span>
<a name="l02555"></a>02555 <span class="keyword">template</span> &lt;<span class="keyword">class</span> A&gt;
<a name="l02556"></a>02556 <span class="keyword">struct </span>LookupTagImpl&lt;AccumulatorEnd, A, AccumulatorEnd&gt;
<a name="l02557"></a>02557 {
<a name="l02558"></a>02558     <span class="keyword">typedef</span> AccumulatorEnd Tag;
<a name="l02559"></a>02559     <span class="keyword">typedef</span> A type;
<a name="l02560"></a>02560     <span class="keyword">typedef</span> A &amp; reference;
<a name="l02561"></a>02561     <span class="keyword">typedef</span> A * pointer;
<a name="l02562"></a>02562     <span class="keyword">typedef</span> <span class="keywordtype">void</span> value_type;
<a name="l02563"></a>02563     <span class="keyword">typedef</span> <span class="keywordtype">void</span> result_type;
<a name="l02564"></a>02564 };
<a name="l02565"></a>02565 
<a name="l02566"></a>02566     <span class="comment">// ... or we are looking for a global statistic, in which case</span>
<a name="l02567"></a>02567     <span class="comment">// we continue the serach via A::GlobalAccumulatorType, but remember that </span>
<a name="l02568"></a>02568     <span class="comment">// we are actually looking for a global tag. </span>
<a name="l02569"></a>02569 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG, <span class="keyword">class</span> A&gt;
<a name="l02570"></a>02570 <span class="keyword">struct </span>LookupTagImpl&lt;Global&lt;TAG&gt;, A, AccumulatorEnd&gt;
<a name="l02571"></a>02571 : <span class="keyword">public</span> LookupTagImpl&lt;TAG, typename A::GlobalAccumulatorType&gt;
<a name="l02572"></a>02572 {
<a name="l02573"></a>02573     <span class="keyword">typedef</span> Global&lt;TAG&gt; Tag;
<a name="l02574"></a>02574 };
<a name="l02575"></a>02575 
<a name="l02576"></a>02576     <span class="comment">// When we encounter the LabelDispatch accumulator, we continue the</span>
<a name="l02577"></a>02577     <span class="comment">// search via LabelDispatch::RegionAccumulatorChain by default</span>
<a name="l02578"></a>02578 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG, <span class="keyword">class</span> A&gt;
<a name="l02579"></a>02579 <span class="keyword">struct </span>LookupTagImpl&lt;TAG, A, LabelDispatchTag&gt;
<a name="l02580"></a>02580 : <span class="keyword">public</span> LookupTagImpl&lt;TAG, typename A::RegionAccumulatorChain&gt;
<a name="l02581"></a>02581 {};
<a name="l02582"></a>02582 
<a name="l02583"></a>02583     <span class="comment">// ... except when we are looking for a global statistic, in which case</span>
<a name="l02584"></a>02584     <span class="comment">// we continue via LabelDispatch::GlobalAccumulatorChain, but remember that </span>
<a name="l02585"></a>02585     <span class="comment">// we are actually looking for a global tag.</span>
<a name="l02586"></a>02586 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG, <span class="keyword">class</span> A&gt;
<a name="l02587"></a>02587 <span class="keyword">struct </span>LookupTagImpl&lt;Global&lt;TAG&gt;, A, LabelDispatchTag&gt;
<a name="l02588"></a>02588 : <span class="keyword">public</span> LookupTagImpl&lt;TAG, typename A::GlobalAccumulatorChain&gt;
<a name="l02589"></a>02589 {
<a name="l02590"></a>02590     <span class="keyword">typedef</span> Global&lt;TAG&gt; Tag;
<a name="l02591"></a>02591 };
<a name="l02592"></a>02592 
<a name="l02593"></a>02593     <span class="comment">// ... or we are looking for the LabelDispatch accumulator itself</span>
<a name="l02594"></a>02594 <span class="keyword">template</span> &lt;<span class="keyword">class</span> A&gt;
<a name="l02595"></a>02595 <span class="keyword">struct </span>LookupTagImpl&lt;LabelDispatchTag, A, LabelDispatchTag&gt;
<a name="l02596"></a>02596 {
<a name="l02597"></a>02597     <span class="keyword">typedef</span> LabelDispatchTag Tag;
<a name="l02598"></a>02598     <span class="keyword">typedef</span> A type;
<a name="l02599"></a>02599     <span class="keyword">typedef</span> A &amp; reference;
<a name="l02600"></a>02600     <span class="keyword">typedef</span> A * pointer;
<a name="l02601"></a>02601     <span class="keyword">typedef</span> <span class="keywordtype">void</span> value_type;
<a name="l02602"></a>02602     <span class="keyword">typedef</span> <span class="keywordtype">void</span> result_type;
<a name="l02603"></a>02603 };
<a name="l02604"></a>02604 
<a name="l02605"></a>02605 } <span class="comment">// namespace acc_detail</span>
<a name="l02606"></a>02606 
<a name="l02607"></a>02607     <span class="comment">// Lookup the accumulator in the chain A that implements the given TAG.</span>
<a name="l02608"></a>02608 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Tag, <span class="keyword">class</span> A&gt;
<a name="l02609"></a>02609 <span class="keyword">struct </span>LookupTag
<a name="l02610"></a>02610 : <span class="keyword">public</span> acc_detail::LookupTagImpl&lt;typename StandardizeTag&lt;Tag&gt;::type, A&gt;
<a name="l02611"></a>02611 {};
<a name="l02612"></a>02612 
<a name="l02613"></a>02613     <span class="comment">// Lookup the dependency TAG of the accumulator A.</span>
<a name="l02614"></a>02614     <span class="comment">// This template ensures that dependencies are used with matching modifiers.</span>
<a name="l02615"></a>02615     <span class="comment">// Specifically, if you search for Count as a dependency of Weighted&lt;Mean&gt;, the search</span>
<a name="l02616"></a>02616     <span class="comment">// actually returns Weighted&lt;Count&gt;, wheras Count will be returned for plain Mean.</span>
<a name="l02617"></a>02617 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Tag, <span class="keyword">class</span> A, <span class="keyword">class</span> TargetTag&gt;
<a name="l02618"></a>02618 <span class="keyword">struct </span>LookupDependency
<a name="l02619"></a>02619 : <span class="keyword">public</span> acc_detail::LookupTagImpl&lt;
<a name="l02620"></a>02620        typename TransferModifiers&lt;TargetTag, typename StandardizeTag&lt;Tag&gt;::type&gt;::type, A&gt;
<a name="l02621"></a>02621 {};
<a name="l02622"></a>02622  
<a name="l02623"></a>02623 
<a name="l02624"></a>02624 <span class="keyword">namespace </span>acc_detail {
<a name="l02625"></a>02625 
<a name="l02626"></a>02626     <span class="comment">// CastImpl applies the same rules as LookupTagImpl, but returns a reference to an </span>
<a name="l02627"></a>02627     <span class="comment">// accumulator instance rather than an accumulator type</span>
<a name="l02628"></a>02628 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Tag, <span class="keyword">class</span> FromTag, <span class="keyword">class</span> reference&gt;
<a name="l02629"></a>02629 <span class="keyword">struct </span>CastImpl
<a name="l02630"></a>02630 {
<a name="l02631"></a>02631     <span class="keyword">template</span> &lt;<span class="keyword">class</span> A&gt;
<a name="l02632"></a>02632     <span class="keyword">static</span> reference exec(A &amp; a)
<a name="l02633"></a>02633     {
<a name="l02634"></a>02634         <span class="keywordflow">return</span> CastImpl&lt;Tag, typename A::InternalBaseType::Tag, reference&gt;::exec(a.next_);
<a name="l02635"></a>02635     }
<a name="l02636"></a>02636     
<a name="l02637"></a>02637     <span class="keyword">template</span> &lt;<span class="keyword">class</span> A&gt;
<a name="l02638"></a>02638     <span class="keyword">static</span> reference exec(A &amp; a, <a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a> label)
<a name="l02639"></a>02639     {
<a name="l02640"></a>02640         <span class="keywordflow">return</span> CastImpl&lt;Tag, typename A::InternalBaseType::Tag, reference&gt;::exec(a.next_, label);
<a name="l02641"></a>02641     }
<a name="l02642"></a>02642 };
<a name="l02643"></a>02643 
<a name="l02644"></a>02644 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Tag, <span class="keyword">class</span> reference&gt;
<a name="l02645"></a>02645 <span class="keyword">struct </span>CastImpl&lt;Tag, Tag, reference&gt;
<a name="l02646"></a>02646 {
<a name="l02647"></a>02647     <span class="keyword">template</span> &lt;<span class="keyword">class</span> A&gt;
<a name="l02648"></a>02648     <span class="keyword">static</span> reference exec(A &amp; a)
<a name="l02649"></a>02649     {
<a name="l02650"></a>02650         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>reference<span class="keyword">&gt;</span>(a);
<a name="l02651"></a>02651     }
<a name="l02652"></a>02652     
<a name="l02653"></a>02653     <span class="keyword">template</span> &lt;<span class="keyword">class</span> A&gt;
<a name="l02654"></a>02654     <span class="keyword">static</span> reference exec(A &amp; a, <a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a>)
<a name="l02655"></a>02655     {
<a name="l02656"></a>02656         vigra_precondition(<span class="keyword">false</span>, 
<a name="l02657"></a>02657             <span class="stringliteral">&quot;getAccumulator(): region accumulators can only be queried for AccumulatorChainArray.&quot;</span>);
<a name="l02658"></a>02658         <span class="keywordflow">return</span> a;
<a name="l02659"></a>02659     }
<a name="l02660"></a>02660 };
<a name="l02661"></a>02661 
<a name="l02662"></a>02662 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Tag, <span class="keyword">class</span> reference&gt;
<a name="l02663"></a>02663 <span class="keyword">struct </span>CastImpl&lt;Tag, AccumulatorEnd, reference&gt;
<a name="l02664"></a>02664 {
<a name="l02665"></a>02665     <span class="keyword">template</span> &lt;<span class="keyword">class</span> A&gt;
<a name="l02666"></a>02666     <span class="keyword">static</span> reference exec(A &amp; a)
<a name="l02667"></a>02667     {
<a name="l02668"></a>02668         <span class="keywordflow">return</span> a;
<a name="l02669"></a>02669     }
<a name="l02670"></a>02670     
<a name="l02671"></a>02671     <span class="keyword">template</span> &lt;<span class="keyword">class</span> A&gt;
<a name="l02672"></a>02672     <span class="keyword">static</span> reference exec(A &amp; a, <a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a>)
<a name="l02673"></a>02673     {
<a name="l02674"></a>02674         <span class="keywordflow">return</span> a;
<a name="l02675"></a>02675     }
<a name="l02676"></a>02676 };
<a name="l02677"></a>02677 
<a name="l02678"></a>02678 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Tag, <span class="keyword">class</span> reference&gt;
<a name="l02679"></a>02679 <span class="keyword">struct </span>CastImpl&lt;Global&lt;Tag&gt;, AccumulatorEnd, reference&gt;
<a name="l02680"></a>02680 {
<a name="l02681"></a>02681     <span class="keyword">template</span> &lt;<span class="keyword">class</span> A&gt;
<a name="l02682"></a>02682     <span class="keyword">static</span> reference exec(A &amp; a)
<a name="l02683"></a>02683     {
<a name="l02684"></a>02684         <span class="keywordflow">return</span> CastImpl&lt;Tag, typename A::GlobalAccumulatorType::Tag, reference&gt;::exec(*a.globalAccumulator_.pointer_);
<a name="l02685"></a>02685     }
<a name="l02686"></a>02686 };
<a name="l02687"></a>02687 
<a name="l02688"></a>02688 <span class="keyword">template</span> &lt;<span class="keyword">class</span> reference&gt;
<a name="l02689"></a>02689 <span class="keyword">struct </span>CastImpl&lt;AccumulatorEnd, AccumulatorEnd, reference&gt;
<a name="l02690"></a>02690 {
<a name="l02691"></a>02691     <span class="keyword">template</span> &lt;<span class="keyword">class</span> A&gt;
<a name="l02692"></a>02692     <span class="keyword">static</span> reference exec(A &amp; a)
<a name="l02693"></a>02693     {
<a name="l02694"></a>02694         <span class="keywordflow">return</span> a;
<a name="l02695"></a>02695     }
<a name="l02696"></a>02696     
<a name="l02697"></a>02697     <span class="keyword">template</span> &lt;<span class="keyword">class</span> A&gt;
<a name="l02698"></a>02698     <span class="keyword">static</span> reference exec(A &amp; a, <a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a>)
<a name="l02699"></a>02699     {
<a name="l02700"></a>02700         <span class="keywordflow">return</span> a;
<a name="l02701"></a>02701     }
<a name="l02702"></a>02702 };
<a name="l02703"></a>02703 
<a name="l02704"></a>02704 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Tag, <span class="keyword">class</span> reference&gt;
<a name="l02705"></a>02705 <span class="keyword">struct </span>CastImpl&lt;Tag, LabelDispatchTag, reference&gt;
<a name="l02706"></a>02706 {
<a name="l02707"></a>02707     <span class="keyword">template</span> &lt;<span class="keyword">class</span> A&gt;
<a name="l02708"></a>02708     <span class="keyword">static</span> reference exec(A &amp; a)
<a name="l02709"></a>02709     {
<a name="l02710"></a>02710         vigra_precondition(<span class="keyword">false</span>, 
<a name="l02711"></a>02711             <span class="stringliteral">&quot;getAccumulator(): a region label is required when a region accumulator is queried.&quot;</span>);
<a name="l02712"></a>02712         <span class="keywordflow">return</span> CastImpl&lt;Tag, typename A::RegionAccumulatorChain::Tag, reference&gt;::exec(a.regions_[0]);
<a name="l02713"></a>02713     }
<a name="l02714"></a>02714     
<a name="l02715"></a>02715     <span class="keyword">template</span> &lt;<span class="keyword">class</span> A&gt;
<a name="l02716"></a>02716     <span class="keyword">static</span> reference exec(A &amp; a, <a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a> label)
<a name="l02717"></a>02717     {
<a name="l02718"></a>02718         <span class="keywordflow">return</span> CastImpl&lt;Tag, typename A::RegionAccumulatorChain::Tag, reference&gt;::exec(a.regions_[label]);
<a name="l02719"></a>02719     }
<a name="l02720"></a>02720 };
<a name="l02721"></a>02721 
<a name="l02722"></a>02722 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Tag, <span class="keyword">class</span> reference&gt;
<a name="l02723"></a>02723 <span class="keyword">struct </span>CastImpl&lt;Global&lt;Tag&gt;, LabelDispatchTag, reference&gt;
<a name="l02724"></a>02724 {
<a name="l02725"></a>02725     <span class="keyword">template</span> &lt;<span class="keyword">class</span> A&gt;
<a name="l02726"></a>02726     <span class="keyword">static</span> reference exec(A &amp; a)
<a name="l02727"></a>02727     {
<a name="l02728"></a>02728         <span class="keywordflow">return</span> CastImpl&lt;Tag, typename A::GlobalAccumulatorChain::Tag, reference&gt;::exec(a.next_);
<a name="l02729"></a>02729     }
<a name="l02730"></a>02730 };
<a name="l02731"></a>02731 
<a name="l02732"></a>02732 <span class="keyword">template</span> &lt;<span class="keyword">class</span> reference&gt;
<a name="l02733"></a>02733 <span class="keyword">struct </span>CastImpl&lt;LabelDispatchTag, LabelDispatchTag, reference&gt;
<a name="l02734"></a>02734 {
<a name="l02735"></a>02735     <span class="keyword">template</span> &lt;<span class="keyword">class</span> A&gt;
<a name="l02736"></a>02736     <span class="keyword">static</span> reference exec(A &amp; a)
<a name="l02737"></a>02737     {
<a name="l02738"></a>02738         <span class="keywordflow">return</span> a;
<a name="l02739"></a>02739     }
<a name="l02740"></a>02740 };
<a name="l02741"></a>02741 
<a name="l02742"></a>02742 } <span class="comment">// namespace acc_detail</span>
<a name="l02743"></a>02743 
<a name="l02744"></a>02744     <span class="comment">// Get a reference to the accumulator TAG in the accumulator chain A</span><span class="comment"></span>
<a name="l02745"></a>02745 <span class="comment">/** Get a reference to the accumulator &#39;TAG&#39; in the accumulator chain &#39;a&#39;. This can be useful for example to update a certain accumulator with data, set individual options or get information about a certain accumulator.\n</span>
<a name="l02746"></a>02746 <span class="comment">Example of use (set options):</span>
<a name="l02747"></a>02747 <span class="comment">\code</span>
<a name="l02748"></a>02748 <span class="comment">    vigra::MultiArray&lt;2, double&gt; data(...);   </span>
<a name="l02749"></a>02749 <span class="comment">    typedef UserRangeHistogram&lt;40&gt; SomeHistogram;   //binCount set at compile time</span>
<a name="l02750"></a>02750 <span class="comment">    typedef UserRangeHistogram&lt;0&gt; SomeHistogram2; // binCount must be set at run-time</span>
<a name="l02751"></a>02751 <span class="comment">    AccumulatorChain&lt;DataType, Select&lt;SomeHistogram, SomeHistogram2&gt; &gt; a;</span>
<a name="l02752"></a>02752 <span class="comment">    </span>
<a name="l02753"></a>02753 <span class="comment">    getAccumulator&lt;SomeHistogram&gt;(a).setMinMax(0.1, 0.9);</span>
<a name="l02754"></a>02754 <span class="comment">    getAccumulator&lt;SomeHistogram2&gt;(a).setMinMax(0.0, 1.0);</span>
<a name="l02755"></a>02755 <span class="comment"></span>
<a name="l02756"></a>02756 <span class="comment">    extractFeatures(data.begin(), data.end(), a);</span>
<a name="l02757"></a>02757 <span class="comment">\endcode</span>
<a name="l02758"></a>02758 <span class="comment"></span>
<a name="l02759"></a>02759 <span class="comment">Example of use (get information):</span>
<a name="l02760"></a>02760 <span class="comment">\code</span>
<a name="l02761"></a>02761 <span class="comment">  vigra::MultiArray&lt;2, double&gt; data(...));</span>
<a name="l02762"></a>02762 <span class="comment">  AccumulatorChain&lt;double, Select&lt;Mean, Skewness&gt; &gt; a;</span>
<a name="l02763"></a>02763 <span class="comment"></span>
<a name="l02764"></a>02764 <span class="comment">  std::cout &lt;&lt; &quot;passes required for all statistics: &quot; &lt;&lt; a.passesRequired() &lt;&lt; std::endl; //skewness needs two passes</span>
<a name="l02765"></a>02765 <span class="comment">  std::cout &lt;&lt; &quot;passes required by Mean: &quot; &lt;&lt; getAccumulator&lt;Mean&gt;(a).passesRequired() &lt;&lt; std::endl;</span>
<a name="l02766"></a>02766 <span class="comment">\endcode</span>
<a name="l02767"></a>02767 <span class="comment">See \ref FeatureAccumulators for more information about feature computation via accumulators.</span>
<a name="l02768"></a>02768 <span class="comment">*/</span>
<a name="l02769"></a>02769 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG, <span class="keyword">class</span> A&gt;
<a name="l02770"></a>02770 <span class="keyword">inline</span> <span class="keyword">typename</span> LookupTag&lt;TAG, A&gt;::reference
<a name="l02771"></a><a class="code" href="namespacevigra_1_1acc.html#a0e56445b73dc9e9265cfd863f77be15a">02771</a> <a class="code" href="namespacevigra_1_1acc.html#a0e56445b73dc9e9265cfd863f77be15a">getAccumulator</a>(A &amp; a)
<a name="l02772"></a>02772 {
<a name="l02773"></a>02773     <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupTag&lt;TAG, A&gt;::Tag StandardizedTag;
<a name="l02774"></a>02774     <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupTag&lt;TAG, A&gt;::reference reference;
<a name="l02775"></a>02775     <span class="keywordflow">return</span> acc_detail::CastImpl&lt;StandardizedTag, typename A::Tag, reference&gt;::exec(a);
<a name="l02776"></a>02776 }
<a name="l02777"></a>02777 
<a name="l02778"></a>02778     <span class="comment">// Get a reference to the accumulator TAG for region &#39;label&#39; in the accumulator chain A</span><span class="comment"></span>
<a name="l02779"></a>02779 <span class="comment">/** Get a reference to the accumulator &#39;TAG&#39; for region &#39;label&#39; in the accumulator chain &#39;a&#39;.</span>
<a name="l02780"></a>02780 <span class="comment">*/</span>
<a name="l02781"></a>02781 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG, <span class="keyword">class</span> A&gt;
<a name="l02782"></a>02782 <span class="keyword">inline</span> <span class="keyword">typename</span> LookupTag&lt;TAG, A&gt;::reference
<a name="l02783"></a><a class="code" href="namespacevigra_1_1acc.html#aa89d25c5558f40d01c2e2d76bee89790">02783</a> <a class="code" href="namespacevigra_1_1acc.html#a0e56445b73dc9e9265cfd863f77be15a">getAccumulator</a>(A &amp; a, <a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a> label)
<a name="l02784"></a>02784 {
<a name="l02785"></a>02785     <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupTag&lt;TAG, A&gt;::Tag StandardizedTag;
<a name="l02786"></a>02786     <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupTag&lt;TAG, A&gt;::reference reference;
<a name="l02787"></a>02787     <span class="keywordflow">return</span> acc_detail::CastImpl&lt;StandardizedTag, typename A::Tag, reference&gt;::exec(a, label);
<a name="l02788"></a>02788 }
<a name="l02789"></a>02789 
<a name="l02790"></a>02790     <span class="comment">// get the result of the accumulator specified by TAG</span><span class="comment"></span>
<a name="l02791"></a>02791 <span class="comment">/** Get the result of the accumulator &#39;TAG&#39; in the accumulator chain &#39;a&#39;.\n</span>
<a name="l02792"></a>02792 <span class="comment">Example of use:</span>
<a name="l02793"></a>02793 <span class="comment">\code</span>
<a name="l02794"></a>02794 <span class="comment">    vigra::MultiArray&lt;2, double&gt; data(...);</span>
<a name="l02795"></a>02795 <span class="comment">    AccumulatorChain&lt;DataType, Select&lt;Variance, Mean, StdDev&gt; &gt; a;</span>
<a name="l02796"></a>02796 <span class="comment">    extractFeatures(data.begin(), data.end(), a); </span>
<a name="l02797"></a>02797 <span class="comment">    double mean = get&lt;Mean&gt;(a);</span>
<a name="l02798"></a>02798 <span class="comment">\endcode</span>
<a name="l02799"></a>02799 <span class="comment">See \ref FeatureAccumulators for more information about feature computation via accumulators.</span>
<a name="l02800"></a>02800 <span class="comment">*/</span>
<a name="l02801"></a>02801 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG, <span class="keyword">class</span> A&gt;
<a name="l02802"></a>02802 <span class="keyword">inline</span> <span class="keyword">typename</span> LookupTag&lt;TAG, A&gt;::result_type
<a name="l02803"></a><a class="code" href="namespacevigra_1_1acc.html#ae1dae7352beb92b0f5b64b44d4fca420">02803</a> <span class="keyword">get</span>(A <span class="keyword">const</span> &amp; a)
<a name="l02804"></a>02804 {
<a name="l02805"></a>02805     <span class="keywordflow">return</span> getAccumulator&lt;TAG&gt;(a).<span class="keyword">get</span>();
<a name="l02806"></a>02806 }
<a name="l02807"></a>02807 
<a name="l02808"></a>02808     <span class="comment">// get the result of the accumulator TAG for region &#39;label&#39;</span><span class="comment"></span>
<a name="l02809"></a>02809 <span class="comment">/** Get the result of the accumulator &#39;TAG&#39; for region &#39;label&#39; in the accumulator chain &#39;a&#39;.\n</span>
<a name="l02810"></a>02810 <span class="comment">Example of use:</span>
<a name="l02811"></a>02811 <span class="comment">\code</span>
<a name="l02812"></a>02812 <span class="comment">    vigra::MultiArray&lt;2, double&gt; data(...);</span>
<a name="l02813"></a>02813 <span class="comment">    vigra::MultiArray&lt;2, int&gt; labels(...);</span>
<a name="l02814"></a>02814 <span class="comment">    typedef vigra::CoupledIteratorType&lt;2, double, int&gt;::type Iterator;</span>
<a name="l02815"></a>02815 <span class="comment">    typedef Iterator::value_type Handle;</span>
<a name="l02816"></a>02816 <span class="comment"></span>
<a name="l02817"></a>02817 <span class="comment">    AccumulatorChainArray&lt;Handle, </span>
<a name="l02818"></a>02818 <span class="comment">        Select&lt;DataArg&lt;1&gt;, LabelArg&lt;2&gt;, Mean, Variance&gt; &gt; a;</span>
<a name="l02819"></a>02819 <span class="comment"></span>
<a name="l02820"></a>02820 <span class="comment">    Iterator start = createCoupledIterator(data, labels);</span>
<a name="l02821"></a>02821 <span class="comment">    Iterator end = start.getEndIterator();</span>
<a name="l02822"></a>02822 <span class="comment">    extractFeatures(start,end,a);</span>
<a name="l02823"></a>02823 <span class="comment"></span>
<a name="l02824"></a>02824 <span class="comment">    double mean_of_region_1 = get&lt;Mean&gt;(a,1);</span>
<a name="l02825"></a>02825 <span class="comment">    double mean_of_background = get&lt;Mean&gt;(a,0);</span>
<a name="l02826"></a>02826 <span class="comment">\endcode</span>
<a name="l02827"></a>02827 <span class="comment">See \ref FeatureAccumulators for more information about feature computation via accumulators.</span>
<a name="l02828"></a>02828 <span class="comment">*/</span>
<a name="l02829"></a>02829 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG, <span class="keyword">class</span> A&gt;
<a name="l02830"></a>02830 <span class="keyword">inline</span> <span class="keyword">typename</span> LookupTag&lt;TAG, A&gt;::result_type
<a name="l02831"></a><a class="code" href="namespacevigra_1_1acc.html#a896c0e65e971f05c9c337dc024451e21">02831</a> <span class="keyword">get</span>(A <span class="keyword">const</span> &amp; a, <a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a> label)
<a name="l02832"></a>02832 {
<a name="l02833"></a>02833     <span class="keywordflow">return</span> getAccumulator&lt;TAG&gt;(a, label).<span class="keyword">get</span>();
<a name="l02834"></a>02834 }
<a name="l02835"></a>02835 
<a name="l02836"></a>02836     <span class="comment">// Get the result of the accumulator specified by TAG without checking if the accumulator is active.</span>
<a name="l02837"></a>02837     <span class="comment">// This must be used within an accumulator implementation to access dependencies because</span>
<a name="l02838"></a>02838     <span class="comment">// it applies the approprate modifiers to the given TAG. It must not be used in other situations.</span>
<a name="l02839"></a>02839     <span class="comment">// FIXME: is there a shorter name?</span>
<a name="l02840"></a>02840 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG, <span class="keyword">class</span> A&gt;
<a name="l02841"></a>02841 <span class="keyword">inline</span> <span class="keyword">typename</span> LookupDependency&lt;TAG, A&gt;::result_type
<a name="l02842"></a>02842 getDependency(A <span class="keyword">const</span> &amp; a)
<a name="l02843"></a>02843 {
<a name="l02844"></a>02844     <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupDependency&lt;TAG, A&gt;::Tag StandardizedTag;
<a name="l02845"></a>02845     <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupDependency&lt;TAG, A&gt;::reference reference;
<a name="l02846"></a>02846     <span class="keywordflow">return</span> acc_detail::CastImpl&lt;StandardizedTag, typename A::Tag, reference&gt;::exec(a)();
<a name="l02847"></a>02847 }
<a name="l02848"></a>02848 
<a name="l02849"></a>02849     <span class="comment">// activate the dynamic accumulator specified by Tag</span><span class="comment"></span>
<a name="l02850"></a>02850 <span class="comment">/** Activate the dynamic accumulator &#39;Tag&#39; in the dynamic accumulator chain &#39;a&#39;. Same as a.activate&lt;Tag&gt;() (see DynamicAccumulatorChain::activate&lt;Tag&gt;() or DynamicAccumulatorChainArray::activate&lt;Tag&gt;()). For run-time activation use DynamicAccumulatorChain::activate(std::string tag) or DynamicAccumulatorChainArray::activate(std::string tag) instead.\n</span>
<a name="l02851"></a>02851 <span class="comment">See \ref FeatureAccumulators for more information about feature computation via accumulators.</span>
<a name="l02852"></a>02852 <span class="comment">*/</span>
<a name="l02853"></a>02853 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Tag, <span class="keyword">class</span> A&gt;
<a name="l02854"></a>02854 <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l02855"></a><a class="code" href="namespacevigra_1_1acc.html#a762643ee2596a5426da54cc3009ebfeb">02855</a> <a class="code" href="namespacevigra_1_1acc.html#a762643ee2596a5426da54cc3009ebfeb">activate</a>(A &amp; a)
<a name="l02856"></a>02856 {
<a name="l02857"></a>02857     a.template activate&lt;Tag&gt;();
<a name="l02858"></a>02858 }
<a name="l02859"></a>02859 
<a name="l02860"></a>02860     <span class="comment">// check if the dynamic accumulator specified by Tag is active</span><span class="comment"></span>
<a name="l02861"></a>02861 <span class="comment">/** Check if the dynamic accumulator &#39;Tag&#39; in the accumulator chain &#39;a&#39; is active. Same as a.isActive&lt;Tag&gt;() (see DynamicAccumulatorChain::isActive&lt;Tag&gt;() or DynamicAccumulatorChainArray::isActive&lt;Tag&gt;()). At run-time, use DynamicAccumulatorChain::isActive(std::string tag) const or DynamicAccumulatorChainArray::isActive(std::string tag) const instead.\n</span>
<a name="l02862"></a>02862 <span class="comment">See \ref FeatureAccumulators for more information about feature computation via accumulators.</span>
<a name="l02863"></a>02863 <span class="comment">*/</span>
<a name="l02864"></a>02864 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Tag, <span class="keyword">class</span> A&gt;
<a name="l02865"></a>02865 <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l02866"></a><a class="code" href="namespacevigra_1_1acc.html#a2f179339abc93d5b58a1f4bf530c80dd">02866</a> <a class="code" href="namespacevigra_1_1acc.html#a2f179339abc93d5b58a1f4bf530c80dd">isActive</a>(A <span class="keyword">const</span> &amp; a)
<a name="l02867"></a>02867 {
<a name="l02868"></a>02868     <span class="keywordflow">return</span> a.template isActive&lt;Tag&gt;();
<a name="l02869"></a>02869 }
<a name="l02870"></a>02870 
<a name="l02871"></a>02871 <span class="comment">/****************************************************************************/</span>
<a name="l02872"></a>02872 <span class="comment">/*                                                                          */</span>
<a name="l02873"></a>02873 <span class="comment">/*                               generic loops                              */</span>
<a name="l02874"></a>02874 <span class="comment">/*                                                                          */</span>
<a name="l02875"></a>02875 <span class="comment">/****************************************************************************/</span>
<a name="l02876"></a>02876 <span class="comment"></span>
<a name="l02877"></a>02877 <span class="comment">/** Generic loop to collect statistics from one or several arrays.</span>
<a name="l02878"></a>02878 <span class="comment"></span>
<a name="l02879"></a>02879 <span class="comment">This function automatically performs as many passes over the data as necessary for the selected statistics. The basic version of &lt;tt&gt;extractFeatures()&lt;/tt&gt; takes an iterator pair and a reference to an accumulator chain:</span>
<a name="l02880"></a>02880 <span class="comment">\code</span>
<a name="l02881"></a>02881 <span class="comment">namespace vigra { namespace acc {</span>
<a name="l02882"></a>02882 <span class="comment"></span>
<a name="l02883"></a>02883 <span class="comment">    template &lt;class ITERATOR, class ACCUMULATOR&gt;</span>
<a name="l02884"></a>02884 <span class="comment">    void extractFeatures(ITERATOR start, ITERATOR end, ACCUMULATOR &amp; a);</span>
<a name="l02885"></a>02885 <span class="comment">}}</span>
<a name="l02886"></a>02886 <span class="comment">\endcode</span>
<a name="l02887"></a>02887 <span class="comment">The &lt;tt&gt;ITERATOR&lt;/tt&gt; can be any STL-conforming &lt;i&gt;forward iterator&lt;/i&gt; (including raw pointers and \ref vigra::CoupledScanOrderIterator). The &lt;tt&gt;ACCUMULATOR&lt;/tt&gt; must be instantiated with the &lt;tt&gt;ITERATOR&lt;/tt&gt;&#39;s &lt;tt&gt;value_type&lt;/tt&gt; as its first template argument. For example, to use a raw pointer you write:</span>
<a name="l02888"></a>02888 <span class="comment">\code</span>
<a name="l02889"></a>02889 <span class="comment">    AccumulatorChain&lt;double, Select&lt;Mean, Variance&gt; &gt; a;</span>
<a name="l02890"></a>02890 <span class="comment"></span>
<a name="l02891"></a>02891 <span class="comment">    double * start = ...,</span>
<a name="l02892"></a>02892 <span class="comment">           * end   = ...;</span>
<a name="l02893"></a>02893 <span class="comment">    extractFeatures(start, end, a);</span>
<a name="l02894"></a>02894 <span class="comment">\endcode</span>
<a name="l02895"></a>02895 <span class="comment">Similarly, you can use MultiArray&#39;s scan-order iterator:</span>
<a name="l02896"></a>02896 <span class="comment">\code    </span>
<a name="l02897"></a>02897 <span class="comment">    AccumulatorChain&lt;TinyVector&lt;float, 2&gt;, Select&lt;Mean, Variance&gt; &gt; a;</span>
<a name="l02898"></a>02898 <span class="comment"></span>
<a name="l02899"></a>02899 <span class="comment">    MultiArray&lt;3, TinyVector&lt;float, 2&gt; &gt; data(...);</span>
<a name="l02900"></a>02900 <span class="comment">    extractFeatures(data.begin(), data.end(), a);</span>
<a name="l02901"></a>02901 <span class="comment">\endcode</span>
<a name="l02902"></a>02902 <span class="comment">An alternative syntax is used when you want to compute weighted or region statistics (or both). Then it is necessary to iterate over several arrays simultaneously. This fact is best conveyed to the accumulator via the helper class \ref vigra::CoupledArrays that is used as the accumulator&#39;s first template argument and holds the dimension and value types of the arrays involved. To actually compute the features, you then pass appropriate arrays to the &lt;tt&gt;extractfeatures()&lt;/tt&gt; function directly. For example, region statistics can be obtained like this:</span>
<a name="l02903"></a>02903 <span class="comment">\code</span>
<a name="l02904"></a>02904 <span class="comment">    MultiArray&lt;3, double&gt; data(...);</span>
<a name="l02905"></a>02905 <span class="comment">    MultiArray&lt;3, int&gt; labels(...);</span>
<a name="l02906"></a>02906 <span class="comment"></span>
<a name="l02907"></a>02907 <span class="comment">    AccumulatorChainArray&lt;CoupledArrays&lt;3, double, int&gt;,</span>
<a name="l02908"></a>02908 <span class="comment">                          Select&lt;DataArg&lt;1&gt;, LabelArg&lt;2&gt;, // where to look for data and region labels</span>
<a name="l02909"></a>02909 <span class="comment">                                 Mean, Variance&gt; &gt;        // what statistics to compute</span>
<a name="l02910"></a>02910 <span class="comment">        a;</span>
<a name="l02911"></a>02911 <span class="comment"></span>
<a name="l02912"></a>02912 <span class="comment">    extractFeatures(data, labels, a);</span>
<a name="l02913"></a>02913 <span class="comment">\endcode</span>
<a name="l02914"></a>02914 <span class="comment">This form of &lt;tt&gt;extractFeatures()&lt;/tt&gt; is supported for up to five arrays (although at most three are currently making sense in practice):</span>
<a name="l02915"></a>02915 <span class="comment">\code</span>
<a name="l02916"></a>02916 <span class="comment">namespace vigra { namespace acc {</span>
<a name="l02917"></a>02917 <span class="comment"></span>
<a name="l02918"></a>02918 <span class="comment">    template &lt;unsigned int N, class T1, class S1,</span>
<a name="l02919"></a>02919 <span class="comment">              class ACCUMULATOR&gt;</span>
<a name="l02920"></a>02920 <span class="comment">    void extractFeatures(MultiArrayView&lt;N, T1, S1&gt; const &amp; a1, </span>
<a name="l02921"></a>02921 <span class="comment">                         ACCUMULATOR &amp; a);</span>
<a name="l02922"></a>02922 <span class="comment">                         </span>
<a name="l02923"></a>02923 <span class="comment">    ...</span>
<a name="l02924"></a>02924 <span class="comment"></span>
<a name="l02925"></a>02925 <span class="comment">    template &lt;unsigned int N, class T1, class S1,</span>
<a name="l02926"></a>02926 <span class="comment">                              class T2, class S2,</span>
<a name="l02927"></a>02927 <span class="comment">                              class T3, class S3,</span>
<a name="l02928"></a>02928 <span class="comment">                              class T4, class S4,</span>
<a name="l02929"></a>02929 <span class="comment">                              class T5, class S5,</span>
<a name="l02930"></a>02930 <span class="comment">              class ACCUMULATOR&gt;</span>
<a name="l02931"></a>02931 <span class="comment">    void extractFeatures(MultiArrayView&lt;N, T1, S1&gt; const &amp; a1, </span>
<a name="l02932"></a>02932 <span class="comment">                         MultiArrayView&lt;N, T2, S2&gt; const &amp; a2, </span>
<a name="l02933"></a>02933 <span class="comment">                         MultiArrayView&lt;N, T3, S3&gt; const &amp; a3, </span>
<a name="l02934"></a>02934 <span class="comment">                         MultiArrayView&lt;N, T4, S4&gt; const &amp; a4, </span>
<a name="l02935"></a>02935 <span class="comment">                         MultiArrayView&lt;N, T5, S5&gt; const &amp; a5, </span>
<a name="l02936"></a>02936 <span class="comment">                         ACCUMULATOR &amp; a);</span>
<a name="l02937"></a>02937 <span class="comment">}}</span>
<a name="l02938"></a>02938 <span class="comment">\endcode</span>
<a name="l02939"></a>02939 <span class="comment">Of course, the number and types of the arrays specified in &lt;tt&gt;CoupledArrays&lt;/tt&gt; must conform to the number and types of the arrays passed to &lt;tt&gt;extractFeatures()&lt;/tt&gt;.</span>
<a name="l02940"></a>02940 <span class="comment"></span>
<a name="l02941"></a>02941 <span class="comment">See \ref FeatureAccumulators for more information about feature computation via accumulators.</span>
<a name="l02942"></a>02942 <span class="comment">*/</span>
<a name="l02943"></a>02943 doxygen_overloaded_function(template &lt;...&gt; <span class="keywordtype">void</span> <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>)
<a name="l02944"></a>02944 
<a name="l02945"></a>02945 
<a name="l02946"></a>02946 <span class="keyword">template</span> &lt;<span class="keyword">class</span> ITERATOR, <span class="keyword">class</span> ACCUMULATOR&gt;
<a name="l02947"></a>02947 <span class="keywordtype">void</span> <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(ITERATOR start, ITERATOR end, ACCUMULATOR &amp; a)
<a name="l02948"></a>02948 {
<a name="l02949"></a>02949     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=1; k &lt;= a.passesRequired(); ++k)
<a name="l02950"></a>02950         <span class="keywordflow">for</span>(ITERATOR i=start; i &lt; end; ++i)
<a name="l02951"></a>02951             a.updatePassN(*i, k);
<a name="l02952"></a>02952 }
<a name="l02953"></a>02953 
<a name="l02954"></a>02954 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,
<a name="l02955"></a>02955           <span class="keyword">class </span>ACCUMULATOR&gt;
<a name="l02956"></a>02956 <span class="keywordtype">void</span> <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; a1, 
<a name="l02957"></a>02957                      ACCUMULATOR &amp; a)
<a name="l02958"></a>02958 {
<a name="l02959"></a>02959     <span class="keyword">typedef</span> <span class="keyword">typename</span> CoupledIteratorType&lt;N, T1&gt;::type Iterator;
<a name="l02960"></a>02960     Iterator start = <a class="code" href="group__MultiIteratorGroup.html#gaa4bf73ceca2081acb1353b88ced1388e">createCoupledIterator</a>(a1),
<a name="l02961"></a>02961              end   = start.getEndIterator();
<a name="l02962"></a>02962     <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(start, end, a);
<a name="l02963"></a>02963 }
<a name="l02964"></a>02964 
<a name="l02965"></a>02965 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,
<a name="l02966"></a>02966                           <span class="keyword">class </span>T2, <span class="keyword">class </span>S2,
<a name="l02967"></a>02967           <span class="keyword">class </span>ACCUMULATOR&gt;
<a name="l02968"></a>02968 <span class="keywordtype">void</span> <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; a1, 
<a name="l02969"></a>02969                      MultiArrayView&lt;N, T2, S2&gt; <span class="keyword">const</span> &amp; a2, 
<a name="l02970"></a>02970                      ACCUMULATOR &amp; a)
<a name="l02971"></a>02971 {
<a name="l02972"></a>02972     <span class="keyword">typedef</span> <span class="keyword">typename</span> CoupledIteratorType&lt;N, T1, T2&gt;::type Iterator;
<a name="l02973"></a>02973     Iterator start = <a class="code" href="group__MultiIteratorGroup.html#gaa4bf73ceca2081acb1353b88ced1388e">createCoupledIterator</a>(a1, a2),
<a name="l02974"></a>02974              end   = start.getEndIterator();
<a name="l02975"></a>02975     <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(start, end, a);
<a name="l02976"></a>02976 }
<a name="l02977"></a>02977 
<a name="l02978"></a>02978 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,
<a name="l02979"></a>02979                           <span class="keyword">class </span>T2, <span class="keyword">class </span>S2,
<a name="l02980"></a>02980                           <span class="keyword">class </span>T3, <span class="keyword">class </span>S3,
<a name="l02981"></a>02981           <span class="keyword">class </span>ACCUMULATOR&gt;
<a name="l02982"></a>02982 <span class="keywordtype">void</span> <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; a1, 
<a name="l02983"></a>02983                      MultiArrayView&lt;N, T2, S2&gt; <span class="keyword">const</span> &amp; a2, 
<a name="l02984"></a>02984                      MultiArrayView&lt;N, T3, S3&gt; <span class="keyword">const</span> &amp; a3, 
<a name="l02985"></a>02985                      ACCUMULATOR &amp; a)
<a name="l02986"></a>02986 {
<a name="l02987"></a>02987     <span class="keyword">typedef</span> <span class="keyword">typename</span> CoupledIteratorType&lt;N, T1, T2, T3&gt;::type Iterator;
<a name="l02988"></a>02988     Iterator start = <a class="code" href="group__MultiIteratorGroup.html#gaa4bf73ceca2081acb1353b88ced1388e">createCoupledIterator</a>(a1, a2, a3),
<a name="l02989"></a>02989              end   = start.getEndIterator();
<a name="l02990"></a>02990     <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(start, end, a);
<a name="l02991"></a>02991 }
<a name="l02992"></a>02992 
<a name="l02993"></a>02993 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,
<a name="l02994"></a>02994                           <span class="keyword">class </span>T2, <span class="keyword">class </span>S2,
<a name="l02995"></a>02995                           <span class="keyword">class </span>T3, <span class="keyword">class </span>S3,
<a name="l02996"></a>02996                           <span class="keyword">class </span>T4, <span class="keyword">class </span>S4,
<a name="l02997"></a>02997           <span class="keyword">class </span>ACCUMULATOR&gt;
<a name="l02998"></a>02998 <span class="keywordtype">void</span> <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; a1, 
<a name="l02999"></a>02999                      MultiArrayView&lt;N, T2, S2&gt; <span class="keyword">const</span> &amp; a2, 
<a name="l03000"></a>03000                      MultiArrayView&lt;N, T3, S3&gt; <span class="keyword">const</span> &amp; a3, 
<a name="l03001"></a>03001                      MultiArrayView&lt;N, T4, S4&gt; <span class="keyword">const</span> &amp; a4, 
<a name="l03002"></a>03002                      ACCUMULATOR &amp; a)
<a name="l03003"></a>03003 {
<a name="l03004"></a>03004     <span class="keyword">typedef</span> <span class="keyword">typename</span> CoupledIteratorType&lt;N, T1, T2, T3, T4&gt;::type Iterator;
<a name="l03005"></a>03005     Iterator start = <a class="code" href="group__MultiIteratorGroup.html#gaa4bf73ceca2081acb1353b88ced1388e">createCoupledIterator</a>(a1, a2, a3, a4),
<a name="l03006"></a>03006              end   = start.getEndIterator();
<a name="l03007"></a>03007     <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(start, end, a);
<a name="l03008"></a>03008 }
<a name="l03009"></a>03009 
<a name="l03010"></a>03010 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,
<a name="l03011"></a>03011                           <span class="keyword">class </span>T2, <span class="keyword">class </span>S2,
<a name="l03012"></a>03012                           <span class="keyword">class </span>T3, <span class="keyword">class </span>S3,
<a name="l03013"></a>03013                           <span class="keyword">class </span>T4, <span class="keyword">class </span>S4,
<a name="l03014"></a>03014                           <span class="keyword">class </span>T5, <span class="keyword">class </span>S5,
<a name="l03015"></a>03015           <span class="keyword">class </span>ACCUMULATOR&gt;
<a name="l03016"></a>03016 <span class="keywordtype">void</span> <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; a1, 
<a name="l03017"></a>03017                      MultiArrayView&lt;N, T2, S2&gt; <span class="keyword">const</span> &amp; a2, 
<a name="l03018"></a>03018                      MultiArrayView&lt;N, T3, S3&gt; <span class="keyword">const</span> &amp; a3, 
<a name="l03019"></a>03019                      MultiArrayView&lt;N, T4, S4&gt; <span class="keyword">const</span> &amp; a4, 
<a name="l03020"></a>03020                      MultiArrayView&lt;N, T5, S5&gt; <span class="keyword">const</span> &amp; a5, 
<a name="l03021"></a>03021                      ACCUMULATOR &amp; a)
<a name="l03022"></a>03022 {
<a name="l03023"></a>03023     <span class="keyword">typedef</span> <span class="keyword">typename</span> CoupledIteratorType&lt;N, T1, T2, T3, T4, T5&gt;::type Iterator;
<a name="l03024"></a>03024     Iterator start = <a class="code" href="group__MultiIteratorGroup.html#gaa4bf73ceca2081acb1353b88ced1388e">createCoupledIterator</a>(a1, a2, a3, a4, a5),
<a name="l03025"></a>03025              end   = start.getEndIterator();
<a name="l03026"></a>03026     <a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(start, end, a);
<a name="l03027"></a>03027 }
<a name="l03028"></a>03028 
<a name="l03029"></a>03029 <span class="comment">/****************************************************************************/</span>
<a name="l03030"></a>03030 <span class="comment">/*                                                                          */</span>
<a name="l03031"></a>03031 <span class="comment">/*                          AccumulatorResultTraits                         */</span>
<a name="l03032"></a>03032 <span class="comment">/*                                                                          */</span>
<a name="l03033"></a>03033 <span class="comment">/****************************************************************************/</span>
<a name="l03034"></a>03034 
<a name="l03035"></a>03035 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l03036"></a>03036 <span class="keyword">struct </span>AccumulatorResultTraits
<a name="l03037"></a>03037 {
<a name="l03038"></a>03038     <span class="keyword">typedef</span> T                                       type;
<a name="l03039"></a>03039     <span class="keyword">typedef</span> T                                       element_type;
<a name="l03040"></a>03040     <span class="keyword">typedef</span> <span class="keywordtype">double</span>                                  element_promote_type;
<a name="l03041"></a>03041     <span class="keyword">typedef</span> T                                       MinmaxType;
<a name="l03042"></a>03042     <span class="keyword">typedef</span> element_promote_type                    SumType;
<a name="l03043"></a>03043     <span class="keyword">typedef</span> element_promote_type                    FlatCovarianceType;
<a name="l03044"></a>03044     <span class="keyword">typedef</span> element_promote_type                    CovarianceType;
<a name="l03045"></a>03045 };
<a name="l03046"></a>03046 
<a name="l03047"></a>03047 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">int</span> N&gt;
<a name="l03048"></a>03048 <span class="keyword">struct </span>AccumulatorResultTraits&lt;TinyVector&lt;T, N&gt; &gt;
<a name="l03049"></a>03049 {
<a name="l03050"></a>03050     <span class="keyword">typedef</span> TinyVector&lt;T, N&gt;                             type;
<a name="l03051"></a>03051     <span class="keyword">typedef</span> T                                            element_type;
<a name="l03052"></a>03052     <span class="keyword">typedef</span> <span class="keywordtype">double</span>                                       element_promote_type;
<a name="l03053"></a>03053     <span class="keyword">typedef</span> TinyVector&lt;T, N&gt;                             MinmaxType;
<a name="l03054"></a>03054     <span class="keyword">typedef</span> TinyVector&lt;element_promote_type, N&gt;          SumType;
<a name="l03055"></a>03055     <span class="keyword">typedef</span> TinyVector&lt;element_promote_type, N*(N+1)/2&gt;  FlatCovarianceType;
<a name="l03056"></a>03056     <span class="keyword">typedef</span> Matrix&lt;element_promote_type&gt;                 CovarianceType;
<a name="l03057"></a>03057 };
<a name="l03058"></a>03058 
<a name="l03059"></a>03059 <span class="comment">// (?) beign change</span>
<a name="l03060"></a>03060 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> RED_IDX, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> GREEN_IDX, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> BLUE_IDX&gt;
<a name="l03061"></a>03061 <span class="keyword">struct </span>AccumulatorResultTraits&lt;RGBValue&lt;T, RED_IDX, GREEN_IDX, BLUE_IDX&gt; &gt;
<a name="l03062"></a>03062 {
<a name="l03063"></a>03063     <span class="keyword">typedef</span> RGBValue&lt;T&gt;                                  type;
<a name="l03064"></a>03064     <span class="keyword">typedef</span> T                                            element_type;
<a name="l03065"></a>03065     <span class="keyword">typedef</span> <span class="keywordtype">double</span>                                       element_promote_type;
<a name="l03066"></a>03066     <span class="keyword">typedef</span> RGBValue&lt;T&gt;                                  MinmaxType;
<a name="l03067"></a>03067     <span class="keyword">typedef</span> RGBValue&lt;element_promote_type&gt;               SumType;
<a name="l03068"></a>03068     <span class="keyword">typedef</span> TinyVector&lt;element_promote_type, 3*(3+1)/2&gt;  FlatCovarianceType;
<a name="l03069"></a>03069     <span class="keyword">typedef</span> Matrix&lt;element_promote_type&gt;                 CovarianceType;
<a name="l03070"></a>03070 };
<a name="l03071"></a>03071 <span class="comment">// end change</span>
<a name="l03072"></a>03072 
<a name="l03073"></a>03073 
<a name="l03074"></a>03074 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> T, <span class="keyword">class</span> Str<span class="keywordtype">id</span>e&gt;
<a name="l03075"></a>03075 <span class="keyword">struct </span>AccumulatorResultTraits&lt;MultiArrayView&lt;N, T, Stride&gt; &gt;
<a name="l03076"></a>03076 {
<a name="l03077"></a>03077     <span class="keyword">typedef</span> MultiArrayView&lt;N, T, Stride&gt;            type;
<a name="l03078"></a>03078     <span class="keyword">typedef</span> T                                       element_type;
<a name="l03079"></a>03079     <span class="keyword">typedef</span> <span class="keywordtype">double</span>                                  element_promote_type;
<a name="l03080"></a>03080     <span class="keyword">typedef</span> MultiArray&lt;N, T&gt;                        MinmaxType;
<a name="l03081"></a>03081     <span class="keyword">typedef</span> MultiArray&lt;N, element_promote_type&gt;     SumType;
<a name="l03082"></a>03082     <span class="keyword">typedef</span> MultiArray&lt;1, element_promote_type&gt;     FlatCovarianceType;
<a name="l03083"></a>03083     <span class="keyword">typedef</span> Matrix&lt;element_promote_type&gt;            CovarianceType;
<a name="l03084"></a>03084 };
<a name="l03085"></a>03085 
<a name="l03086"></a>03086 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;
<a name="l03087"></a>03087 <span class="keyword">struct </span>AccumulatorResultTraits&lt;MultiArray&lt;N, T, Alloc&gt; &gt;
<a name="l03088"></a>03088 {
<a name="l03089"></a>03089     <span class="keyword">typedef</span> MultiArrayView&lt;N, T, Alloc&gt;             type;
<a name="l03090"></a>03090     <span class="keyword">typedef</span> T                                       element_type;
<a name="l03091"></a>03091     <span class="keyword">typedef</span> <span class="keywordtype">double</span>                                  element_promote_type;
<a name="l03092"></a>03092     <span class="keyword">typedef</span> MultiArray&lt;N, T&gt;                        MinmaxType;
<a name="l03093"></a>03093     <span class="keyword">typedef</span> MultiArray&lt;N, element_promote_type&gt;     SumType;
<a name="l03094"></a>03094     <span class="keyword">typedef</span> MultiArray&lt;1, element_promote_type&gt;     FlatCovarianceType;
<a name="l03095"></a>03095     <span class="keyword">typedef</span> Matrix&lt;element_promote_type&gt;            CovarianceType;
<a name="l03096"></a>03096 };
<a name="l03097"></a>03097 
<a name="l03098"></a>03098 <span class="comment">/****************************************************************************/</span>
<a name="l03099"></a>03099 <span class="comment">/*                                                                          */</span>
<a name="l03100"></a>03100 <span class="comment">/*                           modifier implementations                       */</span>
<a name="l03101"></a>03101 <span class="comment">/*                                                                          */</span>
<a name="l03102"></a>03102 <span class="comment">/****************************************************************************/</span>
<a name="l03103"></a>03103 <span class="comment"></span>
<a name="l03104"></a>03104 <span class="comment">/** \brief Modifier. Compute statistic globally rather than per region. </span>
<a name="l03105"></a>03105 <span class="comment"></span>
<a name="l03106"></a>03106 <span class="comment">This modifier only works when labels are given (with (Dynamic)AccumulatorChainArray), in which case statistics are computed per-region by default.</span>
<a name="l03107"></a>03107 <span class="comment">*/</span>
<a name="l03108"></a>03108 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG&gt;
<a name="l03109"></a><a class="code" href="classvigra_1_1acc_1_1Global.html">03109</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1Global.html" title="Modifier. Compute statistic globally rather than per region.">Global</a>
<a name="l03110"></a>03110 {
<a name="l03111"></a>03111   <span class="keyword">public</span>:
<a name="l03112"></a>03112     <span class="keyword">typedef</span> <span class="keyword">typename</span> StandardizeTag&lt;TAG&gt;::type  TargetTag;
<a name="l03113"></a>03113     <span class="keyword">typedef</span> <span class="keyword">typename</span> TargetTag::Dependencies    Dependencies;
<a name="l03114"></a>03114     
<a name="l03115"></a>03115     <span class="keyword">static</span> std::string name() 
<a name="l03116"></a>03116     { 
<a name="l03117"></a>03117         <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;Global&lt;&quot;</span>) + TargetTag::name() + <span class="stringliteral">&quot; &gt;&quot;</span>;
<a name="l03118"></a>03118         <span class="comment">// static const std::string n = std::string(&quot;Global&lt;&quot;) + TargetTag::name() + &quot; &gt;&quot;;</span>
<a name="l03119"></a>03119         <span class="comment">// return n;</span>
<a name="l03120"></a>03120     }
<a name="l03121"></a>03121 };
<a name="l03122"></a>03122 <span class="comment"></span>
<a name="l03123"></a>03123 <span class="comment">/** \brief Specifies index of data in CoupledHandle. </span>
<a name="l03124"></a>03124 <span class="comment"></span>
<a name="l03125"></a>03125 <span class="comment">    If AccumulatorChain is used with CoupledIterator, DataArg&lt;INDEX&gt; tells the accumulator chain which index of the Handle contains the data. (Coordinates are always index 0)</span>
<a name="l03126"></a>03126 <span class="comment">*/</span>
<a name="l03127"></a>03127 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> INDEX&gt;
<a name="l03128"></a><a class="code" href="classvigra_1_1acc_1_1DataArg.html">03128</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1DataArg.html" title="Specifies index of data in CoupledHandle.">DataArg</a>
<a name="l03129"></a>03129 {
<a name="l03130"></a>03130   <span class="keyword">public</span>:
<a name="l03131"></a>03131     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l03132"></a>03132     
<a name="l03133"></a>03133     <span class="keyword">static</span> std::string name() 
<a name="l03134"></a>03134     { 
<a name="l03135"></a>03135         <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;DataArg&lt;&quot;</span>) + <a class="code" href="namespacevigra.html#abefdd44c2db13a2b64f36c82d3647b82">asString</a>(INDEX) + <span class="stringliteral">&quot;&gt; (internal)&quot;</span>;
<a name="l03136"></a>03136         <span class="comment">// static const std::string n = std::string(&quot;DataArg&lt;&quot;) + asString(INDEX) + &quot;&gt; (internal)&quot;;</span>
<a name="l03137"></a>03137         <span class="comment">// return n;</span>
<a name="l03138"></a>03138     }
<a name="l03139"></a>03139     
<a name="l03140"></a>03140     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> BASE&gt;
<a name="l03141"></a>03141     <span class="keyword">struct </span>Impl
<a name="l03142"></a>03142     : <span class="keyword">public</span> BASE
<a name="l03143"></a>03143     {
<a name="l03144"></a>03144         <span class="keyword">typedef</span> DataArgTag Tag;
<a name="l03145"></a>03145         <span class="keyword">typedef</span> <span class="keywordtype">void</span> value_type;
<a name="l03146"></a>03146         <span class="keyword">typedef</span> <span class="keywordtype">void</span> result_type;
<a name="l03147"></a>03147 
<a name="l03148"></a>03148         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> value = INDEX;
<a name="l03149"></a>03149         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> workInPass = 0;
<a name="l03150"></a>03150     };
<a name="l03151"></a>03151 };
<a name="l03152"></a>03152 
<a name="l03153"></a>03153 <span class="comment">// Tags are automatically wrapped with DataFromHandle if CoupledHandle used</span>
<a name="l03154"></a>03154 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG&gt;
<a name="l03155"></a>03155 <span class="keyword">class </span>DataFromHandle
<a name="l03156"></a>03156 {
<a name="l03157"></a>03157   <span class="keyword">public</span>:
<a name="l03158"></a>03158     <span class="keyword">typedef</span> <span class="keyword">typename</span> StandardizeTag&lt;TAG&gt;::type TargetTag;
<a name="l03159"></a>03159     <span class="keyword">typedef</span> <span class="keyword">typename</span> TargetTag::Dependencies Dependencies;
<a name="l03160"></a>03160     
<a name="l03161"></a>03161     <span class="keyword">static</span> std::string name() 
<a name="l03162"></a>03162     { 
<a name="l03163"></a>03163         <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;DataFromHandle&lt;&quot;</span>) + TargetTag::name() + <span class="stringliteral">&quot; &gt; (internal)&quot;</span>;
<a name="l03164"></a>03164         <span class="comment">// static const std::string n = std::string(&quot;DataFromHandle&lt;&quot;) + TargetTag::name() + &quot; &gt; (internal)&quot;;</span>
<a name="l03165"></a>03165         <span class="comment">// return n;</span>
<a name="l03166"></a>03166     }
<a name="l03167"></a>03167     
<a name="l03168"></a>03168     <span class="keyword">template</span> &lt;<span class="keyword">class</span> IndexDefinition, <span class="keyword">class</span> TagFound=<span class="keyword">typename</span> IndexDefinition::Tag&gt;
<a name="l03169"></a>03169     <span class="keyword">struct </span>DataIndexSelector
<a name="l03170"></a>03170     {
<a name="l03171"></a>03171         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> value = 1; <span class="comment">// default: CoupledHandle holds data at index 1 </span>
<a name="l03172"></a>03172         
<a name="l03173"></a>03173         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> NEXT&gt;
<a name="l03174"></a>03174         <span class="keyword">static</span> <span class="keyword">typename</span> CoupledHandleCast&lt;value, CoupledHandle&lt;U, NEXT&gt; &gt;::type::const_reference 
<a name="l03175"></a>03175         exec(<a class="code" href="classvigra_1_1CoupledHandle.html">CoupledHandle&lt;U, NEXT&gt;</a> <span class="keyword">const</span> &amp; t)
<a name="l03176"></a>03176         {
<a name="l03177"></a>03177             <span class="keywordflow">return</span> vigra::get&lt;value&gt;(t);
<a name="l03178"></a>03178         }
<a name="l03179"></a>03179     };
<a name="l03180"></a>03180     
<a name="l03181"></a>03181     <span class="keyword">template</span> &lt;<span class="keyword">class</span> IndexDefinition&gt;
<a name="l03182"></a>03182     <span class="keyword">struct </span>DataIndexSelector&lt;IndexDefinition, DataArgTag&gt;
<a name="l03183"></a>03183     {
<a name="l03184"></a>03184         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> value = IndexDefinition::value;
<a name="l03185"></a>03185         
<a name="l03186"></a>03186         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> NEXT&gt;
<a name="l03187"></a>03187         <span class="keyword">static</span> <span class="keyword">typename</span> CoupledHandleCast&lt;value, CoupledHandle&lt;U, NEXT&gt; &gt;::type::const_reference
<a name="l03188"></a>03188         exec(CoupledHandle&lt;U, NEXT&gt; <span class="keyword">const</span> &amp; t)
<a name="l03189"></a>03189         {
<a name="l03190"></a>03190             <span class="keywordflow">return</span> vigra::get&lt;value&gt;(t);
<a name="l03191"></a>03191         }
<a name="l03192"></a>03192     };
<a name="l03193"></a>03193     
<a name="l03194"></a>03194     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> BASE&gt;
<a name="l03195"></a>03195     <span class="keyword">struct </span>SelectInputType
<a name="l03196"></a>03196     {
<a name="l03197"></a>03197         <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupTag&lt;DataArgTag, BASE&gt;::type FindDataIndex;
<a name="l03198"></a>03198         <span class="keyword">typedef</span> DataIndexSelector&lt;FindDataIndex&gt; DataIndex;
<a name="l03199"></a>03199         <span class="keyword">typedef</span> <span class="keyword">typename</span> CoupledHandleCast&lt;DataIndex::value, T&gt;::type::value_type type;
<a name="l03200"></a>03200     };
<a name="l03201"></a>03201     
<a name="l03202"></a>03202     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> BASE&gt;
<a name="l03203"></a>03203     <span class="keyword">struct </span>Impl
<a name="l03204"></a>03204     : <span class="keyword">public</span> TargetTag::template Impl&lt;typename SelectInputType&lt;T, BASE&gt;::type, BASE&gt;
<a name="l03205"></a>03205     {
<a name="l03206"></a>03206         <span class="keyword">typedef</span> SelectInputType&lt;T, BASE&gt;                InputTypeSelector;
<a name="l03207"></a>03207         <span class="keyword">typedef</span> <span class="keyword">typename</span> InputTypeSelector::DataIndex   DataIndex;
<a name="l03208"></a>03208         <span class="keyword">typedef</span> <span class="keyword">typename</span> InputTypeSelector::type        input_type;
<a name="l03209"></a>03209         <span class="keyword">typedef</span> input_type <span class="keyword">const</span> &amp;                      argument_type;
<a name="l03210"></a>03210         <span class="keyword">typedef</span> argument_type                           first_argument_type;
<a name="l03211"></a>03211         
<a name="l03212"></a>03212         <span class="keyword">typedef</span> <span class="keyword">typename</span> TargetTag::template Impl&lt;input_type, BASE&gt; ImplType;
<a name="l03213"></a>03213         
<a name="l03214"></a>03214         <span class="keyword">using</span> ImplType::reshape;
<a name="l03215"></a>03215         
<a name="l03216"></a>03216         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> NEXT&gt;
<a name="l03217"></a>03217         <span class="keywordtype">void</span> reshape(CoupledHandle&lt;U, NEXT&gt; <span class="keyword">const</span> &amp; t)
<a name="l03218"></a>03218         {
<a name="l03219"></a>03219             ImplType::reshape(acc_detail::shapeOf(DataIndex::exec(t)));
<a name="l03220"></a>03220         }
<a name="l03221"></a>03221         
<a name="l03222"></a>03222         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> NEXT&gt;
<a name="l03223"></a>03223         <span class="keywordtype">void</span> update(CoupledHandle&lt;U, NEXT&gt; <span class="keyword">const</span> &amp; t)
<a name="l03224"></a>03224         {
<a name="l03225"></a>03225             ImplType::update(DataIndex::exec(t));
<a name="l03226"></a>03226         }
<a name="l03227"></a>03227         
<a name="l03228"></a>03228         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> NEXT&gt;
<a name="l03229"></a>03229         <span class="keywordtype">void</span> update(CoupledHandle&lt;U, NEXT&gt; <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l03230"></a>03230         {
<a name="l03231"></a>03231             ImplType::update(DataIndex::exec(t), weight);
<a name="l03232"></a>03232         }
<a name="l03233"></a>03233     };
<a name="l03234"></a>03234 };
<a name="l03235"></a>03235 <span class="comment"></span>
<a name="l03236"></a>03236 <span class="comment">/** \brief Modifier. Compute statistic from pixel coordinates rather than from pixel values. </span>
<a name="l03237"></a>03237 <span class="comment"></span>
<a name="l03238"></a>03238 <span class="comment">    AccumulatorChain must be used with CoupledIterator in order to have access to pixel coordinates.</span>
<a name="l03239"></a>03239 <span class="comment"> */</span>
<a name="l03240"></a>03240 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG&gt;
<a name="l03241"></a><a class="code" href="classvigra_1_1acc_1_1Coord.html">03241</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1Coord.html" title="Modifier. Compute statistic from pixel coordinates rather than from pixel values.">Coord</a>
<a name="l03242"></a>03242 {
<a name="l03243"></a>03243   <span class="keyword">public</span>:
<a name="l03244"></a>03244     <span class="keyword">typedef</span> <span class="keyword">typename</span> StandardizeTag&lt;TAG&gt;::type   TargetTag;
<a name="l03245"></a>03245     <span class="keyword">typedef</span> <span class="keyword">typename</span> TargetTag::Dependencies     Dependencies;
<a name="l03246"></a>03246     
<a name="l03247"></a>03247     <span class="keyword">static</span> std::string name() 
<a name="l03248"></a>03248     { 
<a name="l03249"></a>03249         <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;Coord&lt;&quot;</span>) + TargetTag::name() + <span class="stringliteral">&quot; &gt;&quot;</span>;
<a name="l03250"></a>03250         <span class="comment">// static const std::string n = std::string(&quot;Coord&lt;&quot;) + TargetTag::name() + &quot; &gt;&quot;;</span>
<a name="l03251"></a>03251         <span class="comment">// return n;</span>
<a name="l03252"></a>03252     }
<a name="l03253"></a>03253     
<a name="l03254"></a>03254     <span class="keyword">template</span> &lt;<span class="keyword">class</span> IndexDefinition, <span class="keyword">class</span> TagFound=<span class="keyword">typename</span> IndexDefinition::Tag&gt;
<a name="l03255"></a>03255     <span class="keyword">struct </span>CoordIndexSelector
<a name="l03256"></a>03256     {
<a name="l03257"></a>03257         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> value = 0; <span class="comment">// default: CoupledHandle holds coordinates at index 0 </span>
<a name="l03258"></a>03258         
<a name="l03259"></a>03259         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> NEXT&gt;
<a name="l03260"></a>03260         <span class="keyword">static</span> <span class="keyword">typename</span> CoupledHandleCast&lt;value, CoupledHandle&lt;U, NEXT&gt; &gt;::type::const_reference 
<a name="l03261"></a>03261         exec(<a class="code" href="classvigra_1_1CoupledHandle.html">CoupledHandle&lt;U, NEXT&gt;</a> <span class="keyword">const</span> &amp; t)
<a name="l03262"></a>03262         {
<a name="l03263"></a>03263             <span class="keywordflow">return</span> vigra::get&lt;value&gt;(t);
<a name="l03264"></a>03264         }
<a name="l03265"></a>03265     };
<a name="l03266"></a>03266     
<a name="l03267"></a>03267     <span class="keyword">template</span> &lt;<span class="keyword">class</span> IndexDefinition&gt;
<a name="l03268"></a>03268     <span class="keyword">struct </span>CoordIndexSelector&lt;IndexDefinition, CoordArgTag&gt;
<a name="l03269"></a>03269     {
<a name="l03270"></a>03270         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> value = IndexDefinition::value;
<a name="l03271"></a>03271         
<a name="l03272"></a>03272         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> NEXT&gt;
<a name="l03273"></a>03273         <span class="keyword">static</span> <span class="keyword">typename</span> CoupledHandleCast&lt;value, CoupledHandle&lt;U, NEXT&gt; &gt;::type::const_reference
<a name="l03274"></a>03274         exec(<a class="code" href="classvigra_1_1CoupledHandle.html">CoupledHandle&lt;U, NEXT&gt;</a> <span class="keyword">const</span> &amp; t)
<a name="l03275"></a>03275         {
<a name="l03276"></a>03276             <span class="keywordflow">return</span> vigra::get&lt;value&gt;(t);
<a name="l03277"></a>03277         }
<a name="l03278"></a>03278     };
<a name="l03279"></a>03279      
<a name="l03280"></a>03280     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> BASE&gt;
<a name="l03281"></a>03281     <span class="keyword">struct </span>SelectInputType
<a name="l03282"></a>03282     {
<a name="l03283"></a>03283         <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupTag&lt;CoordArgTag, BASE&gt;::type FindDataIndex;
<a name="l03284"></a>03284         <span class="keyword">typedef</span> CoordIndexSelector&lt;FindDataIndex&gt; CoordIndex;
<a name="l03285"></a>03285         <span class="keyword">typedef</span> <span class="keyword">typename</span> CoupledHandleCast&lt;CoordIndex::value, T&gt;::type::value_type type;
<a name="l03286"></a>03286         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> size = type::static_size;
<a name="l03287"></a>03287     };
<a name="l03288"></a>03288     
<a name="l03289"></a>03289     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> BASE&gt;
<a name="l03290"></a>03290     <span class="keyword">struct </span>Impl
<a name="l03291"></a>03291     : <span class="keyword">public</span> TargetTag::template Impl&lt;TinyVector&lt;double, SelectInputType&lt;T, BASE&gt;::size&gt;, BASE&gt;
<a name="l03292"></a>03292     {
<a name="l03293"></a>03293         <span class="keyword">typedef</span> SelectInputType&lt;T, BASE&gt;                              InputTypeSelector;
<a name="l03294"></a>03294         <span class="keyword">typedef</span> <span class="keyword">typename</span> InputTypeSelector::CoordIndex                CoordIndex;
<a name="l03295"></a>03295         <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1TinyVector.html" title="Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE...">TinyVector&lt;double, SelectInputType&lt;T, BASE&gt;::size</a>&gt;    input_type;
<a name="l03296"></a>03296         <span class="keyword">typedef</span> input_type <span class="keyword">const</span> &amp;                                    argument_type;
<a name="l03297"></a>03297         <span class="keyword">typedef</span> argument_type                                         first_argument_type;
<a name="l03298"></a>03298         
<a name="l03299"></a>03299         <span class="keyword">typedef</span> <span class="keyword">typename</span> TargetTag::template Impl&lt;input_type, BASE&gt; ImplType;
<a name="l03300"></a>03300         
<a name="l03301"></a>03301         input_type offset_;
<a name="l03302"></a>03302         
<a name="l03303"></a>03303         Impl()
<a name="l03304"></a>03304         : offset_()
<a name="l03305"></a>03305         {}
<a name="l03306"></a>03306         
<a name="l03307"></a>03307         <span class="keywordtype">void</span> setCoordinateOffset(input_type <span class="keyword">const</span> &amp; offset)
<a name="l03308"></a>03308         {
<a name="l03309"></a>03309             offset_ = offset;
<a name="l03310"></a>03310         }
<a name="l03311"></a>03311         
<a name="l03312"></a>03312         <span class="keyword">using</span> ImplType::reshape;
<a name="l03313"></a>03313         
<a name="l03314"></a>03314         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> NEXT&gt;
<a name="l03315"></a>03315         <span class="keywordtype">void</span> reshape(<a class="code" href="classvigra_1_1CoupledHandle.html">CoupledHandle&lt;U, NEXT&gt;</a> <span class="keyword">const</span> &amp; t)
<a name="l03316"></a>03316         {
<a name="l03317"></a>03317             ImplType::reshape(acc_detail::shapeOf(CoordIndex::exec(t)));
<a name="l03318"></a>03318         }
<a name="l03319"></a>03319         
<a name="l03320"></a>03320         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> NEXT&gt;
<a name="l03321"></a>03321         <span class="keywordtype">void</span> update(<a class="code" href="classvigra_1_1CoupledHandle.html">CoupledHandle&lt;U, NEXT&gt;</a> <span class="keyword">const</span> &amp; t)
<a name="l03322"></a>03322         {
<a name="l03323"></a>03323             ImplType::update(CoordIndex::exec(t)+offset_);
<a name="l03324"></a>03324         }
<a name="l03325"></a>03325         
<a name="l03326"></a>03326         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> NEXT&gt;
<a name="l03327"></a>03327         <span class="keywordtype">void</span> update(<a class="code" href="classvigra_1_1CoupledHandle.html">CoupledHandle&lt;U, NEXT&gt;</a> <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l03328"></a>03328         {
<a name="l03329"></a>03329             ImplType::update(CoordIndex::exec(t)+offset_, weight);
<a name="l03330"></a>03330         }
<a name="l03331"></a>03331     };
<a name="l03332"></a>03332 };
<a name="l03333"></a>03333 <span class="comment"></span>
<a name="l03334"></a>03334 <span class="comment">/** \brief Specifies index of data in CoupledHandle. </span>
<a name="l03335"></a>03335 <span class="comment"></span>
<a name="l03336"></a>03336 <span class="comment">    If AccumulatorChain is used with CoupledIterator, WeightArg&lt;INDEX&gt; tells the accumulator chain which index of the Handle contains the weights. (Note that coordinates are always index 0.)</span>
<a name="l03337"></a>03337 <span class="comment">*/</span>
<a name="l03338"></a>03338 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> INDEX&gt;
<a name="l03339"></a><a class="code" href="classvigra_1_1acc_1_1WeightArg.html">03339</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1WeightArg.html" title="Specifies index of data in CoupledHandle.">WeightArg</a>
<a name="l03340"></a>03340 {
<a name="l03341"></a>03341   <span class="keyword">public</span>:
<a name="l03342"></a>03342     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l03343"></a>03343     
<a name="l03344"></a>03344     <span class="keyword">static</span> std::string name() 
<a name="l03345"></a>03345     { 
<a name="l03346"></a>03346         <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;WeightArg&lt;&quot;</span>) + <a class="code" href="namespacevigra.html#abefdd44c2db13a2b64f36c82d3647b82">asString</a>(INDEX) + <span class="stringliteral">&quot;&gt; (internal)&quot;</span>;
<a name="l03347"></a>03347         <span class="comment">// static const std::string n = std::string(&quot;WeightArg&lt;&quot;) + asString(INDEX) + &quot;&gt; (internal)&quot;;</span>
<a name="l03348"></a>03348         <span class="comment">// return n;</span>
<a name="l03349"></a>03349     }
<a name="l03350"></a>03350     
<a name="l03351"></a>03351     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> BASE&gt;
<a name="l03352"></a>03352     <span class="keyword">struct </span>Impl
<a name="l03353"></a>03353     : <span class="keyword">public</span> BASE
<a name="l03354"></a>03354     {
<a name="l03355"></a>03355         <span class="keyword">typedef</span> WeightArgTag Tag;
<a name="l03356"></a>03356         <span class="keyword">typedef</span> <span class="keywordtype">void</span> value_type;
<a name="l03357"></a>03357         <span class="keyword">typedef</span> <span class="keywordtype">void</span> result_type;
<a name="l03358"></a>03358 
<a name="l03359"></a>03359         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> value = INDEX;
<a name="l03360"></a>03360         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> workInPass = 0;
<a name="l03361"></a>03361     };
<a name="l03362"></a>03362 };
<a name="l03363"></a>03363 <span class="comment"></span>
<a name="l03364"></a>03364 <span class="comment">/** \brief Compute weighted version of the statistic.</span>
<a name="l03365"></a>03365 <span class="comment">*/</span>
<a name="l03366"></a>03366 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG&gt;
<a name="l03367"></a><a class="code" href="classvigra_1_1acc_1_1Weighted.html">03367</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1Weighted.html" title="Compute weighted version of the statistic.">Weighted</a>
<a name="l03368"></a>03368 {
<a name="l03369"></a>03369   <span class="keyword">public</span>:
<a name="l03370"></a>03370     <span class="keyword">typedef</span> <span class="keyword">typename</span> StandardizeTag&lt;TAG&gt;::type   TargetTag;
<a name="l03371"></a>03371     <span class="keyword">typedef</span> <span class="keyword">typename</span> TargetTag::Dependencies     Dependencies;
<a name="l03372"></a>03372     
<a name="l03373"></a>03373     <span class="keyword">static</span> std::string name() 
<a name="l03374"></a>03374     { 
<a name="l03375"></a>03375         <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;Weighted&lt;&quot;</span>) + TargetTag::name() + <span class="stringliteral">&quot; &gt;&quot;</span>;
<a name="l03376"></a>03376         <span class="comment">// static const std::string n = std::string(&quot;Weighted&lt;&quot;) + TargetTag::name() + &quot; &gt;&quot;;</span>
<a name="l03377"></a>03377         <span class="comment">// return n;</span>
<a name="l03378"></a>03378     }
<a name="l03379"></a>03379     
<a name="l03380"></a>03380     <span class="keyword">template</span> &lt;<span class="keyword">class</span> IndexDefinition, <span class="keyword">class</span> TagFound=<span class="keyword">typename</span> IndexDefinition::Tag&gt;
<a name="l03381"></a>03381     <span class="keyword">struct </span>WeightIndexSelector
<a name="l03382"></a>03382     {
<a name="l03383"></a>03383         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> NEXT&gt;
<a name="l03384"></a>03384         <span class="keyword">static</span> <span class="keywordtype">double</span> exec(<a class="code" href="classvigra_1_1CoupledHandle.html">CoupledHandle&lt;U, NEXT&gt;</a> <span class="keyword">const</span> &amp; t)
<a name="l03385"></a>03385         {
<a name="l03386"></a>03386             <span class="keywordflow">return</span> (<span class="keywordtype">double</span>)*t; <span class="comment">// default: CoupledHandle holds weights at the last (outermost) index </span>
<a name="l03387"></a>03387         }
<a name="l03388"></a>03388     };
<a name="l03389"></a>03389     
<a name="l03390"></a>03390     <span class="keyword">template</span> &lt;<span class="keyword">class</span> IndexDefinition&gt;
<a name="l03391"></a>03391     <span class="keyword">struct </span>WeightIndexSelector&lt;IndexDefinition, WeightArgTag&gt;
<a name="l03392"></a>03392     {
<a name="l03393"></a>03393         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> NEXT&gt;
<a name="l03394"></a>03394         <span class="keyword">static</span> <span class="keywordtype">double</span> exec(<a class="code" href="classvigra_1_1CoupledHandle.html">CoupledHandle&lt;U, NEXT&gt;</a> <span class="keyword">const</span> &amp; t)
<a name="l03395"></a>03395         {
<a name="l03396"></a>03396             <span class="keywordflow">return</span> (<span class="keywordtype">double</span>)get&lt;IndexDefinition::value&gt;(t);
<a name="l03397"></a>03397         }
<a name="l03398"></a>03398     };
<a name="l03399"></a>03399     
<a name="l03400"></a>03400     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> BASE&gt;
<a name="l03401"></a>03401     <span class="keyword">struct </span>Impl
<a name="l03402"></a>03402     : <span class="keyword">public</span> TargetTag::template Impl&lt;T, BASE&gt;
<a name="l03403"></a>03403     {
<a name="l03404"></a>03404         <span class="keyword">typedef</span> <span class="keyword">typename</span> TargetTag::template Impl&lt;T, BASE&gt; ImplType;
<a name="l03405"></a>03405         
<a name="l03406"></a>03406         <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupTag&lt;WeightArgTag, BASE&gt;::type FindWeightIndex;
<a name="l03407"></a>03407                 
<a name="l03408"></a>03408         <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> NEXT&gt;
<a name="l03409"></a>03409         <span class="keywordtype">void</span> update(<a class="code" href="classvigra_1_1CoupledHandle.html">CoupledHandle&lt;U, NEXT&gt;</a> <span class="keyword">const</span> &amp; t)
<a name="l03410"></a>03410         {
<a name="l03411"></a>03411             ImplType::update(t, WeightIndexSelector&lt;FindWeightIndex&gt;::exec(t));
<a name="l03412"></a>03412         }
<a name="l03413"></a>03413     };
<a name="l03414"></a>03414 };
<a name="l03415"></a>03415 
<a name="l03416"></a>03416 <span class="comment">// Centralize by subtracting the mean and cache the result</span>
<a name="l03417"></a>03417 <span class="keyword">class </span>Centralize
<a name="l03418"></a>03418 {
<a name="l03419"></a>03419   <span class="keyword">public</span>:
<a name="l03420"></a>03420     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;Mean&gt;</a> Dependencies;
<a name="l03421"></a>03421     
<a name="l03422"></a>03422     <span class="keyword">static</span> std::string name() 
<a name="l03423"></a>03423     { 
<a name="l03424"></a>03424          <span class="keywordflow">return</span> <span class="stringliteral">&quot;Centralize (internal)&quot;</span>;
<a name="l03425"></a>03425         <span class="comment">// static const std::string n(&quot;Centralize (internal)&quot;);</span>
<a name="l03426"></a>03426         <span class="comment">// return n;</span>
<a name="l03427"></a>03427     }
<a name="l03428"></a>03428    
<a name="l03429"></a>03429     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l03430"></a>03430     <span class="keyword">struct </span>Impl
<a name="l03431"></a>03431     : <span class="keyword">public</span> BASE
<a name="l03432"></a>03432     {
<a name="l03433"></a>03433         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> workInPass = 2;
<a name="l03434"></a>03434         
<a name="l03435"></a>03435         <span class="keyword">typedef</span> <span class="keyword">typename</span> AccumulatorResultTraits&lt;U&gt;::element_promote_type element_type;
<a name="l03436"></a>03436         <span class="keyword">typedef</span> <span class="keyword">typename</span> AccumulatorResultTraits&lt;U&gt;::SumType              value_type;
<a name="l03437"></a>03437         <span class="keyword">typedef</span> value_type <span class="keyword">const</span> &amp;                                  result_type;
<a name="l03438"></a>03438 
<a name="l03439"></a>03439         <span class="keyword">mutable</span> value_type value_;
<a name="l03440"></a>03440         
<a name="l03441"></a>03441         Impl()
<a name="l03442"></a>03442         : value_()  <span class="comment">// call default constructor explicitly to ensure zero initialization</span>
<a name="l03443"></a>03443         {}
<a name="l03444"></a>03444         
<a name="l03445"></a>03445         <span class="keywordtype">void</span> reset()
<a name="l03446"></a>03446         {
<a name="l03447"></a>03447             value_ = element_type();
<a name="l03448"></a>03448         }
<a name="l03449"></a>03449     
<a name="l03450"></a>03450         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Shape&gt;
<a name="l03451"></a>03451         <span class="keywordtype">void</span> reshape(Shape <span class="keyword">const</span> &amp; s)
<a name="l03452"></a>03452         {
<a name="l03453"></a>03453             acc_detail::reshapeImpl(value_, s);
<a name="l03454"></a>03454         }
<a name="l03455"></a>03455         
<a name="l03456"></a>03456         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t)<span class="keyword"> const</span>
<a name="l03457"></a>03457 <span class="keyword">        </span>{
<a name="l03458"></a>03458             <span class="keyword">using namespace </span>vigra::multi_math;
<a name="l03459"></a>03459             value_ = t - getDependency&lt;Mean&gt;(*this);
<a name="l03460"></a>03460         }
<a name="l03461"></a>03461         
<a name="l03462"></a>03462         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span>)<span class="keyword"> const</span>
<a name="l03463"></a>03463 <span class="keyword">        </span>{
<a name="l03464"></a>03464             update(t);
<a name="l03465"></a>03465         }
<a name="l03466"></a>03466         
<a name="l03467"></a>03467         result_type operator()(U <span class="keyword">const</span> &amp; t)<span class="keyword"> const</span>
<a name="l03468"></a>03468 <span class="keyword">        </span>{
<a name="l03469"></a>03469             update(t);
<a name="l03470"></a>03470             <span class="keywordflow">return</span> value_;
<a name="l03471"></a>03471         }
<a name="l03472"></a>03472         
<a name="l03473"></a>03473         result_type operator()()<span class="keyword"> const</span>
<a name="l03474"></a>03474 <span class="keyword">        </span>{
<a name="l03475"></a>03475             <span class="keywordflow">return</span> value_;
<a name="l03476"></a>03476         }
<a name="l03477"></a>03477     };
<a name="l03478"></a>03478 };
<a name="l03479"></a>03479 <span class="comment"></span>
<a name="l03480"></a>03480 <span class="comment">/** \brief Modifier. Substract mean before computing statistic. </span>
<a name="l03481"></a>03481 <span class="comment"></span>
<a name="l03482"></a>03482 <span class="comment">Works in pass 2, %operator+=() not supported (merging not supported).</span>
<a name="l03483"></a>03483 <span class="comment">*/</span>
<a name="l03484"></a>03484 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG&gt;
<a name="l03485"></a><a class="code" href="classvigra_1_1acc_1_1Central.html">03485</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1Central.html" title="Modifier. Substract mean before computing statistic.">Central</a>
<a name="l03486"></a>03486 {
<a name="l03487"></a>03487   <span class="keyword">public</span>:
<a name="l03488"></a>03488     <span class="keyword">typedef</span> <span class="keyword">typename</span> StandardizeTag&lt;TAG&gt;::type                    TargetTag;
<a name="l03489"></a>03489     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;Centralize, typename TargetTag::Dependencies&gt;</a>  <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l03490"></a>03490     
<a name="l03491"></a>03491     <span class="keyword">static</span> std::string name() 
<a name="l03492"></a>03492     { 
<a name="l03493"></a>03493         <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;Central&lt;&quot;</span>) + TargetTag::name() + <span class="stringliteral">&quot; &gt;&quot;</span>;
<a name="l03494"></a>03494         <span class="comment">// static const std::string n = std::string(&quot;Central&lt;&quot;) + TargetTag::name() + &quot; &gt;&quot;;</span>
<a name="l03495"></a>03495         <span class="comment">// return n;</span>
<a name="l03496"></a>03496     }
<a name="l03497"></a>03497     
<a name="l03498"></a>03498     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l03499"></a>03499     <span class="keyword">struct </span>Impl
<a name="l03500"></a>03500     : <span class="keyword">public</span> TargetTag::template Impl&lt;typename AccumulatorResultTraits&lt;U&gt;::SumType, BASE&gt;
<a name="l03501"></a>03501     {
<a name="l03502"></a>03502         <span class="keyword">typedef</span> <span class="keyword">typename</span> TargetTag::template Impl&lt;typename AccumulatorResultTraits&lt;U&gt;::SumType, BASE&gt; ImplType;
<a name="l03503"></a>03503         
<a name="l03504"></a>03504         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> workInPass = 2;
<a name="l03505"></a>03505         
<a name="l03506"></a>03506         <span class="keywordtype">void</span> <a class="code" href="group__FFTWComplexOperators.html#ga23c9113f38123caf2ae30a59a1a5cfc5" title="add-assignment">operator+=</a>(Impl <span class="keyword">const</span> &amp; o)
<a name="l03507"></a>03507         {
<a name="l03508"></a>03508             vigra_precondition(<span class="keyword">false</span>,
<a name="l03509"></a>03509                 <span class="stringliteral">&quot;Central&lt;...&gt;::operator+=(): not supported.&quot;</span>);
<a name="l03510"></a>03510         }
<a name="l03511"></a>03511     
<a name="l03512"></a>03512         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l03513"></a>03513         <span class="keywordtype">void</span> update(T <span class="keyword">const</span> &amp; t)
<a name="l03514"></a>03514         {
<a name="l03515"></a>03515             ImplType::update(getDependency&lt;Centralize&gt;(*<span class="keyword">this</span>));
<a name="l03516"></a>03516         }
<a name="l03517"></a>03517         
<a name="l03518"></a>03518         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l03519"></a>03519         <span class="keywordtype">void</span> update(T <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l03520"></a>03520         {
<a name="l03521"></a>03521             ImplType::update(getDependency&lt;Centralize&gt;(*<span class="keyword">this</span>), weight);
<a name="l03522"></a>03522         }
<a name="l03523"></a>03523     };
<a name="l03524"></a>03524 };
<a name="l03525"></a>03525 
<a name="l03526"></a>03526     <span class="comment">// alternative implementation without caching </span>
<a name="l03527"></a>03527     <span class="comment">//</span>
<a name="l03528"></a>03528 <span class="comment">// template &lt;class TAG&gt;</span>
<a name="l03529"></a>03529 <span class="comment">// class Central</span>
<a name="l03530"></a>03530 <span class="comment">// {</span>
<a name="l03531"></a>03531   <span class="comment">// public:</span>
<a name="l03532"></a>03532     <span class="comment">// typedef typename StandardizeTag&lt;TAG&gt;::type TargetTag;</span>
<a name="l03533"></a>03533     <span class="comment">// typedef TypeList&lt;Mean, typename TransferModifiers&lt;Central&lt;TargetTag&gt;, typename TargetTag::Dependencies::type&gt;::type&gt; Dependencies;</span>
<a name="l03534"></a>03534     
<a name="l03535"></a>03535     <span class="comment">// template &lt;class U, class BASE&gt;</span>
<a name="l03536"></a>03536     <span class="comment">// struct Impl</span>
<a name="l03537"></a>03537     <span class="comment">// : public TargetTag::template Impl&lt;typename AccumulatorResultTraits&lt;U&gt;::SumType, BASE&gt;</span>
<a name="l03538"></a>03538     <span class="comment">// {</span>
<a name="l03539"></a>03539         <span class="comment">// typedef typename TargetTag::template Impl&lt;typename AccumulatorResultTraits&lt;U&gt;::SumType, BASE&gt; ImplType;</span>
<a name="l03540"></a>03540         
<a name="l03541"></a>03541         <span class="comment">// static const unsigned int workInPass = 2;</span>
<a name="l03542"></a>03542         
<a name="l03543"></a>03543         <span class="comment">// void operator+=(Impl const &amp; o)</span>
<a name="l03544"></a>03544         <span class="comment">// {</span>
<a name="l03545"></a>03545             <span class="comment">// vigra_precondition(false,</span>
<a name="l03546"></a>03546                 <span class="comment">// &quot;Central&lt;...&gt;::operator+=(): not supported.&quot;);</span>
<a name="l03547"></a>03547         <span class="comment">// }</span>
<a name="l03548"></a>03548     
<a name="l03549"></a>03549         <span class="comment">// template &lt;class T&gt;</span>
<a name="l03550"></a>03550         <span class="comment">// void update(T const &amp; t)</span>
<a name="l03551"></a>03551         <span class="comment">// {</span>
<a name="l03552"></a>03552             <span class="comment">// ImplType::update(t - getDependency&lt;Mean&gt;(*this));</span>
<a name="l03553"></a>03553         <span class="comment">// }</span>
<a name="l03554"></a>03554         
<a name="l03555"></a>03555         <span class="comment">// template &lt;class T&gt;</span>
<a name="l03556"></a>03556         <span class="comment">// void update(T const &amp; t, double weight)</span>
<a name="l03557"></a>03557         <span class="comment">// {</span>
<a name="l03558"></a>03558             <span class="comment">// ImplType::update(t - getDependency&lt;Mean&gt;(*this), weight);</span>
<a name="l03559"></a>03559         <span class="comment">// }</span>
<a name="l03560"></a>03560     <span class="comment">// };</span>
<a name="l03561"></a>03561 <span class="comment">// };</span>
<a name="l03562"></a>03562 
<a name="l03563"></a>03563 
<a name="l03564"></a>03564 <span class="keyword">class </span>PrincipalProjection
<a name="l03565"></a>03565 {
<a name="l03566"></a>03566   <span class="keyword">public</span>:
<a name="l03567"></a>03567     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;Centralize, Principal&lt;CoordinateSystem&gt;</a> &gt; Dependencies;
<a name="l03568"></a>03568     
<a name="l03569"></a>03569     <span class="keyword">static</span> std::string name() 
<a name="l03570"></a>03570     { 
<a name="l03571"></a>03571         <span class="keywordflow">return</span> <span class="stringliteral">&quot;PrincipalProjection (internal)&quot;</span>;
<a name="l03572"></a>03572         <span class="comment">// static const std::string n(&quot;PrincipalProjection (internal)&quot;);</span>
<a name="l03573"></a>03573         <span class="comment">// return n;</span>
<a name="l03574"></a>03574     }
<a name="l03575"></a>03575     
<a name="l03576"></a>03576     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l03577"></a>03577     <span class="keyword">struct </span>Impl
<a name="l03578"></a>03578     : <span class="keyword">public</span> BASE
<a name="l03579"></a>03579     {
<a name="l03580"></a>03580         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> workInPass = 2;
<a name="l03581"></a>03581         
<a name="l03582"></a>03582         <span class="keyword">typedef</span> <span class="keyword">typename</span> AccumulatorResultTraits&lt;U&gt;::element_promote_type element_type;
<a name="l03583"></a>03583         <span class="keyword">typedef</span> <span class="keyword">typename</span> AccumulatorResultTraits&lt;U&gt;::SumType              value_type;
<a name="l03584"></a>03584         <span class="keyword">typedef</span> value_type <span class="keyword">const</span> &amp;                                  result_type;
<a name="l03585"></a>03585 
<a name="l03586"></a>03586         <span class="keyword">mutable</span> value_type value_;
<a name="l03587"></a>03587         
<a name="l03588"></a>03588         Impl()
<a name="l03589"></a>03589         : value_()  <span class="comment">// call default constructor explicitly to ensure zero initialization</span>
<a name="l03590"></a>03590         {}
<a name="l03591"></a>03591         
<a name="l03592"></a>03592         <span class="keywordtype">void</span> reset()
<a name="l03593"></a>03593         {
<a name="l03594"></a>03594             value_ = element_type();
<a name="l03595"></a>03595         }
<a name="l03596"></a>03596     
<a name="l03597"></a>03597         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Shape&gt;
<a name="l03598"></a>03598         <span class="keywordtype">void</span> reshape(Shape <span class="keyword">const</span> &amp; s)
<a name="l03599"></a>03599         {
<a name="l03600"></a>03600             acc_detail::reshapeImpl(value_, s);
<a name="l03601"></a>03601         }
<a name="l03602"></a>03602         
<a name="l03603"></a>03603         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t)<span class="keyword"> const</span>
<a name="l03604"></a>03604 <span class="keyword">        </span>{
<a name="l03605"></a>03605             <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;t.size(); ++k)
<a name="l03606"></a>03606             {
<a name="l03607"></a>03607                 value_[k] = getDependency&lt;Principal&lt;CoordinateSystem&gt; &gt;(*this)(0, k)*getDependency&lt;Centralize&gt;(*<span class="keyword">this</span>)[0];
<a name="l03608"></a>03608                 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=1; d&lt;t.size(); ++d)
<a name="l03609"></a>03609                     value_[k] += getDependency&lt;Principal&lt;CoordinateSystem&gt; &gt;(*<span class="keyword">this</span>)(d, k)*getDependency&lt;Centralize&gt;(*<span class="keyword">this</span>)[d];
<a name="l03610"></a>03610             }
<a name="l03611"></a>03611         }
<a name="l03612"></a>03612         
<a name="l03613"></a>03613         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span>)<span class="keyword"> const</span>
<a name="l03614"></a>03614 <span class="keyword">        </span>{
<a name="l03615"></a>03615             update(t);
<a name="l03616"></a>03616         }
<a name="l03617"></a>03617         
<a name="l03618"></a>03618         result_type operator()(U <span class="keyword">const</span> &amp; t)<span class="keyword"> const</span>
<a name="l03619"></a>03619 <span class="keyword">        </span>{
<a name="l03620"></a>03620             getAccumulator&lt;Centralize&gt;(*this).update(t);
<a name="l03621"></a>03621             update(t);
<a name="l03622"></a>03622             <span class="keywordflow">return</span> value_;
<a name="l03623"></a>03623         }
<a name="l03624"></a>03624         
<a name="l03625"></a>03625         result_type operator()()<span class="keyword"> const</span>
<a name="l03626"></a>03626 <span class="keyword">        </span>{
<a name="l03627"></a>03627             <span class="keywordflow">return</span> value_;
<a name="l03628"></a>03628         }
<a name="l03629"></a>03629     };
<a name="l03630"></a>03630 };
<a name="l03631"></a>03631 <span class="comment"></span>
<a name="l03632"></a>03632 <span class="comment">/** \brief Modifier. Project onto PCA eigenvectors.</span>
<a name="l03633"></a>03633 <span class="comment"></span>
<a name="l03634"></a>03634 <span class="comment">    Works in pass 2, %operator+=() not supported (merging not supported).</span>
<a name="l03635"></a>03635 <span class="comment">*/</span>
<a name="l03636"></a>03636 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG&gt;
<a name="l03637"></a><a class="code" href="classvigra_1_1acc_1_1Principal.html">03637</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1Principal.html" title="Modifier. Project onto PCA eigenvectors.">Principal</a>
<a name="l03638"></a>03638 {
<a name="l03639"></a>03639   <span class="keyword">public</span>:
<a name="l03640"></a>03640     <span class="keyword">typedef</span> <span class="keyword">typename</span> StandardizeTag&lt;TAG&gt;::type                             TargetTag;
<a name="l03641"></a>03641     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;PrincipalProjection, typename TargetTag::Dependencies&gt;</a>  <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l03642"></a>03642     
<a name="l03643"></a>03643     <span class="keyword">static</span> std::string name() 
<a name="l03644"></a>03644     { 
<a name="l03645"></a>03645         <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;Principal&lt;&quot;</span>) + TargetTag::name() + <span class="stringliteral">&quot; &gt;&quot;</span>;
<a name="l03646"></a>03646         <span class="comment">// static const std::string n = std::string(&quot;Principal&lt;&quot;) + TargetTag::name() + &quot; &gt;&quot;;</span>
<a name="l03647"></a>03647         <span class="comment">// return n;</span>
<a name="l03648"></a>03648     }
<a name="l03649"></a>03649     
<a name="l03650"></a>03650     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l03651"></a>03651     <span class="keyword">struct </span>Impl
<a name="l03652"></a>03652     : <span class="keyword">public</span> TargetTag::template Impl&lt;typename AccumulatorResultTraits&lt;U&gt;::SumType, BASE&gt;
<a name="l03653"></a>03653     {
<a name="l03654"></a>03654         <span class="keyword">typedef</span> <span class="keyword">typename</span> TargetTag::template Impl&lt;typename AccumulatorResultTraits&lt;U&gt;::SumType, BASE&gt; ImplType;
<a name="l03655"></a>03655         
<a name="l03656"></a>03656         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> workInPass = 2;
<a name="l03657"></a>03657         
<a name="l03658"></a>03658         <span class="keywordtype">void</span> <a class="code" href="group__FFTWComplexOperators.html#ga23c9113f38123caf2ae30a59a1a5cfc5" title="add-assignment">operator+=</a>(Impl <span class="keyword">const</span> &amp; o)
<a name="l03659"></a>03659         {
<a name="l03660"></a>03660             vigra_precondition(<span class="keyword">false</span>,
<a name="l03661"></a>03661                 <span class="stringliteral">&quot;Principal&lt;...&gt;::operator+=(): not supported.&quot;</span>);
<a name="l03662"></a>03662         }
<a name="l03663"></a>03663     
<a name="l03664"></a>03664         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l03665"></a>03665         <span class="keywordtype">void</span> update(T <span class="keyword">const</span> &amp; t)
<a name="l03666"></a>03666         {
<a name="l03667"></a>03667             ImplType::update(getDependency&lt;PrincipalProjection&gt;(*<span class="keyword">this</span>));
<a name="l03668"></a>03668         }
<a name="l03669"></a>03669         
<a name="l03670"></a>03670         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l03671"></a>03671         <span class="keywordtype">void</span> update(T <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l03672"></a>03672         {
<a name="l03673"></a>03673             ImplType::update(getDependency&lt;PrincipalProjection&gt;(*<span class="keyword">this</span>), weight);
<a name="l03674"></a>03674         }
<a name="l03675"></a>03675     };
<a name="l03676"></a>03676 };
<a name="l03677"></a>03677 
<a name="l03678"></a>03678 <span class="comment">/*</span>
<a name="l03679"></a>03679 <span class="comment">important notes on modifiers:</span>
<a name="l03680"></a>03680 <span class="comment"> * upon accumulator creation, modifiers are reordered so that data preparation is innermost, </span>
<a name="l03681"></a>03681 <span class="comment">   and data access is outermost, e.g.:</span>
<a name="l03682"></a>03682 <span class="comment">        Coord&lt;DivideByCount&lt;Principal&lt;PowerSum&lt;2&gt; &gt; &gt; &gt;</span>
<a name="l03683"></a>03683 <span class="comment"> * modifiers are automatically transfered to dependencies as appropriate</span>
<a name="l03684"></a>03684 <span class="comment"> * modifiers for lookup (getAccumulator and get) of dependent accumulators are automatically adjusted</span>
<a name="l03685"></a>03685 <span class="comment"> * modifiers must adjust workInPass for the contained accumulator as appropriate</span>
<a name="l03686"></a>03686 <span class="comment"> * we may implement convenience versions of Select that apply a modifier to all </span>
<a name="l03687"></a>03687 <span class="comment">   contained tags at once</span>
<a name="l03688"></a>03688 <span class="comment"> * weighted accumulators have their own Count object when used together</span>
<a name="l03689"></a>03689 <span class="comment">   with unweighted ones (this is as yet untested - FIXME)</span>
<a name="l03690"></a>03690 <span class="comment"> * certain accumulators must remain unchanged when wrapped in certain modifiers: </span>
<a name="l03691"></a>03691 <span class="comment">    * Count: always except for Weighted&lt;Count&gt; and CoordWeighted&lt;Count&gt;</span>
<a name="l03692"></a>03692 <span class="comment">    * Sum: data preparation modifiers</span>
<a name="l03693"></a>03693 <span class="comment">    * FlatScatterMatrixImpl, CovarianceEigensystemImpl: Principal and Whitened</span>
<a name="l03694"></a>03694 <span class="comment"> * will it be useful to implement initPass&lt;N&gt;() or finalizePass&lt;N&gt;() ?</span>
<a name="l03695"></a>03695 <span class="comment">*/</span>
<a name="l03696"></a>03696 
<a name="l03697"></a>03697 <span class="comment">/****************************************************************************/</span>
<a name="l03698"></a>03698 <span class="comment">/*                                                                          */</span>
<a name="l03699"></a>03699 <span class="comment">/*                        the actual accumulators                           */</span>
<a name="l03700"></a>03700 <span class="comment">/*                                                                          */</span>
<a name="l03701"></a>03701 <span class="comment">/****************************************************************************/</span>
<a name="l03702"></a>03702 <span class="comment"></span>
<a name="l03703"></a>03703 <span class="comment">/** \brief Basic statistic. Identity matrix of appropriate size.</span>
<a name="l03704"></a>03704 <span class="comment">*/</span>
<a name="l03705"></a><a class="code" href="classvigra_1_1acc_1_1CoordinateSystem.html">03705</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1CoordinateSystem.html" title="Basic statistic. Identity matrix of appropriate size.">CoordinateSystem</a>
<a name="l03706"></a>03706 {
<a name="l03707"></a>03707   <span class="keyword">public</span>:
<a name="l03708"></a>03708     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l03709"></a>03709     
<a name="l03710"></a>03710     <span class="keyword">static</span> std::string name() 
<a name="l03711"></a>03711     { 
<a name="l03712"></a>03712         <span class="keywordflow">return</span> <span class="stringliteral">&quot;CoordinateSystem&quot;</span>;
<a name="l03713"></a>03713         <span class="comment">// static const std::string n(&quot;CoordinateSystem&quot;);</span>
<a name="l03714"></a>03714         <span class="comment">// return n;</span>
<a name="l03715"></a>03715     }
<a name="l03716"></a>03716     
<a name="l03717"></a>03717     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l03718"></a>03718     <span class="keyword">struct </span>Impl
<a name="l03719"></a>03719     : <span class="keyword">public</span> BASE
<a name="l03720"></a>03720     {
<a name="l03721"></a>03721         <span class="keyword">typedef</span> <span class="keywordtype">double</span>              element_type;
<a name="l03722"></a>03722         <span class="keyword">typedef</span> Matrix&lt;double&gt;      value_type;
<a name="l03723"></a>03723         <span class="keyword">typedef</span> value_type <span class="keyword">const</span> &amp;  result_type;
<a name="l03724"></a>03724 
<a name="l03725"></a>03725         value_type value_;
<a name="l03726"></a>03726         
<a name="l03727"></a>03727         Impl()
<a name="l03728"></a>03728         : value_()  <span class="comment">// call default constructor explicitly to ensure zero initialization</span>
<a name="l03729"></a>03729         {}
<a name="l03730"></a>03730         
<a name="l03731"></a>03731         <span class="keywordtype">void</span> reset()
<a name="l03732"></a>03732         {
<a name="l03733"></a>03733             value_ = element_type();
<a name="l03734"></a>03734         }
<a name="l03735"></a>03735 
<a name="l03736"></a>03736         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Shape&gt;
<a name="l03737"></a>03737         <span class="keywordtype">void</span> reshape(Shape <span class="keyword">const</span> &amp; s)
<a name="l03738"></a>03738         {
<a name="l03739"></a>03739             acc_detail::reshapeImpl(value_, s);
<a name="l03740"></a>03740         }
<a name="l03741"></a>03741         
<a name="l03742"></a>03742         result_type operator()()<span class="keyword"> const</span>
<a name="l03743"></a>03743 <span class="keyword">        </span>{
<a name="l03744"></a>03744             <span class="keywordflow">return</span> value_;
<a name="l03745"></a>03745         }
<a name="l03746"></a>03746     };
<a name="l03747"></a>03747 };
<a name="l03748"></a>03748 
<a name="l03749"></a>03749 <span class="keyword">template</span> &lt;<span class="keyword">class </span>BASE, <span class="keyword">class </span>T, 
<a name="l03750"></a>03750           <span class="keyword">class </span>ElementType=<span class="keyword">typename</span> AccumulatorResultTraits&lt;T&gt;::element_promote_type, 
<a name="l03751"></a>03751           <span class="keyword">class </span>SumType=<span class="keyword">typename</span> AccumulatorResultTraits&lt;T&gt;::SumType&gt;
<a name="l03752"></a>03752 <span class="keyword">struct </span>SumBaseImpl
<a name="l03753"></a>03753 : <span class="keyword">public</span> BASE
<a name="l03754"></a>03754 {
<a name="l03755"></a>03755     <span class="keyword">typedef</span> ElementType         element_type;
<a name="l03756"></a>03756     <span class="keyword">typedef</span> SumType             value_type;
<a name="l03757"></a>03757     <span class="keyword">typedef</span> value_type <span class="keyword">const</span> &amp;  result_type;
<a name="l03758"></a>03758 
<a name="l03759"></a>03759     value_type value_;
<a name="l03760"></a>03760     
<a name="l03761"></a>03761     SumBaseImpl()
<a name="l03762"></a>03762     : value_()  <span class="comment">// call default constructor explicitly to ensure zero initialization</span>
<a name="l03763"></a>03763     {}
<a name="l03764"></a>03764     
<a name="l03765"></a>03765     <span class="keywordtype">void</span> reset()
<a name="l03766"></a>03766     {
<a name="l03767"></a>03767         value_ = element_type();
<a name="l03768"></a>03768     }
<a name="l03769"></a>03769 
<a name="l03770"></a>03770     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Shape&gt;
<a name="l03771"></a>03771     <span class="keywordtype">void</span> reshape(Shape <span class="keyword">const</span> &amp; s)
<a name="l03772"></a>03772     {
<a name="l03773"></a>03773         acc_detail::reshapeImpl(value_, s);
<a name="l03774"></a>03774     }
<a name="l03775"></a>03775     
<a name="l03776"></a>03776     <span class="keywordtype">void</span> <a class="code" href="group__FFTWComplexOperators.html#ga23c9113f38123caf2ae30a59a1a5cfc5" title="add-assignment">operator+=</a>(SumBaseImpl <span class="keyword">const</span> &amp; o)
<a name="l03777"></a>03777     {
<a name="l03778"></a>03778         value_ += o.value_;
<a name="l03779"></a>03779     }
<a name="l03780"></a>03780 
<a name="l03781"></a>03781     result_type operator()()<span class="keyword"> const</span>
<a name="l03782"></a>03782 <span class="keyword">    </span>{
<a name="l03783"></a>03783         <span class="keywordflow">return</span> value_;
<a name="l03784"></a>03784     }
<a name="l03785"></a>03785 };
<a name="l03786"></a>03786 
<a name="l03787"></a>03787 <span class="comment">// Count</span>
<a name="l03788"></a>03788 <span class="keyword">template</span> &lt;&gt;
<a name="l03789"></a>03789 <span class="keyword">class </span>PowerSum&lt;0&gt;
<a name="l03790"></a>03790 {
<a name="l03791"></a>03791   <span class="keyword">public</span>:
<a name="l03792"></a>03792     <span class="keyword">typedef</span> Select&lt;&gt; Dependencies;
<a name="l03793"></a>03793     
<a name="l03794"></a>03794     <span class="keyword">static</span> std::string name() 
<a name="l03795"></a>03795     { 
<a name="l03796"></a>03796         <span class="keywordflow">return</span> <span class="stringliteral">&quot;PowerSum&lt;0&gt;&quot;</span>;
<a name="l03797"></a>03797         <span class="comment">// static const std::string n(&quot;PowerSum&lt;0&gt;&quot;);</span>
<a name="l03798"></a>03798         <span class="comment">// return n;</span>
<a name="l03799"></a>03799     }
<a name="l03800"></a>03800     
<a name="l03801"></a>03801     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> BASE&gt;
<a name="l03802"></a>03802     <span class="keyword">struct </span>Impl
<a name="l03803"></a>03803     : <span class="keyword">public</span> SumBaseImpl&lt;BASE, T, double, double&gt;
<a name="l03804"></a>03804     {
<a name="l03805"></a>03805         <span class="keywordtype">void</span> update(T <span class="keyword">const</span> &amp; t)
<a name="l03806"></a>03806         {
<a name="l03807"></a>03807             ++this-&gt;value_;
<a name="l03808"></a>03808         }
<a name="l03809"></a>03809         
<a name="l03810"></a>03810         <span class="keywordtype">void</span> update(T <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l03811"></a>03811         {
<a name="l03812"></a>03812             this-&gt;value_ += weight;
<a name="l03813"></a>03813         }
<a name="l03814"></a>03814     };
<a name="l03815"></a>03815 };
<a name="l03816"></a>03816 
<a name="l03817"></a>03817 <span class="comment">// Sum</span>
<a name="l03818"></a>03818 <span class="keyword">template</span> &lt;&gt;
<a name="l03819"></a>03819 <span class="keyword">class </span>PowerSum&lt;1&gt;
<a name="l03820"></a>03820 {
<a name="l03821"></a>03821   <span class="keyword">public</span>:
<a name="l03822"></a>03822     <span class="keyword">typedef</span> Select&lt;&gt; Dependencies;
<a name="l03823"></a>03823      
<a name="l03824"></a>03824     <span class="keyword">static</span> std::string name() 
<a name="l03825"></a>03825     { 
<a name="l03826"></a>03826         <span class="keywordflow">return</span> <span class="stringliteral">&quot;PowerSum&lt;1&gt;&quot;</span>;
<a name="l03827"></a>03827         <span class="comment">// static const std::string n(&quot;PowerSum&lt;1&gt;&quot;);</span>
<a name="l03828"></a>03828         <span class="comment">// return n;</span>
<a name="l03829"></a>03829     }
<a name="l03830"></a>03830     
<a name="l03831"></a>03831     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l03832"></a>03832     <span class="keyword">struct </span>Impl
<a name="l03833"></a>03833     : <span class="keyword">public</span> SumBaseImpl&lt;BASE, U&gt;
<a name="l03834"></a>03834     {
<a name="l03835"></a>03835         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t)
<a name="l03836"></a>03836         {
<a name="l03837"></a>03837             this-&gt;value_ += t;
<a name="l03838"></a>03838         }
<a name="l03839"></a>03839         
<a name="l03840"></a>03840         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l03841"></a>03841         {
<a name="l03842"></a>03842             this-&gt;value_ += weight*t;
<a name="l03843"></a>03843         }
<a name="l03844"></a>03844     };
<a name="l03845"></a>03845 };
<a name="l03846"></a>03846 <span class="comment"></span>
<a name="l03847"></a>03847 <span class="comment">/** \brief Basic statistic. PowerSum&lt;N&gt; =@f$ \sum_i x_i^N @f$</span>
<a name="l03848"></a>03848 <span class="comment"></span>
<a name="l03849"></a>03849 <span class="comment">    Works in pass 1, %operator+=() supported (merging supported).</span>
<a name="l03850"></a>03850 <span class="comment">*/</span>
<a name="l03851"></a>03851 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> N&gt;
<a name="l03852"></a><a class="code" href="classvigra_1_1acc_1_1PowerSum.html">03852</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1PowerSum.html" title="Basic statistic. PowerSum&lt;N&gt; = .">PowerSum</a>
<a name="l03853"></a>03853 {
<a name="l03854"></a>03854   <span class="keyword">public</span>:
<a name="l03855"></a>03855     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l03856"></a>03856      
<a name="l03857"></a>03857     <span class="keyword">static</span> std::string name() 
<a name="l03858"></a>03858     { 
<a name="l03859"></a>03859         <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;PowerSum&lt;&quot;</span>) + <a class="code" href="namespacevigra.html#abefdd44c2db13a2b64f36c82d3647b82">asString</a>(N) + <span class="stringliteral">&quot;&gt;&quot;</span>;
<a name="l03860"></a>03860         <span class="comment">// static const std::string n = std::string(&quot;PowerSum&lt;&quot;) + asString(N) + &quot;&gt;&quot;;</span>
<a name="l03861"></a>03861         <span class="comment">// return n;</span>
<a name="l03862"></a>03862     }
<a name="l03863"></a>03863     
<a name="l03864"></a>03864     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l03865"></a>03865     <span class="keyword">struct </span>Impl
<a name="l03866"></a>03866     : <span class="keyword">public</span> SumBaseImpl&lt;BASE, U&gt;
<a name="l03867"></a>03867     {
<a name="l03868"></a>03868         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t)
<a name="l03869"></a>03869         {
<a name="l03870"></a>03870             <span class="keyword">using namespace </span>vigra::multi_math;            
<a name="l03871"></a>03871             this-&gt;value_ += pow(t, (<span class="keywordtype">int</span>)N);
<a name="l03872"></a>03872         }
<a name="l03873"></a>03873         
<a name="l03874"></a>03874         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l03875"></a>03875         {
<a name="l03876"></a>03876             <span class="keyword">using namespace </span>vigra::multi_math;            
<a name="l03877"></a>03877             this-&gt;value_ += weight*pow(t, (<span class="keywordtype">int</span>)N);
<a name="l03878"></a>03878         }
<a name="l03879"></a>03879     };
<a name="l03880"></a>03880 };
<a name="l03881"></a>03881 
<a name="l03882"></a>03882 <span class="keyword">template</span> &lt;&gt;
<a name="l03883"></a>03883 <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1AbsPowerSum.html" title="Basic statistic. AbsPowerSum&lt;N&gt; = .">AbsPowerSum</a>&lt;1&gt;
<a name="l03884"></a>03884 {
<a name="l03885"></a>03885   <span class="keyword">public</span>:
<a name="l03886"></a>03886     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;&gt;</a> Dependencies;
<a name="l03887"></a>03887      
<a name="l03888"></a>03888     <span class="keyword">static</span> std::string name() 
<a name="l03889"></a>03889     { 
<a name="l03890"></a>03890         <span class="keywordflow">return</span> <span class="stringliteral">&quot;AbsPowerSum&lt;1&gt;&quot;</span>;
<a name="l03891"></a>03891         <span class="comment">// static const std::string n(&quot;AbsPowerSum&lt;1&gt;&quot;);</span>
<a name="l03892"></a>03892         <span class="comment">// return n;</span>
<a name="l03893"></a>03893     }
<a name="l03894"></a>03894     
<a name="l03895"></a>03895     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l03896"></a>03896     <span class="keyword">struct </span>Impl
<a name="l03897"></a>03897     : <span class="keyword">public</span> SumBaseImpl&lt;BASE, U&gt;
<a name="l03898"></a>03898     {
<a name="l03899"></a>03899         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t)
<a name="l03900"></a>03900         {
<a name="l03901"></a>03901             <span class="keyword">using namespace </span>vigra::multi_math;            
<a name="l03902"></a>03902             this-&gt;value_ += <a class="code" href="group__FFTWComplexOperators.html#ga6f4ef274842b6153923f02a6cd264576" title="absolute value (= magnitude)">abs</a>(t);
<a name="l03903"></a>03903         }
<a name="l03904"></a>03904         
<a name="l03905"></a>03905         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l03906"></a>03906         {
<a name="l03907"></a>03907             <span class="keyword">using namespace </span>vigra::multi_math;            
<a name="l03908"></a>03908             this-&gt;value_ += weight*<a class="code" href="group__FFTWComplexOperators.html#ga6f4ef274842b6153923f02a6cd264576" title="absolute value (= magnitude)">abs</a>(t);
<a name="l03909"></a>03909         }
<a name="l03910"></a>03910     };
<a name="l03911"></a>03911 };
<a name="l03912"></a>03912 <span class="comment"></span>
<a name="l03913"></a>03913 <span class="comment">/** \brief Basic statistic. AbsPowerSum&lt;N&gt; =@f$ \sum_i |x_i|^N @f$</span>
<a name="l03914"></a>03914 <span class="comment"></span>
<a name="l03915"></a>03915 <span class="comment">    Works in pass 1, %operator+=() supported (merging supported).</span>
<a name="l03916"></a>03916 <span class="comment">*/</span>
<a name="l03917"></a>03917 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> N&gt;
<a name="l03918"></a><a class="code" href="classvigra_1_1acc_1_1AbsPowerSum.html">03918</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1AbsPowerSum.html" title="Basic statistic. AbsPowerSum&lt;N&gt; = .">AbsPowerSum</a>
<a name="l03919"></a>03919 {
<a name="l03920"></a>03920   <span class="keyword">public</span>:
<a name="l03921"></a>03921     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l03922"></a>03922      
<a name="l03923"></a>03923     <span class="keyword">static</span> std::string name() 
<a name="l03924"></a>03924     { 
<a name="l03925"></a>03925         <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;AbsPowerSum&lt;&quot;</span>) + <a class="code" href="namespacevigra.html#abefdd44c2db13a2b64f36c82d3647b82">asString</a>(N) + <span class="stringliteral">&quot;&gt;&quot;</span>;
<a name="l03926"></a>03926         <span class="comment">// static const std::string n = std::string(&quot;AbsPowerSum&lt;&quot;) + asString(N) + &quot;&gt;&quot;;</span>
<a name="l03927"></a>03927         <span class="comment">// return n;</span>
<a name="l03928"></a>03928     }
<a name="l03929"></a>03929     
<a name="l03930"></a>03930     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l03931"></a>03931     <span class="keyword">struct </span>Impl
<a name="l03932"></a>03932     : <span class="keyword">public</span> SumBaseImpl&lt;BASE, U&gt;
<a name="l03933"></a>03933     {
<a name="l03934"></a>03934         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t)
<a name="l03935"></a>03935         {
<a name="l03936"></a>03936             <span class="keyword">using namespace </span>vigra::multi_math;            
<a name="l03937"></a>03937             this-&gt;value_ += pow(<a class="code" href="group__FFTWComplexOperators.html#ga6f4ef274842b6153923f02a6cd264576" title="absolute value (= magnitude)">abs</a>(t), (<span class="keywordtype">int</span>)N);
<a name="l03938"></a>03938         }
<a name="l03939"></a>03939         
<a name="l03940"></a>03940         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l03941"></a>03941         {
<a name="l03942"></a>03942             <span class="keyword">using namespace </span>vigra::multi_math;            
<a name="l03943"></a>03943             this-&gt;value_ += weight*pow(<a class="code" href="group__FFTWComplexOperators.html#ga6f4ef274842b6153923f02a6cd264576" title="absolute value (= magnitude)">abs</a>(t), (<span class="keywordtype">int</span>)N);
<a name="l03944"></a>03944         }
<a name="l03945"></a>03945     };
<a name="l03946"></a>03946 };
<a name="l03947"></a>03947 
<a name="l03948"></a>03948 <span class="keyword">template</span> &lt;<span class="keyword">class</span> BASE, <span class="keyword">class</span> VALUE_TYPE, <span class="keyword">class</span> U&gt;
<a name="l03949"></a>03949 <span class="keyword">struct </span>CachedResultBase
<a name="l03950"></a>03950 : <span class="keyword">public</span> BASE
<a name="l03951"></a>03951 {
<a name="l03952"></a>03952     <span class="keyword">typedef</span> <span class="keyword">typename</span> AccumulatorResultTraits&lt;U&gt;::element_type  element_type;
<a name="l03953"></a>03953     <span class="keyword">typedef</span> VALUE_TYPE                                         value_type;
<a name="l03954"></a>03954     <span class="keyword">typedef</span> value_type <span class="keyword">const</span> &amp;                                 result_type;
<a name="l03955"></a>03955 
<a name="l03956"></a>03956     <span class="keyword">mutable</span> value_type value_;
<a name="l03957"></a>03957     
<a name="l03958"></a>03958     CachedResultBase()
<a name="l03959"></a>03959     : value_()  <span class="comment">// call default constructor explicitly to ensure zero initialization</span>
<a name="l03960"></a>03960     {}
<a name="l03961"></a>03961     
<a name="l03962"></a>03962     <span class="keywordtype">void</span> reset()
<a name="l03963"></a>03963     {
<a name="l03964"></a>03964         value_ = element_type();
<a name="l03965"></a>03965         this-&gt;setClean();
<a name="l03966"></a>03966     }
<a name="l03967"></a>03967 
<a name="l03968"></a>03968     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Shape&gt;
<a name="l03969"></a>03969     <span class="keywordtype">void</span> reshape(Shape <span class="keyword">const</span> &amp; s)
<a name="l03970"></a>03970     {
<a name="l03971"></a>03971         acc_detail::reshapeImpl(value_, s);
<a name="l03972"></a>03972     }
<a name="l03973"></a>03973 
<a name="l03974"></a>03974     <span class="keywordtype">void</span> <a class="code" href="group__FFTWComplexOperators.html#ga23c9113f38123caf2ae30a59a1a5cfc5" title="add-assignment">operator+=</a>(CachedResultBase <span class="keyword">const</span> &amp;)
<a name="l03975"></a>03975     {
<a name="l03976"></a>03976         this-&gt;setDirty();
<a name="l03977"></a>03977     }
<a name="l03978"></a>03978 
<a name="l03979"></a>03979     <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp;)
<a name="l03980"></a>03980     {
<a name="l03981"></a>03981         this-&gt;setDirty();
<a name="l03982"></a>03982     }
<a name="l03983"></a>03983     
<a name="l03984"></a>03984     <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp;, <span class="keywordtype">double</span>)
<a name="l03985"></a>03985     {
<a name="l03986"></a>03986          this-&gt;setDirty();
<a name="l03987"></a>03987     }
<a name="l03988"></a>03988 };
<a name="l03989"></a>03989 
<a name="l03990"></a>03990 <span class="comment">// cached Mean and Variance</span><span class="comment"></span>
<a name="l03991"></a>03991 <span class="comment">/** \brief Modifier. Divide statistic by Count:  DivideByCount&lt;TAG&gt; = TAG / Count .</span>
<a name="l03992"></a>03992 <span class="comment">*/</span>
<a name="l03993"></a>03993 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG&gt;
<a name="l03994"></a><a class="code" href="classvigra_1_1acc_1_1DivideByCount.html">03994</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1DivideByCount.html" title="Modifier. Divide statistic by Count: DivideByCount&lt;TAG&gt; = TAG / Count .">DivideByCount</a>
<a name="l03995"></a>03995 {
<a name="l03996"></a>03996   <span class="keyword">public</span>:
<a name="l03997"></a>03997     <span class="keyword">typedef</span> <span class="keyword">typename</span> StandardizeTag&lt;TAG&gt;::type TargetTag;
<a name="l03998"></a>03998     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;TargetTag, Count&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l03999"></a>03999   
<a name="l04000"></a>04000     <span class="keyword">static</span> std::string name() 
<a name="l04001"></a>04001     { 
<a name="l04002"></a>04002         <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;DivideByCount&lt;&quot;</span>) + TargetTag::name() + <span class="stringliteral">&quot; &gt;&quot;</span>;
<a name="l04003"></a>04003         <span class="comment">// static const std::string n = std::string(&quot;DivideByCount&lt;&quot;) + TargetTag::name() + &quot; &gt;&quot;;</span>
<a name="l04004"></a>04004         <span class="comment">// return n;</span>
<a name="l04005"></a>04005     }
<a name="l04006"></a>04006     
<a name="l04007"></a>04007     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l04008"></a>04008     <span class="keyword">struct </span>Impl
<a name="l04009"></a>04009     : <span class="keyword">public</span> CachedResultBase&lt;BASE, typename LookupDependency&lt;TargetTag, BASE&gt;::value_type, U&gt; 
<a name="l04010"></a>04010     {
<a name="l04011"></a>04011         <span class="keyword">typedef</span> <span class="keyword">typename</span> CachedResultBase&lt;BASE, typename LookupDependency&lt;TargetTag, BASE&gt;::value_type, U&gt;::result_type result_type;
<a name="l04012"></a>04012         
<a name="l04013"></a>04013         result_type operator()()<span class="keyword"> const</span>
<a name="l04014"></a>04014 <span class="keyword">        </span>{
<a name="l04015"></a>04015             <span class="keywordflow">if</span>(this-&gt;isDirty())
<a name="l04016"></a>04016             {
<a name="l04017"></a>04017                 <span class="keyword">using namespace </span>multi_math;
<a name="l04018"></a>04018                 this-&gt;value_ = getDependency&lt;TargetTag&gt;(*this) / getDependency&lt;Count&gt;(*this);
<a name="l04019"></a>04019                 this-&gt;setClean();
<a name="l04020"></a>04020             }
<a name="l04021"></a>04021             <span class="keywordflow">return</span> this-&gt;value_;
<a name="l04022"></a>04022         }
<a name="l04023"></a>04023     };
<a name="l04024"></a>04024 };
<a name="l04025"></a>04025 
<a name="l04026"></a>04026 <span class="comment">// UnbiasedVariance</span><span class="comment"></span>
<a name="l04027"></a>04027 <span class="comment">/** \brief Modifier. Divide statistics by Count-1:  DivideUnbiased&lt;TAG&gt; = TAG / (Count-1)</span>
<a name="l04028"></a>04028 <span class="comment">*/</span>
<a name="l04029"></a>04029 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG&gt;
<a name="l04030"></a><a class="code" href="classvigra_1_1acc_1_1DivideUnbiased.html">04030</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1DivideUnbiased.html" title="Modifier. Divide statistics by Count-1: DivideUnbiased&lt;TAG&gt; = TAG / (Count-1)">DivideUnbiased</a>
<a name="l04031"></a>04031 {
<a name="l04032"></a>04032   <span class="keyword">public</span>:
<a name="l04033"></a>04033     <span class="keyword">typedef</span> <span class="keyword">typename</span> StandardizeTag&lt;TAG&gt;::type TargetTag;
<a name="l04034"></a>04034     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;TargetTag, Count&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l04035"></a>04035       
<a name="l04036"></a>04036     <span class="keyword">static</span> std::string name() 
<a name="l04037"></a>04037     { 
<a name="l04038"></a>04038         <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;DivideUnbiased&lt;&quot;</span>) + TargetTag::name() + <span class="stringliteral">&quot; &gt;&quot;</span>;
<a name="l04039"></a>04039         <span class="comment">// static const std::string n = std::string(&quot;DivideUnbiased&lt;&quot;) + TargetTag::name() + &quot; &gt;&quot;;</span>
<a name="l04040"></a>04040         <span class="comment">// return n;</span>
<a name="l04041"></a>04041     }
<a name="l04042"></a>04042     
<a name="l04043"></a>04043     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l04044"></a>04044     <span class="keyword">struct </span>Impl
<a name="l04045"></a>04045     : <span class="keyword">public</span> BASE
<a name="l04046"></a>04046     {
<a name="l04047"></a>04047         <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupDependency&lt;TargetTag, BASE&gt;::value_type  value_type;
<a name="l04048"></a>04048         <span class="keyword">typedef</span> value_type                                       result_type;
<a name="l04049"></a>04049         
<a name="l04050"></a>04050         result_type operator()()<span class="keyword"> const</span>
<a name="l04051"></a>04051 <span class="keyword">        </span>{
<a name="l04052"></a>04052             <span class="keyword">using namespace </span>multi_math;
<a name="l04053"></a>04053             <span class="keywordflow">return</span> getDependency&lt;TargetTag&gt;(*this) / (getDependency&lt;Count&gt;(*this) - 1.0);
<a name="l04054"></a>04054         }
<a name="l04055"></a>04055     };
<a name="l04056"></a>04056 };
<a name="l04057"></a>04057 
<a name="l04058"></a>04058 <span class="comment">// RootMeanSquares and StdDev</span><span class="comment"></span>
<a name="l04059"></a>04059 <span class="comment">/** \brief Modifier. RootDivideByCount&lt;TAG&gt; = sqrt( TAG/Count )</span>
<a name="l04060"></a>04060 <span class="comment">*/</span>
<a name="l04061"></a>04061 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG&gt;
<a name="l04062"></a><a class="code" href="classvigra_1_1acc_1_1RootDivideByCount.html">04062</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1RootDivideByCount.html" title="Modifier. RootDivideByCount&lt;TAG&gt; = sqrt( TAG/Count )">RootDivideByCount</a>
<a name="l04063"></a>04063 {
<a name="l04064"></a>04064   <span class="keyword">public</span>:
<a name="l04065"></a>04065     <span class="keyword">typedef</span> <span class="keyword">typename</span> StandardizeTag&lt;DivideByCount&lt;TAG&gt; &gt;::type TargetTag;
<a name="l04066"></a>04066     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;TargetTag&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l04067"></a>04067     
<a name="l04068"></a>04068     <span class="keyword">static</span> std::string name() 
<a name="l04069"></a>04069     { 
<a name="l04070"></a>04070         <span class="keyword">typedef</span> <span class="keyword">typename</span> StandardizeTag&lt;TAG&gt;::type InnerTag;
<a name="l04071"></a>04071         <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;RootDivideByCount&lt;&quot;</span>) + InnerTag::name() + <span class="stringliteral">&quot; &gt;&quot;</span>;
<a name="l04072"></a>04072         <span class="comment">// static const std::string n = std::string(&quot;RootDivideByCount&lt;&quot;) + InnerTag::name() + &quot; &gt;&quot;;</span>
<a name="l04073"></a>04073         <span class="comment">// return n;</span>
<a name="l04074"></a>04074     }
<a name="l04075"></a>04075     
<a name="l04076"></a>04076     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l04077"></a>04077     <span class="keyword">struct </span>Impl
<a name="l04078"></a>04078     : <span class="keyword">public</span> BASE
<a name="l04079"></a>04079     {
<a name="l04080"></a>04080         <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupDependency&lt;TargetTag, BASE&gt;::value_type  value_type;
<a name="l04081"></a>04081         <span class="keyword">typedef</span> value_type                                       result_type;
<a name="l04082"></a>04082         
<a name="l04083"></a>04083         result_type operator()()<span class="keyword"> const</span>
<a name="l04084"></a>04084 <span class="keyword">        </span>{
<a name="l04085"></a>04085             <span class="keyword">using namespace </span>multi_math;
<a name="l04086"></a>04086             <span class="keywordflow">return</span> <a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">sqrt</a>(getDependency&lt;TargetTag&gt;(*<span class="keyword">this</span>));
<a name="l04087"></a>04087         }
<a name="l04088"></a>04088     };
<a name="l04089"></a>04089 };
<a name="l04090"></a>04090 
<a name="l04091"></a>04091 <span class="comment">// UnbiasedStdDev</span><span class="comment"></span>
<a name="l04092"></a>04092 <span class="comment">/** \brief Modifier. RootDivideUnbiased&lt;TAG&gt; = sqrt( TAG / (Count-1) )</span>
<a name="l04093"></a>04093 <span class="comment">*/</span>
<a name="l04094"></a>04094 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TAG&gt;
<a name="l04095"></a><a class="code" href="classvigra_1_1acc_1_1RootDivideUnbiased.html">04095</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1RootDivideUnbiased.html" title="Modifier. RootDivideUnbiased&lt;TAG&gt; = sqrt( TAG / (Count-1) )">RootDivideUnbiased</a>
<a name="l04096"></a>04096 {
<a name="l04097"></a>04097   <span class="keyword">public</span>:
<a name="l04098"></a>04098     <span class="keyword">typedef</span> <span class="keyword">typename</span> StandardizeTag&lt;DivideUnbiased&lt;TAG&gt; &gt;::type TargetTag;
<a name="l04099"></a>04099     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;TargetTag&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l04100"></a>04100     
<a name="l04101"></a>04101     <span class="keyword">static</span> std::string name() 
<a name="l04102"></a>04102     { 
<a name="l04103"></a>04103         <span class="keyword">typedef</span> <span class="keyword">typename</span> StandardizeTag&lt;TAG&gt;::type InnerTag;
<a name="l04104"></a>04104         <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;RootDivideUnbiased&lt;&quot;</span>) + InnerTag::name() + <span class="stringliteral">&quot; &gt;&quot;</span>;
<a name="l04105"></a>04105         <span class="comment">// static const std::string n = std::string(&quot;RootDivideUnbiased&lt;&quot;) + InnerTag::name() + &quot; &gt;&quot;;</span>
<a name="l04106"></a>04106         <span class="comment">// return n;</span>
<a name="l04107"></a>04107     }
<a name="l04108"></a>04108     
<a name="l04109"></a>04109     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l04110"></a>04110     <span class="keyword">struct </span>Impl
<a name="l04111"></a>04111     : <span class="keyword">public</span> BASE
<a name="l04112"></a>04112     {
<a name="l04113"></a>04113         <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupDependency&lt;TargetTag, BASE&gt;::value_type  value_type;
<a name="l04114"></a>04114         <span class="keyword">typedef</span> value_type                                       result_type;
<a name="l04115"></a>04115         
<a name="l04116"></a>04116         result_type operator()()<span class="keyword"> const</span>
<a name="l04117"></a>04117 <span class="keyword">        </span>{
<a name="l04118"></a>04118             <span class="keyword">using namespace </span>multi_math;
<a name="l04119"></a>04119             <span class="keywordflow">return</span> <a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">sqrt</a>(getDependency&lt;TargetTag&gt;(*<span class="keyword">this</span>));
<a name="l04120"></a>04120         }
<a name="l04121"></a>04121     };
<a name="l04122"></a>04122 };
<a name="l04123"></a>04123 <span class="comment"></span>
<a name="l04124"></a>04124 <span class="comment">/** \brief Spezialization: works in pass 1, %operator+=() supported (merging supported).</span>
<a name="l04125"></a>04125 <span class="comment">*/</span>
<a name="l04126"></a>04126 <span class="keyword">template</span> &lt;&gt;
<a name="l04127"></a><a class="code" href="classvigra_1_1acc_1_1Central_3_01PowerSum_3_012_01_4_01_4.html">04127</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1Central.html" title="Modifier. Substract mean before computing statistic.">Central</a>&lt;<a class="code" href="classvigra_1_1acc_1_1PowerSum.html" title="Basic statistic. PowerSum&lt;N&gt; = .">PowerSum</a>&lt;2&gt; &gt;
<a name="l04128"></a>04128 {
<a name="l04129"></a>04129   <span class="keyword">public</span>:
<a name="l04130"></a>04130     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;Mean, Count&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l04131"></a>04131      
<a name="l04132"></a>04132     <span class="keyword">static</span> std::string name() 
<a name="l04133"></a>04133     { 
<a name="l04134"></a>04134         <span class="keywordflow">return</span> <span class="stringliteral">&quot;Central&lt;PowerSum&lt;2&gt; &gt;&quot;</span>;
<a name="l04135"></a>04135         <span class="comment">// static const std::string n(&quot;Central&lt;PowerSum&lt;2&gt; &gt;&quot;);</span>
<a name="l04136"></a>04136         <span class="comment">// return n;</span>
<a name="l04137"></a>04137     }
<a name="l04138"></a>04138     
<a name="l04139"></a>04139     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l04140"></a>04140     <span class="keyword">struct </span>Impl
<a name="l04141"></a>04141     : <span class="keyword">public</span> SumBaseImpl&lt;BASE, U&gt;
<a name="l04142"></a>04142     {
<a name="l04143"></a>04143         <span class="keywordtype">void</span> <a class="code" href="group__FFTWComplexOperators.html#ga23c9113f38123caf2ae30a59a1a5cfc5" title="add-assignment">operator+=</a>(Impl <span class="keyword">const</span> &amp; o)
<a name="l04144"></a>04144         {
<a name="l04145"></a>04145             <span class="keyword">using namespace </span>vigra::multi_math;
<a name="l04146"></a>04146             <span class="keywordtype">double</span> n1 = getDependency&lt;Count&gt;(*this), n2 = getDependency&lt;Count&gt;(o);
<a name="l04147"></a>04147             <span class="keywordflow">if</span>(n1 == 0.0)
<a name="l04148"></a>04148             {
<a name="l04149"></a>04149                 this-&gt;value_ = o.value_;
<a name="l04150"></a>04150             }
<a name="l04151"></a>04151             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(n2 != 0.0)
<a name="l04152"></a>04152             {
<a name="l04153"></a>04153                 this-&gt;value_ += o.value_ + n1 * n2 / (n1 + n2) * <a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(getDependency&lt;Mean&gt;(*<span class="keyword">this</span>) - getDependency&lt;Mean&gt;(o));
<a name="l04154"></a>04154             }
<a name="l04155"></a>04155         }
<a name="l04156"></a>04156     
<a name="l04157"></a>04157         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t)
<a name="l04158"></a>04158         {
<a name="l04159"></a>04159             <span class="keywordtype">double</span> n = getDependency&lt;Count&gt;(*this);
<a name="l04160"></a>04160             <span class="keywordflow">if</span>(n &gt; 1.0)
<a name="l04161"></a>04161             {
<a name="l04162"></a>04162                 <span class="keyword">using namespace </span>vigra::multi_math;
<a name="l04163"></a>04163                 this-&gt;value_ += n / (n - 1.0) * <a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(getDependency&lt;Mean&gt;(*<span class="keyword">this</span>) - t);
<a name="l04164"></a>04164             }
<a name="l04165"></a>04165         }
<a name="l04166"></a>04166         
<a name="l04167"></a>04167         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l04168"></a>04168         {
<a name="l04169"></a>04169             <span class="keywordtype">double</span> n = getDependency&lt;Count&gt;(*this);
<a name="l04170"></a>04170             <span class="keywordflow">if</span>(n &gt; weight)
<a name="l04171"></a>04171             {
<a name="l04172"></a>04172                 <span class="keyword">using namespace </span>vigra::multi_math;
<a name="l04173"></a>04173                 this-&gt;value_ += n / (n - weight) * <a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(getDependency&lt;Mean&gt;(*<span class="keyword">this</span>) - t);
<a name="l04174"></a>04174             }
<a name="l04175"></a>04175         }
<a name="l04176"></a>04176     };
<a name="l04177"></a>04177 };
<a name="l04178"></a>04178 <span class="comment"></span>
<a name="l04179"></a>04179 <span class="comment">/** \brief Specialization: works in pass 2, %operator+=() supported (merging supported).</span>
<a name="l04180"></a>04180 <span class="comment">*/</span>
<a name="l04181"></a>04181 <span class="keyword">template</span> &lt;&gt;
<a name="l04182"></a><a class="code" href="classvigra_1_1acc_1_1Central_3_01PowerSum_3_013_01_4_01_4.html">04182</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1Central.html" title="Modifier. Substract mean before computing statistic.">Central</a>&lt;<a class="code" href="classvigra_1_1acc_1_1PowerSum.html" title="Basic statistic. PowerSum&lt;N&gt; = .">PowerSum</a>&lt;3&gt; &gt;
<a name="l04183"></a>04183 {
<a name="l04184"></a>04184   <span class="keyword">public</span>:
<a name="l04185"></a>04185     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;Centralize, Count, Mean, Central&lt;PowerSum&lt;2&gt;</a> &gt; &gt; <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l04186"></a>04186      
<a name="l04187"></a>04187     <span class="keyword">static</span> std::string name() 
<a name="l04188"></a>04188     { 
<a name="l04189"></a>04189         <span class="keywordflow">return</span> <span class="stringliteral">&quot;Central&lt;PowerSum&lt;3&gt; &gt;&quot;</span>;
<a name="l04190"></a>04190         <span class="comment">// static const std::string n(&quot;Central&lt;PowerSum&lt;3&gt; &gt;&quot;);</span>
<a name="l04191"></a>04191         <span class="comment">// return n;</span>
<a name="l04192"></a>04192     }
<a name="l04193"></a>04193     
<a name="l04194"></a>04194     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l04195"></a>04195     <span class="keyword">struct </span>Impl
<a name="l04196"></a>04196     : <span class="keyword">public</span> SumBaseImpl&lt;BASE, U&gt;
<a name="l04197"></a>04197     {
<a name="l04198"></a>04198         <span class="keyword">typedef</span> <span class="keyword">typename</span> SumBaseImpl&lt;BASE, U&gt;::value_type value_type;
<a name="l04199"></a>04199 
<a name="l04200"></a>04200         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> workInPass = 2;
<a name="l04201"></a>04201         
<a name="l04202"></a>04202         <span class="keywordtype">void</span> <a class="code" href="group__FFTWComplexOperators.html#ga23c9113f38123caf2ae30a59a1a5cfc5" title="add-assignment">operator+=</a>(Impl <span class="keyword">const</span> &amp; o)
<a name="l04203"></a>04203         {
<a name="l04204"></a>04204             <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1acc_1_1Central.html" title="Modifier. Substract mean before computing statistic.">Central&lt;PowerSum&lt;2&gt;</a> &gt; Sum2Tag;
<a name="l04205"></a>04205             
<a name="l04206"></a>04206             <span class="keyword">using namespace </span>vigra::multi_math;
<a name="l04207"></a>04207             <span class="keywordtype">double</span> n1 = getDependency&lt;Count&gt;(*this), n2 = getDependency&lt;Count&gt;(o);
<a name="l04208"></a>04208             <span class="keywordflow">if</span>(n1 == 0.0)
<a name="l04209"></a>04209             {
<a name="l04210"></a>04210                 this-&gt;value_ = o.value_;
<a name="l04211"></a>04211             }
<a name="l04212"></a>04212             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(n2 != 0.0)
<a name="l04213"></a>04213             {
<a name="l04214"></a>04214                 <span class="keywordtype">double</span> n = n1 + n2;
<a name="l04215"></a>04215                 <span class="keywordtype">double</span> weight = n1 * n2 * (n1 - n2) / <a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(n);
<a name="l04216"></a>04216                 value_type delta = getDependency&lt;Mean&gt;(o) - getDependency&lt;Mean&gt;(*<span class="keyword">this</span>);
<a name="l04217"></a>04217                 this-&gt;value_ += o.value_ + weight * pow(delta, 3) +
<a name="l04218"></a>04218                                3.0 / n * delta * (n1 * getDependency&lt;Sum2Tag&gt;(o) - n2 * getDependency&lt;Sum2Tag&gt;(*<span class="keyword">this</span>));
<a name="l04219"></a>04219             }
<a name="l04220"></a>04220         }
<a name="l04221"></a>04221     
<a name="l04222"></a>04222         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t)
<a name="l04223"></a>04223         {
<a name="l04224"></a>04224             <span class="keyword">using namespace </span>vigra::multi_math;            
<a name="l04225"></a>04225             this-&gt;value_ += pow(getDependency&lt;Centralize&gt;(*<span class="keyword">this</span>), 3);
<a name="l04226"></a>04226         }
<a name="l04227"></a>04227         
<a name="l04228"></a>04228         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l04229"></a>04229         {
<a name="l04230"></a>04230             <span class="keyword">using namespace </span>vigra::multi_math;            
<a name="l04231"></a>04231             this-&gt;value_ += weight*pow(getDependency&lt;Centralize&gt;(*<span class="keyword">this</span>), 3);
<a name="l04232"></a>04232         }
<a name="l04233"></a>04233     };
<a name="l04234"></a>04234 };<span class="comment"></span>
<a name="l04235"></a>04235 <span class="comment">/** \brief Specialization: works in pass 2, %operator+=() supported (merging supported).</span>
<a name="l04236"></a>04236 <span class="comment">*/</span>
<a name="l04237"></a>04237 <span class="keyword">template</span> &lt;&gt;
<a name="l04238"></a><a class="code" href="classvigra_1_1acc_1_1Central_3_01PowerSum_3_014_01_4_01_4.html">04238</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1Central.html" title="Modifier. Substract mean before computing statistic.">Central</a>&lt;<a class="code" href="classvigra_1_1acc_1_1PowerSum.html" title="Basic statistic. PowerSum&lt;N&gt; = .">PowerSum</a>&lt;4&gt; &gt;
<a name="l04239"></a>04239 {
<a name="l04240"></a>04240   <span class="keyword">public</span>:
<a name="l04241"></a>04241     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;Centralize, Central&lt;PowerSum&lt;3&gt;</a> &gt; &gt; <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l04242"></a>04242      
<a name="l04243"></a>04243     <span class="keyword">static</span> std::string name() 
<a name="l04244"></a>04244     { 
<a name="l04245"></a>04245         <span class="keywordflow">return</span> <span class="stringliteral">&quot;Central&lt;PowerSum&lt;4&gt; &gt;&quot;</span>;
<a name="l04246"></a>04246         <span class="comment">// static const std::string n(&quot;Central&lt;PowerSum&lt;4&gt; &gt;&quot;);</span>
<a name="l04247"></a>04247         <span class="comment">// return n;</span>
<a name="l04248"></a>04248     }
<a name="l04249"></a>04249     
<a name="l04250"></a>04250     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l04251"></a>04251     <span class="keyword">struct </span>Impl
<a name="l04252"></a>04252     : <span class="keyword">public</span> SumBaseImpl&lt;BASE, U&gt;
<a name="l04253"></a>04253     {
<a name="l04254"></a>04254         <span class="keyword">typedef</span> <span class="keyword">typename</span> SumBaseImpl&lt;BASE, U&gt;::value_type value_type;
<a name="l04255"></a>04255 
<a name="l04256"></a>04256         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> workInPass = 2;
<a name="l04257"></a>04257         
<a name="l04258"></a>04258         <span class="keywordtype">void</span> <a class="code" href="group__FFTWComplexOperators.html#ga23c9113f38123caf2ae30a59a1a5cfc5" title="add-assignment">operator+=</a>(Impl <span class="keyword">const</span> &amp; o)
<a name="l04259"></a>04259         {
<a name="l04260"></a>04260             <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1acc_1_1Central.html" title="Modifier. Substract mean before computing statistic.">Central&lt;PowerSum&lt;2&gt;</a> &gt; Sum2Tag;
<a name="l04261"></a>04261             <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1acc_1_1Central.html" title="Modifier. Substract mean before computing statistic.">Central&lt;PowerSum&lt;3&gt;</a> &gt; Sum3Tag;
<a name="l04262"></a>04262 
<a name="l04263"></a>04263             <span class="keyword">using namespace </span>vigra::multi_math;
<a name="l04264"></a>04264             <span class="keywordtype">double</span> n1 = getDependency&lt;Count&gt;(*this), n2 = getDependency&lt;Count&gt;(o);
<a name="l04265"></a>04265             <span class="keywordflow">if</span>(n1 == 0.0)
<a name="l04266"></a>04266             {
<a name="l04267"></a>04267                 this-&gt;value_ = o.value_;
<a name="l04268"></a>04268             }
<a name="l04269"></a>04269             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(n2 != 0.0)
<a name="l04270"></a>04270             {
<a name="l04271"></a>04271                 <span class="keywordtype">double</span> n = n1 + n2;
<a name="l04272"></a>04272                 <span class="keywordtype">double</span> n1_2 = <a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(n1);
<a name="l04273"></a>04273                 <span class="keywordtype">double</span> n2_2 = <a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(n2);
<a name="l04274"></a>04274                 <span class="keywordtype">double</span> n_2 = <a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(n);
<a name="l04275"></a>04275                 <span class="keywordtype">double</span> weight = n1 * n2 * (n1_2 - n1*n2 + n2_2) / n_2 / n;
<a name="l04276"></a>04276                 value_type delta = getDependency&lt;Mean&gt;(o) - getDependency&lt;Mean&gt;(*<span class="keyword">this</span>);
<a name="l04277"></a>04277                 this-&gt;value_ += o.value_ + weight * pow(delta, 4) +
<a name="l04278"></a>04278                               6.0 / n_2 * <a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(delta) * (n1_2 * getDependency&lt;Sum2Tag&gt;(o) + n2_2 * getDependency&lt;Sum2Tag&gt;(*<span class="keyword">this</span>)) +
<a name="l04279"></a>04279                               4.0 / n * delta * (n1 * getDependency&lt;Sum3Tag&gt;(o) - n2 * getDependency&lt;Sum3Tag&gt;(*this));
<a name="l04280"></a>04280             }
<a name="l04281"></a>04281         }
<a name="l04282"></a>04282     
<a name="l04283"></a>04283         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t)
<a name="l04284"></a>04284         {
<a name="l04285"></a>04285             <span class="keyword">using namespace </span>vigra::multi_math;            
<a name="l04286"></a>04286             this-&gt;value_ += pow(getDependency&lt;Centralize&gt;(*<span class="keyword">this</span>), 4);
<a name="l04287"></a>04287         }
<a name="l04288"></a>04288         
<a name="l04289"></a>04289         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l04290"></a>04290         {
<a name="l04291"></a>04291             <span class="keyword">using namespace </span>vigra::multi_math;            
<a name="l04292"></a>04292             this-&gt;value_ += weight*pow(getDependency&lt;Centralize&gt;(*<span class="keyword">this</span>), 4);
<a name="l04293"></a>04293         }
<a name="l04294"></a>04294     };
<a name="l04295"></a>04295 };
<a name="l04296"></a>04296 <span class="comment"></span>
<a name="l04297"></a>04297 <span class="comment">/** \brief Basic statistic. Skewness. </span>
<a name="l04298"></a>04298 <span class="comment"></span>
<a name="l04299"></a>04299 <span class="comment">    %Skewness =@f$ \frac{ \frac{1}{n}\sum_i (x_i-\hat{x})^3 }{ (\frac{1}{n}\sum_i (x_i-\hat{x})^2)^{3/2} } @f$ .</span>
<a name="l04300"></a>04300 <span class="comment">    Works in pass 2, %operator+=() supported (merging supported).</span>
<a name="l04301"></a>04301 <span class="comment">*/</span>
<a name="l04302"></a><a class="code" href="classvigra_1_1acc_1_1Skewness.html">04302</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1Skewness.html" title="Basic statistic. Skewness.">Skewness</a>
<a name="l04303"></a>04303 {
<a name="l04304"></a>04304   <span class="keyword">public</span>:
<a name="l04305"></a>04305     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;Central&lt;PowerSum&lt;2&gt;</a> &gt;, <a class="code" href="classvigra_1_1acc_1_1Central.html" title="Modifier. Substract mean before computing statistic.">Central&lt;PowerSum&lt;3&gt;</a> &gt; &gt; <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l04306"></a>04306     
<a name="l04307"></a>04307     <span class="keyword">static</span> std::string name() 
<a name="l04308"></a>04308     { 
<a name="l04309"></a>04309         <span class="keywordflow">return</span> <span class="stringliteral">&quot;Skewness&quot;</span>;
<a name="l04310"></a>04310         <span class="comment">// static const std::string n(&quot;Skewness&quot;);</span>
<a name="l04311"></a>04311         <span class="comment">// return n;</span>
<a name="l04312"></a>04312     }
<a name="l04313"></a>04313     
<a name="l04314"></a>04314     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l04315"></a>04315     <span class="keyword">struct </span>Impl
<a name="l04316"></a>04316     : <span class="keyword">public</span> BASE
<a name="l04317"></a>04317     {
<a name="l04318"></a>04318         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> workInPass = 2;
<a name="l04319"></a>04319         
<a name="l04320"></a>04320         <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupDependency&lt;Central&lt;PowerSum&lt;3&gt; &gt;, BASE&gt;::value_type   value_type;
<a name="l04321"></a>04321         <span class="keyword">typedef</span> value_type                                                    result_type;
<a name="l04322"></a>04322 
<a name="l04323"></a>04323         result_type operator()()<span class="keyword"> const</span>
<a name="l04324"></a>04324 <span class="keyword">        </span>{
<a name="l04325"></a>04325             <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1acc_1_1Central.html" title="Modifier. Substract mean before computing statistic.">Central&lt;PowerSum&lt;3&gt;</a> &gt; Sum3;
<a name="l04326"></a>04326             <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1acc_1_1Central.html" title="Modifier. Substract mean before computing statistic.">Central&lt;PowerSum&lt;2&gt;</a> &gt; Sum2;
<a name="l04327"></a>04327         
<a name="l04328"></a>04328                         <span class="keyword">using namespace </span>multi_math;
<a name="l04329"></a>04329             <span class="keywordflow">return</span> <a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">sqrt</a>(getDependency&lt;Count&gt;(*<span class="keyword">this</span>)) * getDependency&lt;Sum3&gt;(*this) / pow(getDependency&lt;Sum2&gt;(*<span class="keyword">this</span>), 1.5);
<a name="l04330"></a>04330         }
<a name="l04331"></a>04331     };
<a name="l04332"></a>04332 };
<a name="l04333"></a>04333 <span class="comment"></span>
<a name="l04334"></a>04334 <span class="comment">/** \brief Basic statistic. Unbiased Skewness.</span>
<a name="l04335"></a>04335 <span class="comment"></span>
<a name="l04336"></a>04336 <span class="comment">    Works in pass 2, %operator+=() supported (merging supported).</span>
<a name="l04337"></a>04337 <span class="comment">*/</span>
<a name="l04338"></a><a class="code" href="classvigra_1_1acc_1_1UnbiasedSkewness.html">04338</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1UnbiasedSkewness.html" title="Basic statistic. Unbiased Skewness.">UnbiasedSkewness</a>
<a name="l04339"></a>04339 {
<a name="l04340"></a>04340   <span class="keyword">public</span>:
<a name="l04341"></a>04341     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;Skewness&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l04342"></a>04342     
<a name="l04343"></a>04343     <span class="keyword">static</span> std::string name() 
<a name="l04344"></a>04344     { 
<a name="l04345"></a>04345         <span class="keywordflow">return</span> <span class="stringliteral">&quot;UnbiasedSkewness&quot;</span>;
<a name="l04346"></a>04346         <span class="comment">// static const std::string n(&quot;UnbiasedSkewness&quot;);</span>
<a name="l04347"></a>04347         <span class="comment">// return n;</span>
<a name="l04348"></a>04348     }
<a name="l04349"></a>04349     
<a name="l04350"></a>04350     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l04351"></a>04351     <span class="keyword">struct </span>Impl
<a name="l04352"></a>04352     : <span class="keyword">public</span> BASE
<a name="l04353"></a>04353     {
<a name="l04354"></a>04354         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> workInPass = 2;
<a name="l04355"></a>04355         
<a name="l04356"></a>04356         <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupDependency&lt;Central&lt;PowerSum&lt;3&gt; &gt;, BASE&gt;::value_type   value_type;
<a name="l04357"></a>04357         <span class="keyword">typedef</span> value_type                                                    result_type;
<a name="l04358"></a>04358 
<a name="l04359"></a>04359         result_type operator()()<span class="keyword"> const</span>
<a name="l04360"></a>04360 <span class="keyword">        </span>{
<a name="l04361"></a>04361                         <span class="keyword">using namespace </span>multi_math;
<a name="l04362"></a>04362             <span class="keywordtype">double</span> n = getDependency&lt;Count&gt;(*this);
<a name="l04363"></a>04363             <span class="keywordflow">return</span> <a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">sqrt</a>(n*(n-1.0)) / (n - 2.0) * getDependency&lt;Skewness&gt;(*this);
<a name="l04364"></a>04364         }
<a name="l04365"></a>04365     };
<a name="l04366"></a>04366 };
<a name="l04367"></a>04367 <span class="comment"></span>
<a name="l04368"></a>04368 <span class="comment">/** \brief Basic statistic. Kurtosis. </span>
<a name="l04369"></a>04369 <span class="comment"></span>
<a name="l04370"></a>04370 <span class="comment">    %Kurtosis = @f$ \frac{ \frac{1}{n}\sum_i (x_i-\bar{x})^4 }{</span>
<a name="l04371"></a>04371 <span class="comment">    (\frac{1}{n} \sum_i(x_i-\bar{x})^2)^2 } - 3 @f$ . </span>
<a name="l04372"></a>04372 <span class="comment">    Works in pass 2, %operator+=() supported (merging supported).</span>
<a name="l04373"></a>04373 <span class="comment">*/</span>
<a name="l04374"></a><a class="code" href="classvigra_1_1acc_1_1Kurtosis.html">04374</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1Kurtosis.html" title="Basic statistic. Kurtosis.">Kurtosis</a>
<a name="l04375"></a>04375 {
<a name="l04376"></a>04376   <span class="keyword">public</span>:
<a name="l04377"></a>04377     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;Central&lt;PowerSum&lt;2&gt;</a> &gt;, <a class="code" href="classvigra_1_1acc_1_1Central.html" title="Modifier. Substract mean before computing statistic.">Central&lt;PowerSum&lt;4&gt;</a> &gt; &gt; <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l04378"></a>04378     
<a name="l04379"></a>04379     <span class="keyword">static</span> std::string name() 
<a name="l04380"></a>04380     { 
<a name="l04381"></a>04381         <span class="keywordflow">return</span> <span class="stringliteral">&quot;Kurtosis&quot;</span>;
<a name="l04382"></a>04382         <span class="comment">// static const std::string n(&quot;Kurtosis&quot;);</span>
<a name="l04383"></a>04383         <span class="comment">// return n;</span>
<a name="l04384"></a>04384     }
<a name="l04385"></a>04385     
<a name="l04386"></a>04386     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l04387"></a>04387     <span class="keyword">struct </span>Impl
<a name="l04388"></a>04388     : <span class="keyword">public</span> BASE
<a name="l04389"></a>04389     {
<a name="l04390"></a>04390         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> workInPass = 2;
<a name="l04391"></a>04391         
<a name="l04392"></a>04392         <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupDependency&lt;Central&lt;PowerSum&lt;4&gt; &gt;, BASE&gt;::value_type value_type;
<a name="l04393"></a>04393         <span class="keyword">typedef</span> value_type                                                  result_type;
<a name="l04394"></a>04394 
<a name="l04395"></a>04395         result_type operator()()<span class="keyword"> const</span>
<a name="l04396"></a>04396 <span class="keyword">        </span>{
<a name="l04397"></a>04397             <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1acc_1_1Central.html" title="Modifier. Substract mean before computing statistic.">Central&lt;PowerSum&lt;4&gt;</a> &gt; Sum4;
<a name="l04398"></a>04398             <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1acc_1_1Central.html" title="Modifier. Substract mean before computing statistic.">Central&lt;PowerSum&lt;2&gt;</a> &gt; Sum2;
<a name="l04399"></a>04399         
<a name="l04400"></a>04400                         <span class="keyword">using namespace </span>multi_math;
<a name="l04401"></a>04401             <span class="keywordflow">return</span> getDependency&lt;Count&gt;(*this) * getDependency&lt;Sum4&gt;(*this) / <a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(getDependency&lt;Sum2&gt;(*<span class="keyword">this</span>)) - value_type(3.0);
<a name="l04402"></a>04402         }
<a name="l04403"></a>04403     };
<a name="l04404"></a>04404 };
<a name="l04405"></a>04405 <span class="comment"></span>
<a name="l04406"></a>04406 <span class="comment">/** \brief Basic statistic. Unbiased Kurtosis.</span>
<a name="l04407"></a>04407 <span class="comment"></span>
<a name="l04408"></a>04408 <span class="comment">    Works in pass 2, %operator+=() supported (merging supported).</span>
<a name="l04409"></a>04409 <span class="comment">*/</span>
<a name="l04410"></a><a class="code" href="classvigra_1_1acc_1_1UnbiasedKurtosis.html">04410</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1UnbiasedKurtosis.html" title="Basic statistic. Unbiased Kurtosis.">UnbiasedKurtosis</a>
<a name="l04411"></a>04411 {
<a name="l04412"></a>04412   <span class="keyword">public</span>:
<a name="l04413"></a>04413     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;Kurtosis&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l04414"></a>04414     
<a name="l04415"></a>04415     <span class="keyword">static</span> std::string name() 
<a name="l04416"></a>04416     { 
<a name="l04417"></a>04417         <span class="keywordflow">return</span> <span class="stringliteral">&quot;UnbiasedKurtosis&quot;</span>;
<a name="l04418"></a>04418         <span class="comment">// static const std::string n(&quot;UnbiasedKurtosis&quot;);</span>
<a name="l04419"></a>04419         <span class="comment">// return n;</span>
<a name="l04420"></a>04420     }
<a name="l04421"></a>04421     
<a name="l04422"></a>04422     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l04423"></a>04423     <span class="keyword">struct </span>Impl
<a name="l04424"></a>04424     : <span class="keyword">public</span> BASE
<a name="l04425"></a>04425     {
<a name="l04426"></a>04426         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> workInPass = 2;
<a name="l04427"></a>04427         
<a name="l04428"></a>04428         <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupDependency&lt;Central&lt;PowerSum&lt;4&gt; &gt;, BASE&gt;::value_type value_type;
<a name="l04429"></a>04429         <span class="keyword">typedef</span> value_type                                                  result_type;
<a name="l04430"></a>04430 
<a name="l04431"></a>04431         result_type operator()()<span class="keyword"> const</span>
<a name="l04432"></a>04432 <span class="keyword">        </span>{
<a name="l04433"></a>04433                         <span class="keyword">using namespace </span>multi_math;
<a name="l04434"></a>04434             <span class="keywordtype">double</span> n = getDependency&lt;Count&gt;(*this);
<a name="l04435"></a>04435             <span class="keywordflow">return</span> (n-1.0)/((n-2.0)*(n-3.0))*((n+1.0)*getDependency&lt;Kurtosis&gt;(*this) + value_type(6.0));
<a name="l04436"></a>04436         }
<a name="l04437"></a>04437     };
<a name="l04438"></a>04438 };
<a name="l04439"></a>04439 
<a name="l04440"></a>04440 <span class="keyword">namespace </span>acc_detail {
<a name="l04441"></a>04441 
<a name="l04442"></a>04442 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Scatter, <span class="keyword">class</span> Sum&gt;
<a name="l04443"></a>04443 <span class="keywordtype">void</span> updateFlatScatterMatrix(Scatter &amp; sc, <a class="code" href="namespacevigra_1_1acc.html#a18abd27947f0ce9c0bd554853cd909c6" title="Alias. Sum.">Sum</a> <span class="keyword">const</span> &amp; s, <span class="keywordtype">double</span> w)
<a name="l04444"></a>04444 {
<a name="l04445"></a>04445     <span class="keywordtype">int</span> size = s.size();
<a name="l04446"></a>04446     <span class="keywordflow">for</span>(<a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a> j=0, k=0; j&lt;size; ++j)
<a name="l04447"></a>04447         <span class="keywordflow">for</span>(<a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a> i=j; i&lt;size; ++i, ++k)
<a name="l04448"></a>04448             sc[k] += w*s[i]*s[j];
<a name="l04449"></a>04449 }
<a name="l04450"></a>04450 
<a name="l04451"></a>04451 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Sum&gt;
<a name="l04452"></a>04452 <span class="keywordtype">void</span> updateFlatScatterMatrix(<span class="keywordtype">double</span> &amp; sc, <a class="code" href="namespacevigra_1_1acc.html#a18abd27947f0ce9c0bd554853cd909c6" title="Alias. Sum.">Sum</a> <span class="keyword">const</span> &amp; s, <span class="keywordtype">double</span> w)
<a name="l04453"></a>04453 {
<a name="l04454"></a>04454     sc += w*s*s;
<a name="l04455"></a>04455 }
<a name="l04456"></a>04456 
<a name="l04457"></a>04457 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Cov, <span class="keyword">class</span> Scatter&gt;
<a name="l04458"></a>04458 <span class="keywordtype">void</span> flatScatterMatrixToScatterMatrix(Cov &amp; cov, Scatter <span class="keyword">const</span> &amp; sc)
<a name="l04459"></a>04459 {
<a name="l04460"></a>04460     <span class="keywordtype">int</span> size = cov.shape(0), k=0;
<a name="l04461"></a>04461     <span class="keywordflow">for</span>(<a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a> j=0; j&lt;size; ++j)
<a name="l04462"></a>04462     {
<a name="l04463"></a>04463         cov(j,j) = sc[k++];
<a name="l04464"></a>04464         <span class="keywordflow">for</span>(<a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a> i=j+1; i&lt;size; ++i)
<a name="l04465"></a>04465         {
<a name="l04466"></a>04466             cov(i,j) = sc[k++];
<a name="l04467"></a>04467             cov(j,i) = cov(i,j);
<a name="l04468"></a>04468         }
<a name="l04469"></a>04469     }
<a name="l04470"></a>04470 }
<a name="l04471"></a>04471 
<a name="l04472"></a>04472 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Scatter&gt;
<a name="l04473"></a>04473 <span class="keywordtype">void</span> flatScatterMatrixToScatterMatrix(<span class="keywordtype">double</span> &amp; cov, Scatter <span class="keyword">const</span> &amp; sc)
<a name="l04474"></a>04474 {
<a name="l04475"></a>04475     cov = sc;
<a name="l04476"></a>04476 }
<a name="l04477"></a>04477 
<a name="l04478"></a>04478 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Cov, <span class="keyword">class</span> Scatter&gt;
<a name="l04479"></a>04479 <span class="keywordtype">void</span> flatScatterMatrixToCovariance(Cov &amp; cov, Scatter <span class="keyword">const</span> &amp; sc, <span class="keywordtype">double</span> n)
<a name="l04480"></a>04480 {
<a name="l04481"></a>04481     <span class="keywordtype">int</span> size = cov.shape(0), k=0;
<a name="l04482"></a>04482     <span class="keywordflow">for</span>(<a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a> j=0; j&lt;size; ++j)
<a name="l04483"></a>04483     {
<a name="l04484"></a>04484         cov(j,j) = sc[k++] / n;
<a name="l04485"></a>04485         <span class="keywordflow">for</span>(<a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a> i=j+1; i&lt;size; ++i)
<a name="l04486"></a>04486         {
<a name="l04487"></a>04487             cov(i,j) = sc[k++] / n;
<a name="l04488"></a>04488             cov(j,i) = cov(i,j);
<a name="l04489"></a>04489         }
<a name="l04490"></a>04490     }
<a name="l04491"></a>04491 }
<a name="l04492"></a>04492 
<a name="l04493"></a>04493 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Scatter&gt;
<a name="l04494"></a>04494 <span class="keywordtype">void</span> flatScatterMatrixToCovariance(<span class="keywordtype">double</span> &amp; cov, Scatter <span class="keyword">const</span> &amp; sc, <span class="keywordtype">double</span> n)
<a name="l04495"></a>04495 {
<a name="l04496"></a>04496     cov = sc / n;
<a name="l04497"></a>04497 }
<a name="l04498"></a>04498 
<a name="l04499"></a>04499 } <span class="comment">// namespace acc_detail</span>
<a name="l04500"></a>04500 
<a name="l04501"></a>04501 <span class="comment">// we only store the flattened upper triangular part of the scatter matrix</span><span class="comment"></span>
<a name="l04502"></a>04502 <span class="comment">/** \brief Basic statistic. Flattened uppter-triangular part of scatter matrix.</span>
<a name="l04503"></a>04503 <span class="comment"></span>
<a name="l04504"></a>04504 <span class="comment">    Works in pass 1, %operator+=() supported (merging supported).</span>
<a name="l04505"></a>04505 <span class="comment">*/</span>
<a name="l04506"></a><a class="code" href="classvigra_1_1acc_1_1FlatScatterMatrix.html">04506</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1FlatScatterMatrix.html" title="Basic statistic. Flattened uppter-triangular part of scatter matrix.">FlatScatterMatrix</a>
<a name="l04507"></a>04507 {
<a name="l04508"></a>04508   <span class="keyword">public</span>:
<a name="l04509"></a>04509     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;Mean, Count&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l04510"></a>04510     
<a name="l04511"></a>04511     <span class="keyword">static</span> std::string name() 
<a name="l04512"></a>04512     { 
<a name="l04513"></a>04513         <span class="keywordflow">return</span> <span class="stringliteral">&quot;FlatScatterMatrix&quot;</span>;
<a name="l04514"></a>04514         <span class="comment">// static const std::string n(&quot;FlatScatterMatrix&quot;);</span>
<a name="l04515"></a>04515         <span class="comment">// return n;</span>
<a name="l04516"></a>04516     }
<a name="l04517"></a>04517     
<a name="l04518"></a>04518     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l04519"></a>04519     <span class="keyword">struct </span>Impl
<a name="l04520"></a>04520     : <span class="keyword">public</span> BASE
<a name="l04521"></a>04521     {
<a name="l04522"></a>04522         <span class="keyword">typedef</span> <span class="keyword">typename</span> AccumulatorResultTraits&lt;U&gt;::element_promote_type  element_type;
<a name="l04523"></a>04523         <span class="keyword">typedef</span> <span class="keyword">typename</span> AccumulatorResultTraits&lt;U&gt;::FlatCovarianceType    value_type;
<a name="l04524"></a>04524         <span class="keyword">typedef</span> value_type <span class="keyword">const</span> &amp;                                   result_type;
<a name="l04525"></a>04525        
<a name="l04526"></a>04526         <span class="keyword">typedef</span> <span class="keyword">typename</span> AccumulatorResultTraits&lt;U&gt;::SumType        SumType;
<a name="l04527"></a>04527 
<a name="l04528"></a>04528         value_type value_;
<a name="l04529"></a>04529         SumType     diff_;
<a name="l04530"></a>04530         
<a name="l04531"></a>04531         Impl()
<a name="l04532"></a>04532         : value_(),  <span class="comment">// call default constructor explicitly to ensure zero initialization</span>
<a name="l04533"></a>04533           diff_()
<a name="l04534"></a>04534         {}
<a name="l04535"></a>04535         
<a name="l04536"></a>04536         <span class="keywordtype">void</span> reset()
<a name="l04537"></a>04537         {
<a name="l04538"></a>04538             value_ = element_type();
<a name="l04539"></a>04539         }
<a name="l04540"></a>04540     
<a name="l04541"></a>04541         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Shape&gt;
<a name="l04542"></a>04542         <span class="keywordtype">void</span> reshape(Shape <span class="keyword">const</span> &amp; s)
<a name="l04543"></a>04543         {
<a name="l04544"></a>04544             <span class="keywordtype">int</span> size = <a class="code" href="group__TinyVectorOperators.html#gaa49e08e69b54385f9434ffe32a32f299" title="product of the vector&#39;s elements">prod</a>(s);
<a name="l04545"></a>04545             acc_detail::reshapeImpl(value_, <a class="code" href="group__MultiIteratorGroup.html#gaf6799170bf47f30c42a3f164f6ccf8ce" title="shape type for MultiArray&lt;1, T&gt;">Shape1</a>(size*(size+1)/2));
<a name="l04546"></a>04546             acc_detail::reshapeImpl(diff_, s);
<a name="l04547"></a>04547         }
<a name="l04548"></a>04548         
<a name="l04549"></a>04549         <span class="keywordtype">void</span> <a class="code" href="group__FFTWComplexOperators.html#ga23c9113f38123caf2ae30a59a1a5cfc5" title="add-assignment">operator+=</a>(Impl <span class="keyword">const</span> &amp; o)
<a name="l04550"></a>04550         {
<a name="l04551"></a>04551             <span class="keywordtype">double</span> n1 = getDependency&lt;Count&gt;(*this), n2 = getDependency&lt;Count&gt;(o);
<a name="l04552"></a>04552             <span class="keywordflow">if</span>(n1 == 0.0)
<a name="l04553"></a>04553             {
<a name="l04554"></a>04554                 value_ = o.value_;
<a name="l04555"></a>04555             }
<a name="l04556"></a>04556             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(n2 != 0.0)
<a name="l04557"></a>04557             {
<a name="l04558"></a>04558                 <span class="keyword">using namespace </span>vigra::multi_math;
<a name="l04559"></a>04559                 diff_ = getDependency&lt;Mean&gt;(*this) - getDependency&lt;Mean&gt;(o);
<a name="l04560"></a>04560                 acc_detail::updateFlatScatterMatrix(value_, diff_, n1 * n2 / (n1 + n2));
<a name="l04561"></a>04561                 value_ += o.value_;
<a name="l04562"></a>04562             }
<a name="l04563"></a>04563         }
<a name="l04564"></a>04564     
<a name="l04565"></a>04565         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t)
<a name="l04566"></a>04566         {
<a name="l04567"></a>04567             compute(t);
<a name="l04568"></a>04568         }
<a name="l04569"></a>04569         
<a name="l04570"></a>04570         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l04571"></a>04571         {
<a name="l04572"></a>04572             compute(t, weight);
<a name="l04573"></a>04573         }
<a name="l04574"></a>04574         
<a name="l04575"></a>04575         result_type operator()()<span class="keyword"> const</span>
<a name="l04576"></a>04576 <span class="keyword">        </span>{
<a name="l04577"></a>04577             <span class="keywordflow">return</span> value_;
<a name="l04578"></a>04578         }
<a name="l04579"></a>04579         
<a name="l04580"></a>04580       <span class="keyword">private</span>:
<a name="l04581"></a>04581         <span class="keywordtype">void</span> compute(U <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight = 1.0)
<a name="l04582"></a>04582         {
<a name="l04583"></a>04583             <span class="keywordtype">double</span> n = getDependency&lt;Count&gt;(*this);
<a name="l04584"></a>04584             <span class="keywordflow">if</span>(n &gt; weight)
<a name="l04585"></a>04585             {
<a name="l04586"></a>04586                 <span class="keyword">using namespace </span>vigra::multi_math;
<a name="l04587"></a>04587                 diff_ = getDependency&lt;Mean&gt;(*this) - t;
<a name="l04588"></a>04588                 acc_detail::updateFlatScatterMatrix(value_, diff_, n * weight / (n - weight));
<a name="l04589"></a>04589             }
<a name="l04590"></a>04590         }
<a name="l04591"></a>04591     };
<a name="l04592"></a>04592 };
<a name="l04593"></a>04593 
<a name="l04594"></a>04594 <span class="comment">// Covariance</span>
<a name="l04595"></a>04595 <span class="keyword">template</span> &lt;&gt;
<a name="l04596"></a>04596 <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1DivideByCount.html" title="Modifier. Divide statistic by Count: DivideByCount&lt;TAG&gt; = TAG / Count .">DivideByCount</a>&lt;<a class="code" href="classvigra_1_1acc_1_1FlatScatterMatrix.html" title="Basic statistic. Flattened uppter-triangular part of scatter matrix.">FlatScatterMatrix</a>&gt;
<a name="l04597"></a>04597 {
<a name="l04598"></a>04598   <span class="keyword">public</span>:
<a name="l04599"></a>04599     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;FlatScatterMatrix, Count&gt;</a> Dependencies;
<a name="l04600"></a>04600     
<a name="l04601"></a>04601     <span class="keyword">static</span> std::string name() 
<a name="l04602"></a>04602     { 
<a name="l04603"></a>04603         <span class="keywordflow">return</span> <span class="stringliteral">&quot;DivideByCount&lt;FlatScatterMatrix&gt;&quot;</span>;
<a name="l04604"></a>04604         <span class="comment">// static const std::string n(&quot;DivideByCount&lt;FlatScatterMatrix&gt;&quot;);</span>
<a name="l04605"></a>04605         <span class="comment">// return n;</span>
<a name="l04606"></a>04606     }
<a name="l04607"></a>04607     
<a name="l04608"></a>04608     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l04609"></a>04609     <span class="keyword">struct </span>Impl
<a name="l04610"></a>04610     : <span class="keyword">public</span> CachedResultBase&lt;BASE, typename AccumulatorResultTraits&lt;U&gt;::CovarianceType, U&gt;
<a name="l04611"></a>04611     {
<a name="l04612"></a>04612         <span class="keyword">typedef</span> CachedResultBase&lt;BASE, typename AccumulatorResultTraits&lt;U&gt;::CovarianceType, U&gt; BaseType;      
<a name="l04613"></a>04613         <span class="keyword">typedef</span> <span class="keyword">typename</span> BaseType::result_type result_type;
<a name="l04614"></a>04614         
<a name="l04615"></a>04615         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Shape&gt;
<a name="l04616"></a>04616         <span class="keywordtype">void</span> reshape(Shape <span class="keyword">const</span> &amp; s)
<a name="l04617"></a>04617         {
<a name="l04618"></a>04618             <span class="keywordtype">int</span> size = <a class="code" href="group__TinyVectorOperators.html#gaa49e08e69b54385f9434ffe32a32f299" title="product of the vector&#39;s elements">prod</a>(s);
<a name="l04619"></a>04619             acc_detail::reshapeImpl(this-&gt;value_, <a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(size,size));
<a name="l04620"></a>04620         }
<a name="l04621"></a>04621         
<a name="l04622"></a>04622         result_type operator()()<span class="keyword"> const</span>
<a name="l04623"></a>04623 <span class="keyword">        </span>{
<a name="l04624"></a>04624             <span class="keywordflow">if</span>(this-&gt;isDirty())
<a name="l04625"></a>04625             {
<a name="l04626"></a>04626                 acc_detail::flatScatterMatrixToCovariance(this-&gt;value_, getDependency&lt;FlatScatterMatrix&gt;(*<span class="keyword">this</span>), getDependency&lt;Count&gt;(*<span class="keyword">this</span>));
<a name="l04627"></a>04627                 this-&gt;setClean();
<a name="l04628"></a>04628             }
<a name="l04629"></a>04629             <span class="keywordflow">return</span> this-&gt;value_;
<a name="l04630"></a>04630         }
<a name="l04631"></a>04631     };
<a name="l04632"></a>04632 };
<a name="l04633"></a>04633 
<a name="l04634"></a>04634 <span class="comment">// UnbiasedCovariance</span>
<a name="l04635"></a>04635 <span class="keyword">template</span> &lt;&gt;
<a name="l04636"></a>04636 <span class="keyword">class </span>DivideUnbiased&lt;FlatScatterMatrix&gt;
<a name="l04637"></a>04637 {
<a name="l04638"></a>04638   <span class="keyword">public</span>:
<a name="l04639"></a>04639     <span class="keyword">typedef</span> Select&lt;FlatScatterMatrix, Count&gt; Dependencies;
<a name="l04640"></a>04640     
<a name="l04641"></a>04641     <span class="keyword">static</span> std::string name() 
<a name="l04642"></a>04642     { 
<a name="l04643"></a>04643         <span class="keywordflow">return</span> <span class="stringliteral">&quot;DivideUnbiased&lt;FlatScatterMatrix&gt;&quot;</span>;
<a name="l04644"></a>04644         <span class="comment">// static const std::string n(&quot;DivideUnbiased&lt;FlatScatterMatrix&gt;&quot;);</span>
<a name="l04645"></a>04645         <span class="comment">// return n;</span>
<a name="l04646"></a>04646     }
<a name="l04647"></a>04647     
<a name="l04648"></a>04648     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l04649"></a>04649     <span class="keyword">struct </span>Impl
<a name="l04650"></a>04650     : <span class="keyword">public</span> CachedResultBase&lt;BASE, typename AccumulatorResultTraits&lt;U&gt;::CovarianceType, U&gt;
<a name="l04651"></a>04651     {
<a name="l04652"></a>04652         <span class="keyword">typedef</span> CachedResultBase&lt;BASE, typename AccumulatorResultTraits&lt;U&gt;::CovarianceType, U&gt; BaseType;      
<a name="l04653"></a>04653         <span class="keyword">typedef</span> <span class="keyword">typename</span> BaseType::result_type result_type;
<a name="l04654"></a>04654         
<a name="l04655"></a>04655         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Shape&gt;
<a name="l04656"></a>04656         <span class="keywordtype">void</span> reshape(Shape <span class="keyword">const</span> &amp; s)
<a name="l04657"></a>04657         {
<a name="l04658"></a>04658             <span class="keywordtype">int</span> size = <a class="code" href="group__TinyVectorOperators.html#gaa49e08e69b54385f9434ffe32a32f299" title="product of the vector&#39;s elements">prod</a>(s);
<a name="l04659"></a>04659             acc_detail::reshapeImpl(this-&gt;value_, <a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(size,size));
<a name="l04660"></a>04660         }
<a name="l04661"></a>04661         
<a name="l04662"></a>04662         result_type operator()()<span class="keyword"> const</span>
<a name="l04663"></a>04663 <span class="keyword">        </span>{
<a name="l04664"></a>04664             <span class="keywordflow">if</span>(this-&gt;isDirty())
<a name="l04665"></a>04665             {
<a name="l04666"></a>04666                 acc_detail::flatScatterMatrixToCovariance(this-&gt;value_, getDependency&lt;FlatScatterMatrix&gt;(*<span class="keyword">this</span>), getDependency&lt;Count&gt;(*<span class="keyword">this</span>) - 1.0);
<a name="l04667"></a>04667                 this-&gt;setClean();
<a name="l04668"></a>04668             }
<a name="l04669"></a>04669             <span class="keywordflow">return</span> this-&gt;value_;
<a name="l04670"></a>04670         }
<a name="l04671"></a>04671     };
<a name="l04672"></a>04672 };
<a name="l04673"></a>04673 <span class="comment"></span>
<a name="l04674"></a>04674 <span class="comment">/** Basic statistic. ScatterMatrixEigensystem (?)</span>
<a name="l04675"></a>04675 <span class="comment">*/</span>
<a name="l04676"></a><a class="code" href="classvigra_1_1acc_1_1ScatterMatrixEigensystem.html">04676</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1ScatterMatrixEigensystem.html">ScatterMatrixEigensystem</a>
<a name="l04677"></a>04677 {
<a name="l04678"></a>04678   <span class="keyword">public</span>:
<a name="l04679"></a>04679     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;FlatScatterMatrix&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l04680"></a>04680     
<a name="l04681"></a>04681     <span class="keyword">static</span> std::string name() 
<a name="l04682"></a>04682     { 
<a name="l04683"></a>04683         <span class="keywordflow">return</span> <span class="stringliteral">&quot;ScatterMatrixEigensystem&quot;</span>;
<a name="l04684"></a>04684         <span class="comment">// static const std::string n(&quot;ScatterMatrixEigensystem&quot;);</span>
<a name="l04685"></a>04685         <span class="comment">// return n;</span>
<a name="l04686"></a>04686     }
<a name="l04687"></a>04687     
<a name="l04688"></a>04688     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l04689"></a>04689     <span class="keyword">struct </span>Impl
<a name="l04690"></a>04690     : <span class="keyword">public</span> BASE
<a name="l04691"></a>04691     {
<a name="l04692"></a>04692         <span class="keyword">typedef</span> <span class="keyword">typename</span> AccumulatorResultTraits&lt;U&gt;::element_promote_type  element_type;
<a name="l04693"></a>04693         <span class="keyword">typedef</span> <span class="keyword">typename</span> AccumulatorResultTraits&lt;U&gt;::SumType               EigenvalueType;
<a name="l04694"></a>04694         <span class="keyword">typedef</span> <span class="keyword">typename</span> AccumulatorResultTraits&lt;U&gt;::CovarianceType        EigenvectorType;
<a name="l04695"></a>04695         <span class="keyword">typedef</span> std::pair&lt;EigenvalueType, EigenvectorType&gt;                 value_type;
<a name="l04696"></a>04696         <span class="keyword">typedef</span> value_type <span class="keyword">const</span> &amp;                                         result_type;
<a name="l04697"></a>04697 
<a name="l04698"></a>04698         <span class="keyword">mutable</span> value_type value_;
<a name="l04699"></a>04699         
<a name="l04700"></a>04700         Impl()
<a name="l04701"></a>04701         : value_()
<a name="l04702"></a>04702         {}
<a name="l04703"></a>04703         
<a name="l04704"></a>04704         <span class="keywordtype">void</span> <a class="code" href="group__FFTWComplexOperators.html#ga23c9113f38123caf2ae30a59a1a5cfc5" title="add-assignment">operator+=</a>(Impl <span class="keyword">const</span> &amp; o)
<a name="l04705"></a>04705         {
<a name="l04706"></a>04706             <span class="keywordflow">if</span>(!acc_detail::hasDataImpl(value_.second))
<a name="l04707"></a>04707             {
<a name="l04708"></a>04708                 acc_detail::copyShapeImpl(o.value_.first, value_.first);
<a name="l04709"></a>04709                 acc_detail::copyShapeImpl(o.value_.second, value_.second);
<a name="l04710"></a>04710             }
<a name="l04711"></a>04711             this-&gt;setDirty();
<a name="l04712"></a>04712         }
<a name="l04713"></a>04713 
<a name="l04714"></a>04714         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp;)
<a name="l04715"></a>04715         {
<a name="l04716"></a>04716             this-&gt;setDirty();
<a name="l04717"></a>04717         }
<a name="l04718"></a>04718         
<a name="l04719"></a>04719         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp;, <span class="keywordtype">double</span>)
<a name="l04720"></a>04720         {
<a name="l04721"></a>04721              this-&gt;setDirty();
<a name="l04722"></a>04722         }
<a name="l04723"></a>04723 
<a name="l04724"></a>04724         <span class="keywordtype">void</span> reset()
<a name="l04725"></a>04725         {
<a name="l04726"></a>04726             value_.first = element_type();
<a name="l04727"></a>04727             value_.second = element_type();
<a name="l04728"></a>04728             this-&gt;setClean();
<a name="l04729"></a>04729         }
<a name="l04730"></a>04730     
<a name="l04731"></a>04731         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Shape&gt;
<a name="l04732"></a>04732         <span class="keywordtype">void</span> reshape(Shape <span class="keyword">const</span> &amp; s)
<a name="l04733"></a>04733         {
<a name="l04734"></a>04734             <span class="keywordtype">int</span> size = <a class="code" href="group__TinyVectorOperators.html#gaa49e08e69b54385f9434ffe32a32f299" title="product of the vector&#39;s elements">prod</a>(s);
<a name="l04735"></a>04735             acc_detail::reshapeImpl(value_.first, <a class="code" href="classvigra_1_1TinyVector.html" title="Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE...">Shape1</a>(size));
<a name="l04736"></a>04736             acc_detail::reshapeImpl(value_.second, <a class="code" href="classvigra_1_1TinyVector.html" title="Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE...">Shape2</a>(size,size));
<a name="l04737"></a>04737         }
<a name="l04738"></a>04738         
<a name="l04739"></a>04739         result_type operator()()<span class="keyword"> const</span>
<a name="l04740"></a>04740 <span class="keyword">        </span>{
<a name="l04741"></a>04741             <span class="keywordflow">if</span>(this-&gt;isDirty())
<a name="l04742"></a>04742             {
<a name="l04743"></a>04743                 compute(getDependency&lt;FlatScatterMatrix&gt;(*<span class="keyword">this</span>), value_.first, value_.second);
<a name="l04744"></a>04744                 this-&gt;setClean();
<a name="l04745"></a>04745             }
<a name="l04746"></a>04746             <span class="keywordflow">return</span> value_;
<a name="l04747"></a>04747         }
<a name="l04748"></a>04748         
<a name="l04749"></a>04749       <span class="keyword">private</span>:
<a name="l04750"></a>04750         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Flat, <span class="keyword">class</span> EW, <span class="keyword">class</span> EV&gt;
<a name="l04751"></a>04751         <span class="keyword">static</span> <span class="keywordtype">void</span> compute(Flat <span class="keyword">const</span> &amp; flatScatter, EW &amp; ew, EV &amp; ev)
<a name="l04752"></a>04752         {
<a name="l04753"></a>04753             EigenvectorType scatter(ev.shape());
<a name="l04754"></a>04754             acc_detail::flatScatterMatrixToScatterMatrix(scatter, flatScatter);
<a name="l04755"></a>04755             <span class="comment">// create a view because EW could be a TinyVector</span>
<a name="l04756"></a>04756             <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView&lt;2, element_type&gt;</a> ewview(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(ev.shape(0), 1), &amp;ew[0]);
<a name="l04757"></a>04757             <a class="code" href="group__MatrixAlgebra.html#ga2fb4d56ba8360951f0ffa62e105e1a69">symmetricEigensystem</a>(scatter, ewview, ev);
<a name="l04758"></a>04758         }
<a name="l04759"></a>04759         
<a name="l04760"></a>04760         <span class="keyword">static</span> <span class="keywordtype">void</span> compute(<span class="keywordtype">double</span> v, <span class="keywordtype">double</span> &amp; ew, <span class="keywordtype">double</span> &amp; ev)
<a name="l04761"></a>04761         {
<a name="l04762"></a>04762             ew = v;
<a name="l04763"></a>04763             ev = 1.0;
<a name="l04764"></a>04764         }
<a name="l04765"></a>04765     };
<a name="l04766"></a>04766 };
<a name="l04767"></a>04767 
<a name="l04768"></a>04768 <span class="comment">// CovarianceEigensystem</span>
<a name="l04769"></a>04769 <span class="keyword">template</span> &lt;&gt;
<a name="l04770"></a>04770 <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1DivideByCount.html" title="Modifier. Divide statistic by Count: DivideByCount&lt;TAG&gt; = TAG / Count .">DivideByCount</a>&lt;<a class="code" href="classvigra_1_1acc_1_1ScatterMatrixEigensystem.html">ScatterMatrixEigensystem</a>&gt;
<a name="l04771"></a>04771 {
<a name="l04772"></a>04772   <span class="keyword">public</span>:
<a name="l04773"></a>04773     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;ScatterMatrixEigensystem, Count&gt;</a> Dependencies;
<a name="l04774"></a>04774     
<a name="l04775"></a>04775     <span class="keyword">static</span> std::string name() 
<a name="l04776"></a>04776     { 
<a name="l04777"></a>04777         <span class="keywordflow">return</span> <span class="stringliteral">&quot;DivideByCount&lt;ScatterMatrixEigensystem&gt;&quot;</span>;
<a name="l04778"></a>04778         <span class="comment">// static const std::string n(&quot;DivideByCount&lt;ScatterMatrixEigensystem&gt;&quot;);</span>
<a name="l04779"></a>04779         <span class="comment">// return n;</span>
<a name="l04780"></a>04780     }
<a name="l04781"></a>04781     
<a name="l04782"></a>04782     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l04783"></a>04783     <span class="keyword">struct </span>Impl
<a name="l04784"></a>04784     : <span class="keyword">public</span> BASE
<a name="l04785"></a>04785     {
<a name="l04786"></a>04786         <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupDependency&lt;ScatterMatrixEigensystem, BASE&gt;::type  SMImpl;
<a name="l04787"></a>04787         <span class="keyword">typedef</span> <span class="keyword">typename</span> SMImpl::element_type                             element_type;
<a name="l04788"></a>04788         <span class="keyword">typedef</span> <span class="keyword">typename</span> SMImpl::EigenvalueType                           EigenvalueType;
<a name="l04789"></a>04789         <span class="keyword">typedef</span> <span class="keyword">typename</span> SMImpl::EigenvectorType                          EigenvectorType;
<a name="l04790"></a>04790         <span class="keyword">typedef</span> std::pair&lt;EigenvalueType, EigenvectorType const &amp;&gt;        value_type;
<a name="l04791"></a>04791         <span class="keyword">typedef</span> value_type <span class="keyword">const</span> &amp;                                        result_type;
<a name="l04792"></a>04792 
<a name="l04793"></a>04793         <span class="keyword">mutable</span> value_type value_;
<a name="l04794"></a>04794         
<a name="l04795"></a>04795         Impl()
<a name="l04796"></a>04796         : value_(EigenvalueType(), BASE::template call_getDependency&lt;ScatterMatrixEigensystem&gt;().second)
<a name="l04797"></a>04797         {}
<a name="l04798"></a>04798         
<a name="l04799"></a>04799         <span class="keywordtype">void</span> <a class="code" href="group__FFTWComplexOperators.html#ga23c9113f38123caf2ae30a59a1a5cfc5" title="add-assignment">operator+=</a>(Impl <span class="keyword">const</span> &amp;)
<a name="l04800"></a>04800         {
<a name="l04801"></a>04801             this-&gt;setDirty();
<a name="l04802"></a>04802         }
<a name="l04803"></a>04803 
<a name="l04804"></a>04804         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp;)
<a name="l04805"></a>04805         {
<a name="l04806"></a>04806             this-&gt;setDirty();
<a name="l04807"></a>04807         }
<a name="l04808"></a>04808         
<a name="l04809"></a>04809         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp;, <span class="keywordtype">double</span>)
<a name="l04810"></a>04810         {
<a name="l04811"></a>04811              this-&gt;setDirty();
<a name="l04812"></a>04812         }
<a name="l04813"></a>04813 
<a name="l04814"></a>04814         <span class="keywordtype">void</span> reset()
<a name="l04815"></a>04815         {
<a name="l04816"></a>04816             value_.first = element_type();
<a name="l04817"></a>04817             this-&gt;setClean();
<a name="l04818"></a>04818         }
<a name="l04819"></a>04819     
<a name="l04820"></a>04820         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Shape&gt;
<a name="l04821"></a>04821         <span class="keywordtype">void</span> reshape(Shape <span class="keyword">const</span> &amp; s)
<a name="l04822"></a>04822         {
<a name="l04823"></a>04823             <span class="keywordtype">int</span> size = <a class="code" href="group__TinyVectorOperators.html#gaa49e08e69b54385f9434ffe32a32f299" title="product of the vector&#39;s elements">prod</a>(s);
<a name="l04824"></a>04824             acc_detail::reshapeImpl(value_.first, <a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(size,1));
<a name="l04825"></a>04825         }
<a name="l04826"></a>04826         
<a name="l04827"></a>04827         result_type operator()()<span class="keyword"> const</span>
<a name="l04828"></a>04828 <span class="keyword">        </span>{
<a name="l04829"></a>04829             <span class="keywordflow">if</span>(this-&gt;isDirty())
<a name="l04830"></a>04830             {
<a name="l04831"></a>04831                 value_.first = getDependency&lt;ScatterMatrixEigensystem&gt;(*this).first / getDependency&lt;Count&gt;(*this);
<a name="l04832"></a>04832                 this-&gt;setClean();
<a name="l04833"></a>04833             }
<a name="l04834"></a>04834             <span class="keywordflow">return</span> value_;
<a name="l04835"></a>04835         }
<a name="l04836"></a>04836     };
<a name="l04837"></a>04837 };
<a name="l04838"></a>04838 
<a name="l04839"></a>04839 <span class="comment">// alternative implementation of CovarianceEigensystem - solve eigensystem directly</span>
<a name="l04840"></a>04840 <span class="comment">//</span>
<a name="l04841"></a>04841 <span class="comment">// template &lt;&gt;</span>
<a name="l04842"></a>04842 <span class="comment">// class DivideByCount&lt;ScatterMatrixEigensystem&gt;</span>
<a name="l04843"></a>04843 <span class="comment">// {</span>
<a name="l04844"></a>04844   <span class="comment">// public:</span>
<a name="l04845"></a>04845     <span class="comment">// typedef Select&lt;Covariance&gt; Dependencies;</span>
<a name="l04846"></a>04846     
<a name="l04847"></a>04847     <span class="comment">// template &lt;class U, class BASE&gt;</span>
<a name="l04848"></a>04848     <span class="comment">// struct Impl</span>
<a name="l04849"></a>04849     <span class="comment">// : public BASE</span>
<a name="l04850"></a>04850     <span class="comment">// {</span>
<a name="l04851"></a>04851         <span class="comment">// typedef typename AccumulatorResultTraits&lt;U&gt;::element_promote_type  element_type;</span>
<a name="l04852"></a>04852         <span class="comment">// typedef typename AccumulatorResultTraits&lt;U&gt;::SumType               EigenvalueType;</span>
<a name="l04853"></a>04853         <span class="comment">// typedef typename AccumulatorResultTraits&lt;U&gt;::CovarianceType        EigenvectorType;</span>
<a name="l04854"></a>04854         <span class="comment">// typedef std::pair&lt;EigenvalueType, EigenvectorType&gt;                 value_type;</span>
<a name="l04855"></a>04855         <span class="comment">// typedef value_type const &amp;                                         result_type;</span>
<a name="l04856"></a>04856 
<a name="l04857"></a>04857         <span class="comment">// mutable value_type value_;</span>
<a name="l04858"></a>04858         
<a name="l04859"></a>04859         <span class="comment">// Impl()</span>
<a name="l04860"></a>04860         <span class="comment">// : value_()</span>
<a name="l04861"></a>04861         <span class="comment">// {}</span>
<a name="l04862"></a>04862         
<a name="l04863"></a>04863         <span class="comment">// void operator+=(Impl const &amp;)</span>
<a name="l04864"></a>04864         <span class="comment">// {</span>
<a name="l04865"></a>04865             <span class="comment">// this-&gt;setDirty();</span>
<a name="l04866"></a>04866         <span class="comment">// }</span>
<a name="l04867"></a>04867 
<a name="l04868"></a>04868         <span class="comment">// void update(U const &amp;)</span>
<a name="l04869"></a>04869         <span class="comment">// {</span>
<a name="l04870"></a>04870             <span class="comment">// this-&gt;setDirty();</span>
<a name="l04871"></a>04871         <span class="comment">// }</span>
<a name="l04872"></a>04872         
<a name="l04873"></a>04873         <span class="comment">// void update(U const &amp;, double)</span>
<a name="l04874"></a>04874         <span class="comment">// {</span>
<a name="l04875"></a>04875              <span class="comment">// this-&gt;setDirty();</span>
<a name="l04876"></a>04876         <span class="comment">// }</span>
<a name="l04877"></a>04877 
<a name="l04878"></a>04878         <span class="comment">// void reset()</span>
<a name="l04879"></a>04879         <span class="comment">// {</span>
<a name="l04880"></a>04880             <span class="comment">// value_.first = element_type();</span>
<a name="l04881"></a>04881             <span class="comment">// value_.second = element_type();</span>
<a name="l04882"></a>04882             <span class="comment">// this-&gt;setClean();</span>
<a name="l04883"></a>04883         <span class="comment">// }</span>
<a name="l04884"></a>04884     
<a name="l04885"></a>04885         <span class="comment">// template &lt;class Shape&gt;</span>
<a name="l04886"></a>04886         <span class="comment">// void reshape(Shape const &amp; s)</span>
<a name="l04887"></a>04887         <span class="comment">// {</span>
<a name="l04888"></a>04888             <span class="comment">// int size = prod(s);</span>
<a name="l04889"></a>04889             <span class="comment">// acc_detail::reshapeImpl(value_.first, Shape2(size,1));</span>
<a name="l04890"></a>04890             <span class="comment">// acc_detail::reshapeImpl(value_.second, Shape2(size,size));</span>
<a name="l04891"></a>04891         <span class="comment">// }</span>
<a name="l04892"></a>04892         
<a name="l04893"></a>04893         <span class="comment">// result_type operator()() const</span>
<a name="l04894"></a>04894         <span class="comment">// {</span>
<a name="l04895"></a>04895             <span class="comment">// if(this-&gt;isDirty())</span>
<a name="l04896"></a>04896             <span class="comment">// {</span>
<a name="l04897"></a>04897                 <span class="comment">// compute(getDependency&lt;Covariance&gt;(*this), value_.first, value_.second);</span>
<a name="l04898"></a>04898                 <span class="comment">// this-&gt;setClean();</span>
<a name="l04899"></a>04899             <span class="comment">// }</span>
<a name="l04900"></a>04900             <span class="comment">// return value_;</span>
<a name="l04901"></a>04901         <span class="comment">// }</span>
<a name="l04902"></a>04902         
<a name="l04903"></a>04903       <span class="comment">// private:</span>
<a name="l04904"></a>04904         <span class="comment">// template &lt;class Cov, class EW, class EV&gt;</span>
<a name="l04905"></a>04905         <span class="comment">// static void compute(Cov const &amp; cov, EW &amp; ew, EV &amp; ev)</span>
<a name="l04906"></a>04906         <span class="comment">// {</span>
<a name="l04907"></a>04907             <span class="comment">// // create a view because EW could be a TinyVector</span>
<a name="l04908"></a>04908             <span class="comment">// MultiArrayView&lt;2, element_type&gt; ewview(Shape2(cov.shape(0), 1), &amp;ew[0]);</span>
<a name="l04909"></a>04909             <span class="comment">// symmetricEigensystem(cov, ewview, ev);</span>
<a name="l04910"></a>04910         <span class="comment">// }</span>
<a name="l04911"></a>04911         
<a name="l04912"></a>04912         <span class="comment">// static void compute(double cov, double &amp; ew, double &amp; ev)</span>
<a name="l04913"></a>04913         <span class="comment">// {</span>
<a name="l04914"></a>04914             <span class="comment">// ew = cov;</span>
<a name="l04915"></a>04915             <span class="comment">// ev = 1.0;</span>
<a name="l04916"></a>04916         <span class="comment">// }</span>
<a name="l04917"></a>04917     <span class="comment">// };</span>
<a name="l04918"></a>04918 <span class="comment">// };</span>
<a name="l04919"></a>04919 
<a name="l04920"></a>04920 <span class="comment">// covariance eigenvalues</span><span class="comment"></span>
<a name="l04921"></a>04921 <span class="comment">/** \brief Specialization (covariance eigenvalues): works in pass 1, %operator+=() supported (merging).</span>
<a name="l04922"></a>04922 <span class="comment">*/</span>
<a name="l04923"></a>04923 <span class="keyword">template</span> &lt;&gt;
<a name="l04924"></a><a class="code" href="classvigra_1_1acc_1_1Principal_3_01PowerSum_3_012_01_4_01_4.html">04924</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1Principal.html" title="Modifier. Project onto PCA eigenvectors.">Principal</a>&lt;<a class="code" href="classvigra_1_1acc_1_1PowerSum.html" title="Basic statistic. PowerSum&lt;N&gt; = .">PowerSum</a>&lt;2&gt; &gt;
<a name="l04925"></a>04925 {
<a name="l04926"></a>04926   <span class="keyword">public</span>:
<a name="l04927"></a>04927     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;ScatterMatrixEigensystem&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l04928"></a>04928      
<a name="l04929"></a>04929     <span class="keyword">static</span> std::string name() 
<a name="l04930"></a>04930     { 
<a name="l04931"></a>04931         <span class="keywordflow">return</span> <span class="stringliteral">&quot;Principal&lt;PowerSum&lt;2&gt; &gt;&quot;</span>;
<a name="l04932"></a>04932         <span class="comment">// static const std::string n(&quot;Principal&lt;PowerSum&lt;2&gt; &gt;&quot;);</span>
<a name="l04933"></a>04933         <span class="comment">// return n;</span>
<a name="l04934"></a>04934     }
<a name="l04935"></a>04935     
<a name="l04936"></a>04936     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l04937"></a>04937     <span class="keyword">struct </span>Impl
<a name="l04938"></a>04938     : <span class="keyword">public</span> BASE
<a name="l04939"></a>04939     {
<a name="l04940"></a>04940         <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupDependency&lt;ScatterMatrixEigensystem, BASE&gt;::type::EigenvalueType value_type;
<a name="l04941"></a>04941         <span class="keyword">typedef</span> value_type <span class="keyword">const</span> &amp;                                                       result_type;
<a name="l04942"></a>04942         
<a name="l04943"></a>04943         result_type operator()()<span class="keyword"> const</span>
<a name="l04944"></a>04944 <span class="keyword">        </span>{
<a name="l04945"></a>04945             <span class="keywordflow">return</span> getDependency&lt;ScatterMatrixEigensystem&gt;(*this).first;
<a name="l04946"></a>04946         }
<a name="l04947"></a>04947     };
<a name="l04948"></a>04948 };
<a name="l04949"></a>04949 
<a name="l04950"></a>04950 
<a name="l04951"></a>04951 <span class="comment">// Principal&lt;CoordinateSystem&gt; == covariance eigenvectors</span><span class="comment"></span>
<a name="l04952"></a>04952 <span class="comment">/** \brief Specialization (covariance eigenvectors): works in pass 1, %operator+=() supported (merging).</span>
<a name="l04953"></a>04953 <span class="comment">*/</span>
<a name="l04954"></a>04954 <span class="keyword">template</span> &lt;&gt;
<a name="l04955"></a><a class="code" href="classvigra_1_1acc_1_1Principal_3_01CoordinateSystem_01_4.html">04955</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1Principal.html" title="Modifier. Project onto PCA eigenvectors.">Principal</a>&lt;<a class="code" href="classvigra_1_1acc_1_1CoordinateSystem.html" title="Basic statistic. Identity matrix of appropriate size.">CoordinateSystem</a>&gt;
<a name="l04956"></a>04956 {
<a name="l04957"></a>04957   <span class="keyword">public</span>:
<a name="l04958"></a>04958     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;ScatterMatrixEigensystem&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l04959"></a>04959      
<a name="l04960"></a>04960     <span class="keyword">static</span> std::string name() 
<a name="l04961"></a>04961     { 
<a name="l04962"></a>04962         <span class="keywordflow">return</span> <span class="stringliteral">&quot;Principal&lt;CoordinateSystem&gt;&quot;</span>;
<a name="l04963"></a>04963         <span class="comment">// static const std::string n(&quot;Principal&lt;CoordinateSystem&gt;&quot;);</span>
<a name="l04964"></a>04964         <span class="comment">// return n;</span>
<a name="l04965"></a>04965     }
<a name="l04966"></a>04966     
<a name="l04967"></a>04967     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l04968"></a>04968     <span class="keyword">struct </span>Impl
<a name="l04969"></a>04969     : <span class="keyword">public</span> BASE
<a name="l04970"></a>04970     {
<a name="l04971"></a>04971         <span class="keyword">typedef</span> <span class="keyword">typename</span> LookupDependency&lt;ScatterMatrixEigensystem, BASE&gt;::type::EigenvectorType value_type;
<a name="l04972"></a>04972         <span class="keyword">typedef</span> value_type <span class="keyword">const</span> &amp;                                                        result_type;
<a name="l04973"></a>04973         
<a name="l04974"></a>04974         result_type operator()()<span class="keyword"> const</span>
<a name="l04975"></a>04975 <span class="keyword">        </span>{
<a name="l04976"></a>04976             <span class="keywordflow">return</span> getDependency&lt;ScatterMatrixEigensystem&gt;(*this).second;
<a name="l04977"></a>04977         }
<a name="l04978"></a>04978     };
<a name="l04979"></a>04979 };
<a name="l04980"></a>04980 <span class="comment"></span>
<a name="l04981"></a>04981 <span class="comment">/** \brief Basic statistic. %Minimum value.</span>
<a name="l04982"></a>04982 <span class="comment"></span>
<a name="l04983"></a>04983 <span class="comment">    Works in pass 1, %operator+=() supported (merging supported).</span>
<a name="l04984"></a>04984 <span class="comment">*/</span>
<a name="l04985"></a><a class="code" href="classvigra_1_1acc_1_1Minimum.html">04985</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1Minimum.html" title="Basic statistic. Minimum value.">Minimum</a>
<a name="l04986"></a>04986 {
<a name="l04987"></a>04987   <span class="keyword">public</span>:
<a name="l04988"></a>04988     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l04989"></a>04989     
<a name="l04990"></a>04990     <span class="keyword">static</span> std::string name() 
<a name="l04991"></a>04991     { 
<a name="l04992"></a>04992         <span class="keywordflow">return</span> <span class="stringliteral">&quot;Minimum&quot;</span>;
<a name="l04993"></a>04993         <span class="comment">// static const std::string n(&quot;Minimum&quot;);</span>
<a name="l04994"></a>04994         <span class="comment">// return n;</span>
<a name="l04995"></a>04995     }
<a name="l04996"></a>04996     
<a name="l04997"></a>04997     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l04998"></a>04998     <span class="keyword">struct </span>Impl
<a name="l04999"></a>04999     : <span class="keyword">public</span> BASE
<a name="l05000"></a>05000     {
<a name="l05001"></a>05001         <span class="keyword">typedef</span> <span class="keyword">typename</span> AccumulatorResultTraits&lt;U&gt;::element_type element_type;
<a name="l05002"></a>05002         <span class="keyword">typedef</span> <span class="keyword">typename</span> AccumulatorResultTraits&lt;U&gt;::MinmaxType   value_type;
<a name="l05003"></a>05003         <span class="keyword">typedef</span> value_type <span class="keyword">const</span> &amp;                                result_type;
<a name="l05004"></a>05004 
<a name="l05005"></a>05005         value_type value_;
<a name="l05006"></a>05006         
<a name="l05007"></a>05007         Impl()
<a name="l05008"></a>05008         {
<a name="l05009"></a>05009             value_ = NumericTraits&lt;element_type&gt;::max();
<a name="l05010"></a>05010         }
<a name="l05011"></a>05011         
<a name="l05012"></a>05012         <span class="keywordtype">void</span> reset()
<a name="l05013"></a>05013         {
<a name="l05014"></a>05014             value_ = NumericTraits&lt;element_type&gt;::max();
<a name="l05015"></a>05015         }
<a name="l05016"></a>05016     
<a name="l05017"></a>05017         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Shape&gt;
<a name="l05018"></a>05018         <span class="keywordtype">void</span> reshape(Shape <span class="keyword">const</span> &amp; s)
<a name="l05019"></a>05019         {
<a name="l05020"></a>05020             acc_detail::reshapeImpl(value_, s, NumericTraits&lt;element_type&gt;::max());
<a name="l05021"></a>05021         }
<a name="l05022"></a>05022         
<a name="l05023"></a>05023         <span class="keywordtype">void</span> <a class="code" href="group__FFTWComplexOperators.html#ga23c9113f38123caf2ae30a59a1a5cfc5" title="add-assignment">operator+=</a>(Impl <span class="keyword">const</span> &amp; o)
<a name="l05024"></a>05024         {
<a name="l05025"></a>05025             updateImpl(o.value_); <span class="comment">// necessary because std::min causes ambiguous overload</span>
<a name="l05026"></a>05026         }
<a name="l05027"></a>05027     
<a name="l05028"></a>05028         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t)
<a name="l05029"></a>05029         {
<a name="l05030"></a>05030             updateImpl(t);
<a name="l05031"></a>05031         }
<a name="l05032"></a>05032         
<a name="l05033"></a>05033         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span>)
<a name="l05034"></a>05034         {
<a name="l05035"></a>05035             updateImpl(t);
<a name="l05036"></a>05036         }
<a name="l05037"></a>05037         
<a name="l05038"></a>05038         result_type operator()()<span class="keyword"> const</span>
<a name="l05039"></a>05039 <span class="keyword">        </span>{
<a name="l05040"></a>05040             <span class="keywordflow">return</span> value_;
<a name="l05041"></a>05041         }
<a name="l05042"></a>05042         
<a name="l05043"></a>05043       <span class="keyword">private</span>:
<a name="l05044"></a>05044         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l05045"></a>05045         <span class="keywordtype">void</span> updateImpl(T <span class="keyword">const</span> &amp; o)
<a name="l05046"></a>05046         {
<a name="l05047"></a>05047             <span class="keyword">using namespace </span>multi_math;
<a name="l05048"></a>05048             value_ = min(value_, o);
<a name="l05049"></a>05049         }
<a name="l05050"></a>05050         
<a name="l05051"></a>05051         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;
<a name="l05052"></a>05052         <span class="keywordtype">void</span> updateImpl(<a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">MultiArray&lt;1, T, Alloc&gt;</a> <span class="keyword">const</span> &amp; o)
<a name="l05053"></a>05053         {
<a name="l05054"></a>05054             value_ = multi_math::min(value_, o);
<a name="l05055"></a>05055         }
<a name="l05056"></a>05056     };
<a name="l05057"></a>05057 };
<a name="l05058"></a>05058 <span class="comment"></span>
<a name="l05059"></a>05059 <span class="comment">/** \brief Basic statistic. %Maximum value.</span>
<a name="l05060"></a>05060 <span class="comment"></span>
<a name="l05061"></a>05061 <span class="comment">    Works in pass 1, %operator+=() supported (merging supported).</span>
<a name="l05062"></a>05062 <span class="comment">*/</span>
<a name="l05063"></a><a class="code" href="classvigra_1_1acc_1_1Maximum.html">05063</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1Maximum.html" title="Basic statistic. Maximum value.">Maximum</a>
<a name="l05064"></a>05064 {
<a name="l05065"></a>05065   <span class="keyword">public</span>:
<a name="l05066"></a>05066     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l05067"></a>05067     
<a name="l05068"></a>05068     <span class="keyword">static</span> std::string name() 
<a name="l05069"></a>05069     { 
<a name="l05070"></a>05070         <span class="keywordflow">return</span> <span class="stringliteral">&quot;Maximum&quot;</span>;
<a name="l05071"></a>05071         <span class="comment">// static const std::string n(&quot;Maximum&quot;);</span>
<a name="l05072"></a>05072         <span class="comment">// return n;</span>
<a name="l05073"></a>05073     }
<a name="l05074"></a>05074     
<a name="l05075"></a>05075     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l05076"></a>05076     <span class="keyword">struct </span>Impl
<a name="l05077"></a>05077     : <span class="keyword">public</span> BASE
<a name="l05078"></a>05078     {
<a name="l05079"></a>05079         <span class="keyword">typedef</span> <span class="keyword">typename</span> AccumulatorResultTraits&lt;U&gt;::element_type element_type;
<a name="l05080"></a>05080         <span class="keyword">typedef</span> <span class="keyword">typename</span> AccumulatorResultTraits&lt;U&gt;::MinmaxType   value_type;
<a name="l05081"></a>05081         <span class="keyword">typedef</span> value_type <span class="keyword">const</span> &amp;                                result_type;
<a name="l05082"></a>05082 
<a name="l05083"></a>05083         value_type value_;
<a name="l05084"></a>05084         
<a name="l05085"></a>05085         Impl()
<a name="l05086"></a>05086         {
<a name="l05087"></a>05087             value_ = NumericTraits&lt;element_type&gt;::min();
<a name="l05088"></a>05088         }
<a name="l05089"></a>05089         
<a name="l05090"></a>05090         <span class="keywordtype">void</span> reset()
<a name="l05091"></a>05091         {
<a name="l05092"></a>05092             value_ = NumericTraits&lt;element_type&gt;::min();
<a name="l05093"></a>05093         }
<a name="l05094"></a>05094     
<a name="l05095"></a>05095         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Shape&gt;
<a name="l05096"></a>05096         <span class="keywordtype">void</span> reshape(Shape <span class="keyword">const</span> &amp; s)
<a name="l05097"></a>05097         {
<a name="l05098"></a>05098             acc_detail::reshapeImpl(value_, s, NumericTraits&lt;element_type&gt;::min());
<a name="l05099"></a>05099         }
<a name="l05100"></a>05100         
<a name="l05101"></a>05101         <span class="keywordtype">void</span> <a class="code" href="group__FFTWComplexOperators.html#ga23c9113f38123caf2ae30a59a1a5cfc5" title="add-assignment">operator+=</a>(Impl <span class="keyword">const</span> &amp; o)
<a name="l05102"></a>05102         {
<a name="l05103"></a>05103             updateImpl(o.value_); <span class="comment">// necessary because std::max causes ambiguous overload</span>
<a name="l05104"></a>05104         }
<a name="l05105"></a>05105     
<a name="l05106"></a>05106         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t)
<a name="l05107"></a>05107         {
<a name="l05108"></a>05108             updateImpl(t);
<a name="l05109"></a>05109         }
<a name="l05110"></a>05110         
<a name="l05111"></a>05111         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span>)
<a name="l05112"></a>05112         {
<a name="l05113"></a>05113             updateImpl(t);
<a name="l05114"></a>05114         }
<a name="l05115"></a>05115         
<a name="l05116"></a>05116         result_type operator()()<span class="keyword"> const</span>
<a name="l05117"></a>05117 <span class="keyword">        </span>{
<a name="l05118"></a>05118             <span class="keywordflow">return</span> value_;
<a name="l05119"></a>05119         }
<a name="l05120"></a>05120         
<a name="l05121"></a>05121       <span class="keyword">private</span>:
<a name="l05122"></a>05122         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l05123"></a>05123         <span class="keywordtype">void</span> updateImpl(T <span class="keyword">const</span> &amp; o)
<a name="l05124"></a>05124         {
<a name="l05125"></a>05125             <span class="keyword">using namespace </span>multi_math;
<a name="l05126"></a>05126             value_ = max(value_, o);
<a name="l05127"></a>05127         }
<a name="l05128"></a>05128         
<a name="l05129"></a>05129         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;
<a name="l05130"></a>05130         <span class="keywordtype">void</span> updateImpl(<a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">MultiArray&lt;1, T, Alloc&gt;</a> <span class="keyword">const</span> &amp; o)
<a name="l05131"></a>05131         {
<a name="l05132"></a>05132             value_ = multi_math::max(value_, o);
<a name="l05133"></a>05133         }
<a name="l05134"></a>05134     };
<a name="l05135"></a>05135 };
<a name="l05136"></a>05136 <span class="comment"></span>
<a name="l05137"></a>05137 <span class="comment">/** \brief Basic statistic. Data value where weight assumes its minimal value. </span>
<a name="l05138"></a>05138 <span class="comment"></span>
<a name="l05139"></a>05139 <span class="comment">    Weights must be given. Coord&lt;ArgMinWeight&gt; gives coordinate where weight assumes its minimal value. Works in pass 1, %operator+=() supported (merging supported).</span>
<a name="l05140"></a>05140 <span class="comment">*/</span>
<a name="l05141"></a><a class="code" href="classvigra_1_1acc_1_1ArgMinWeight.html">05141</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1ArgMinWeight.html" title="Basic statistic. Data value where weight assumes its minimal value.">ArgMinWeight</a>
<a name="l05142"></a>05142 {
<a name="l05143"></a>05143   <span class="keyword">public</span>:
<a name="l05144"></a>05144     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l05145"></a>05145     
<a name="l05146"></a>05146     <span class="keyword">static</span> std::string name() 
<a name="l05147"></a>05147     { 
<a name="l05148"></a>05148         <span class="keywordflow">return</span> <span class="stringliteral">&quot;ArgMinWeight&quot;</span>;
<a name="l05149"></a>05149         <span class="comment">// static const std::string n(&quot;ArgMinWeight&quot;);</span>
<a name="l05150"></a>05150         <span class="comment">// return n;</span>
<a name="l05151"></a>05151     }
<a name="l05152"></a>05152     
<a name="l05153"></a>05153     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l05154"></a>05154     <span class="keyword">struct </span>Impl
<a name="l05155"></a>05155     : <span class="keyword">public</span> BASE
<a name="l05156"></a>05156     {
<a name="l05157"></a>05157         <span class="keyword">typedef</span> <span class="keyword">typename</span> AccumulatorResultTraits&lt;U&gt;::element_type element_type;
<a name="l05158"></a>05158         <span class="keyword">typedef</span> <span class="keyword">typename</span> AccumulatorResultTraits&lt;U&gt;::MinmaxType   value_type;
<a name="l05159"></a>05159         <span class="keyword">typedef</span> value_type <span class="keyword">const</span> &amp;                                result_type;
<a name="l05160"></a>05160 
<a name="l05161"></a>05161         <span class="keywordtype">double</span> min_weight_;
<a name="l05162"></a>05162         value_type value_;
<a name="l05163"></a>05163         
<a name="l05164"></a>05164         Impl()
<a name="l05165"></a>05165         : min_weight_(NumericTraits&lt;double&gt;::max()),
<a name="l05166"></a>05166           value_()
<a name="l05167"></a>05167         {}
<a name="l05168"></a>05168         
<a name="l05169"></a>05169         <span class="keywordtype">void</span> reset()
<a name="l05170"></a>05170         {
<a name="l05171"></a>05171             min_weight_ = NumericTraits&lt;double&gt;::max();
<a name="l05172"></a>05172             value_ = element_type();
<a name="l05173"></a>05173         }
<a name="l05174"></a>05174     
<a name="l05175"></a>05175         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Shape&gt;
<a name="l05176"></a>05176         <span class="keywordtype">void</span> reshape(Shape <span class="keyword">const</span> &amp; s)
<a name="l05177"></a>05177         {
<a name="l05178"></a>05178             acc_detail::reshapeImpl(value_, s);
<a name="l05179"></a>05179         }
<a name="l05180"></a>05180         
<a name="l05181"></a>05181         <span class="keywordtype">void</span> <a class="code" href="group__FFTWComplexOperators.html#ga23c9113f38123caf2ae30a59a1a5cfc5" title="add-assignment">operator+=</a>(Impl <span class="keyword">const</span> &amp; o)
<a name="l05182"></a>05182         {
<a name="l05183"></a>05183             <span class="keyword">using namespace </span>multi_math;
<a name="l05184"></a>05184             <span class="keywordflow">if</span>(o.min_weight_ &lt; min_weight_)
<a name="l05185"></a>05185             {
<a name="l05186"></a>05186                 min_weight_ = o.min_weight_;
<a name="l05187"></a>05187                 value_ = o.value_;
<a name="l05188"></a>05188             }
<a name="l05189"></a>05189         }
<a name="l05190"></a>05190     
<a name="l05191"></a>05191         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t)
<a name="l05192"></a>05192         {
<a name="l05193"></a>05193             vigra_precondition(<span class="keyword">false</span>, <span class="stringliteral">&quot;ArgMinWeight::update() needs weights.&quot;</span>);
<a name="l05194"></a>05194         }
<a name="l05195"></a>05195         
<a name="l05196"></a>05196         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l05197"></a>05197         {
<a name="l05198"></a>05198             <span class="keywordflow">if</span>(weight &lt; min_weight_)
<a name="l05199"></a>05199             {
<a name="l05200"></a>05200                 min_weight_ = weight;
<a name="l05201"></a>05201                 value_ = t;
<a name="l05202"></a>05202             }
<a name="l05203"></a>05203         }
<a name="l05204"></a>05204         
<a name="l05205"></a>05205         result_type operator()()<span class="keyword"> const</span>
<a name="l05206"></a>05206 <span class="keyword">        </span>{
<a name="l05207"></a>05207             <span class="keywordflow">return</span> value_;
<a name="l05208"></a>05208         }
<a name="l05209"></a>05209     };
<a name="l05210"></a>05210 };
<a name="l05211"></a>05211 <span class="comment"></span>
<a name="l05212"></a>05212 <span class="comment">/** \brief Basic statistic. Data where weight assumes its maximal value. </span>
<a name="l05213"></a>05213 <span class="comment"></span>
<a name="l05214"></a>05214 <span class="comment">    Weights must be given. Coord&lt;ArgMinWeight&gt; gives coordinate where weight assumes its maximal value. Works in pass 1, %operator+=() supported (merging supported).</span>
<a name="l05215"></a>05215 <span class="comment">*/</span>
<a name="l05216"></a><a class="code" href="classvigra_1_1acc_1_1ArgMaxWeight.html">05216</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1ArgMaxWeight.html" title="Basic statistic. Data where weight assumes its maximal value.">ArgMaxWeight</a>
<a name="l05217"></a>05217 {
<a name="l05218"></a>05218   <span class="keyword">public</span>:
<a name="l05219"></a>05219     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l05220"></a>05220     
<a name="l05221"></a>05221     <span class="keyword">static</span> std::string name() 
<a name="l05222"></a>05222     { 
<a name="l05223"></a>05223         <span class="keywordflow">return</span> <span class="stringliteral">&quot;ArgMaxWeight&quot;</span>;
<a name="l05224"></a>05224         <span class="comment">// static const std::string n(&quot;ArgMaxWeight&quot;);</span>
<a name="l05225"></a>05225         <span class="comment">// return n;</span>
<a name="l05226"></a>05226     }
<a name="l05227"></a>05227     
<a name="l05228"></a>05228     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l05229"></a>05229     <span class="keyword">struct </span>Impl
<a name="l05230"></a>05230     : <span class="keyword">public</span> BASE
<a name="l05231"></a>05231     {
<a name="l05232"></a>05232         <span class="keyword">typedef</span> <span class="keyword">typename</span> AccumulatorResultTraits&lt;U&gt;::element_type element_type;
<a name="l05233"></a>05233         <span class="keyword">typedef</span> <span class="keyword">typename</span> AccumulatorResultTraits&lt;U&gt;::MinmaxType   value_type;
<a name="l05234"></a>05234         <span class="keyword">typedef</span> value_type <span class="keyword">const</span> &amp;                                result_type;
<a name="l05235"></a>05235 
<a name="l05236"></a>05236         <span class="keywordtype">double</span> max_weight_;
<a name="l05237"></a>05237         value_type value_;
<a name="l05238"></a>05238         
<a name="l05239"></a>05239         Impl()
<a name="l05240"></a>05240         : max_weight_(NumericTraits&lt;double&gt;::min()),
<a name="l05241"></a>05241           value_()
<a name="l05242"></a>05242         {}
<a name="l05243"></a>05243         
<a name="l05244"></a>05244         <span class="keywordtype">void</span> reset()
<a name="l05245"></a>05245         {
<a name="l05246"></a>05246             max_weight_ = NumericTraits&lt;double&gt;::min();
<a name="l05247"></a>05247             value_ = element_type();
<a name="l05248"></a>05248         }
<a name="l05249"></a>05249     
<a name="l05250"></a>05250         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Shape&gt;
<a name="l05251"></a>05251         <span class="keywordtype">void</span> reshape(Shape <span class="keyword">const</span> &amp; s)
<a name="l05252"></a>05252         {
<a name="l05253"></a>05253             acc_detail::reshapeImpl(value_, s);
<a name="l05254"></a>05254         }
<a name="l05255"></a>05255         
<a name="l05256"></a>05256         <span class="keywordtype">void</span> <a class="code" href="group__FFTWComplexOperators.html#ga23c9113f38123caf2ae30a59a1a5cfc5" title="add-assignment">operator+=</a>(Impl <span class="keyword">const</span> &amp; o)
<a name="l05257"></a>05257         {
<a name="l05258"></a>05258             <span class="keyword">using namespace </span>multi_math;
<a name="l05259"></a>05259             <span class="keywordflow">if</span>(o.max_weight_ &gt; max_weight_)
<a name="l05260"></a>05260             {
<a name="l05261"></a>05261                 max_weight_ = o.max_weight_;
<a name="l05262"></a>05262                 value_ = o.value_;
<a name="l05263"></a>05263             }
<a name="l05264"></a>05264         }
<a name="l05265"></a>05265     
<a name="l05266"></a>05266         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t)
<a name="l05267"></a>05267         {
<a name="l05268"></a>05268             vigra_precondition(<span class="keyword">false</span>, <span class="stringliteral">&quot;ArgMaxWeight::update() needs weights.&quot;</span>);
<a name="l05269"></a>05269         }
<a name="l05270"></a>05270         
<a name="l05271"></a>05271         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l05272"></a>05272         {
<a name="l05273"></a>05273             <span class="keywordflow">if</span>(weight &gt; max_weight_)
<a name="l05274"></a>05274             {
<a name="l05275"></a>05275                 max_weight_ = weight;
<a name="l05276"></a>05276                 value_ = t;
<a name="l05277"></a>05277             }
<a name="l05278"></a>05278         }
<a name="l05279"></a>05279         
<a name="l05280"></a>05280         result_type operator()()<span class="keyword"> const</span>
<a name="l05281"></a>05281 <span class="keyword">        </span>{
<a name="l05282"></a>05282             <span class="keywordflow">return</span> value_;
<a name="l05283"></a>05283         }
<a name="l05284"></a>05284     };
<a name="l05285"></a>05285 };
<a name="l05286"></a>05286 
<a name="l05287"></a>05287 
<a name="l05288"></a>05288 <span class="keyword">template</span> &lt;<span class="keyword">class</span> BASE, <span class="keywordtype">int</span> BinCount&gt;
<a name="l05289"></a>05289 <span class="keyword">class </span>HistogramBase
<a name="l05290"></a>05290 : <span class="keyword">public</span> BASE
<a name="l05291"></a>05291 {
<a name="l05292"></a>05292   <span class="keyword">public</span>:
<a name="l05293"></a>05293   
<a name="l05294"></a>05294     <span class="keyword">typedef</span> <span class="keywordtype">double</span>                        element_type;
<a name="l05295"></a>05295     <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1TinyVector.html">TinyVector&lt;double, BinCount&gt;</a>  value_type;
<a name="l05296"></a>05296     <span class="keyword">typedef</span> value_type <span class="keyword">const</span> &amp;            result_type;
<a name="l05297"></a>05297     
<a name="l05298"></a>05298     value_type value_;
<a name="l05299"></a>05299     <span class="keywordtype">double</span> left_outliers, right_outliers;
<a name="l05300"></a>05300     
<a name="l05301"></a>05301     HistogramBase()
<a name="l05302"></a>05302     : value_(),
<a name="l05303"></a>05303       left_outliers(), 
<a name="l05304"></a>05304       right_outliers()
<a name="l05305"></a>05305     {}
<a name="l05306"></a>05306     
<a name="l05307"></a>05307     <span class="keywordtype">void</span> reset()
<a name="l05308"></a>05308     {
<a name="l05309"></a>05309         value_ = element_type();
<a name="l05310"></a>05310         left_outliers = 0.0;
<a name="l05311"></a>05311         right_outliers = 0.0;
<a name="l05312"></a>05312     }
<a name="l05313"></a>05313 
<a name="l05314"></a>05314     <span class="keywordtype">void</span> <a class="code" href="group__FFTWComplexOperators.html#ga23c9113f38123caf2ae30a59a1a5cfc5" title="add-assignment">operator+=</a>(HistogramBase <span class="keyword">const</span> &amp; o)
<a name="l05315"></a>05315     {
<a name="l05316"></a>05316         value_ += o.value_;
<a name="l05317"></a>05317         left_outliers += o.left_outliers;
<a name="l05318"></a>05318         right_outliers += o.right_outliers;
<a name="l05319"></a>05319     }
<a name="l05320"></a>05320         
<a name="l05321"></a>05321     result_type operator()()<span class="keyword"> const</span>
<a name="l05322"></a>05322 <span class="keyword">    </span>{
<a name="l05323"></a>05323         <span class="keywordflow">return</span> value_;
<a name="l05324"></a>05324     }
<a name="l05325"></a>05325 };
<a name="l05326"></a>05326 
<a name="l05327"></a>05327 <span class="keyword">template</span> &lt;<span class="keyword">class</span> BASE&gt;
<a name="l05328"></a>05328 <span class="keyword">class </span>HistogramBase&lt;BASE, 0&gt;
<a name="l05329"></a>05329 : <span class="keyword">public</span> BASE
<a name="l05330"></a>05330 {
<a name="l05331"></a>05331   <span class="keyword">public</span>:
<a name="l05332"></a>05332   
<a name="l05333"></a>05333     <span class="keyword">typedef</span> <span class="keywordtype">double</span>                        element_type;
<a name="l05334"></a>05334     <span class="keyword">typedef</span> MultiArray&lt;1, double&gt;         value_type;
<a name="l05335"></a>05335     <span class="keyword">typedef</span> value_type <span class="keyword">const</span> &amp;            result_type;
<a name="l05336"></a>05336     
<a name="l05337"></a>05337     value_type value_;
<a name="l05338"></a>05338     <span class="keywordtype">double</span> left_outliers, right_outliers;
<a name="l05339"></a>05339     
<a name="l05340"></a>05340     HistogramBase()
<a name="l05341"></a>05341     : value_(),
<a name="l05342"></a>05342       left_outliers(), 
<a name="l05343"></a>05343       right_outliers()
<a name="l05344"></a>05344     {}
<a name="l05345"></a>05345     
<a name="l05346"></a>05346     <span class="keywordtype">void</span> reset()
<a name="l05347"></a>05347     {
<a name="l05348"></a>05348         value_ = element_type();
<a name="l05349"></a>05349         left_outliers = 0.0;
<a name="l05350"></a>05350         right_outliers = 0.0;
<a name="l05351"></a>05351     }
<a name="l05352"></a>05352     
<a name="l05353"></a>05353     <span class="keywordtype">void</span> <a class="code" href="group__FFTWComplexOperators.html#ga23c9113f38123caf2ae30a59a1a5cfc5" title="add-assignment">operator+=</a>(HistogramBase <span class="keyword">const</span> &amp; o)
<a name="l05354"></a>05354     {
<a name="l05355"></a>05355         <span class="keywordflow">if</span>(value_.size() == 0)
<a name="l05356"></a>05356         {
<a name="l05357"></a>05357             value_ = o.value_;
<a name="l05358"></a>05358         }
<a name="l05359"></a>05359         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(o.value_.size() &gt; 0)
<a name="l05360"></a>05360         {
<a name="l05361"></a>05361             vigra_precondition(value_.size() == o.value_.size(),
<a name="l05362"></a>05362                 <span class="stringliteral">&quot;HistogramBase::operator+=(): bin counts must be equal.&quot;</span>);
<a name="l05363"></a>05363             value_ += o.value_;
<a name="l05364"></a>05364         }
<a name="l05365"></a>05365         left_outliers += o.left_outliers;
<a name="l05366"></a>05366         right_outliers += o.right_outliers;
<a name="l05367"></a>05367     }
<a name="l05368"></a>05368         
<a name="l05369"></a>05369     <span class="keywordtype">void</span> setBinCount(<span class="keywordtype">int</span> binCount)
<a name="l05370"></a>05370     {
<a name="l05371"></a>05371         vigra_precondition(binCount &gt; 0,
<a name="l05372"></a>05372             <span class="stringliteral">&quot;HistogramBase:.setBinCount(): binCount &gt; 0 required.&quot;</span>);
<a name="l05373"></a>05373         value_type(<a class="code" href="group__MultiIteratorGroup.html#gaf6799170bf47f30c42a3f164f6ccf8ce" title="shape type for MultiArray&lt;1, T&gt;">Shape1</a>(binCount)).swap(value_);
<a name="l05374"></a>05374     }
<a name="l05375"></a>05375 
<a name="l05376"></a>05376     result_type operator()()<span class="keyword"> const</span>
<a name="l05377"></a>05377 <span class="keyword">    </span>{
<a name="l05378"></a>05378         <span class="keywordflow">return</span> value_;
<a name="l05379"></a>05379     }
<a name="l05380"></a>05380 };
<a name="l05381"></a>05381 
<a name="l05382"></a>05382 <span class="keyword">template</span> &lt;<span class="keyword">class</span> BASE, <span class="keywordtype">int</span> BinCount, <span class="keyword">class</span> U=<span class="keyword">typename</span> BASE::input_type&gt;
<a name="l05383"></a>05383 <span class="keyword">class </span>RangeHistogramBase
<a name="l05384"></a>05384 : <span class="keyword">public</span> HistogramBase&lt;BASE, BinCount&gt;
<a name="l05385"></a>05385 {
<a name="l05386"></a>05386   <span class="keyword">public</span>:
<a name="l05387"></a>05387     <span class="keywordtype">double</span> scale_, offset_, inverse_scale_;
<a name="l05388"></a>05388     
<a name="l05389"></a>05389     RangeHistogramBase()
<a name="l05390"></a>05390     : scale_(),
<a name="l05391"></a>05391       offset_(), 
<a name="l05392"></a>05392       inverse_scale_()
<a name="l05393"></a>05393     {}
<a name="l05394"></a>05394     
<a name="l05395"></a>05395     <span class="keywordtype">void</span> reset()
<a name="l05396"></a>05396     {
<a name="l05397"></a>05397         scale_ = 0.0;
<a name="l05398"></a>05398         offset_ = 0.0;
<a name="l05399"></a>05399         inverse_scale_ = 0.0;
<a name="l05400"></a>05400         HistogramBase&lt;BASE, BinCount&gt;::reset();
<a name="l05401"></a>05401     }
<a name="l05402"></a>05402 
<a name="l05403"></a>05403     <span class="keywordtype">void</span> <a class="code" href="group__FFTWComplexOperators.html#ga23c9113f38123caf2ae30a59a1a5cfc5" title="add-assignment">operator+=</a>(RangeHistogramBase <span class="keyword">const</span> &amp; o)
<a name="l05404"></a>05404     {
<a name="l05405"></a>05405         vigra_precondition(scale_ == 0.0 || o.scale_ == 0.0 || (scale_ == o.scale_ &amp;&amp; offset_ == o.offset_),
<a name="l05406"></a>05406             <span class="stringliteral">&quot;RangeHistogramBase::operator+=(): cannot merge histograms with different data mapping.&quot;</span>);
<a name="l05407"></a>05407         
<a name="l05408"></a>05408         <a class="code" href="group__FFTWComplexOperators.html#ga23c9113f38123caf2ae30a59a1a5cfc5" title="add-assignment">HistogramBase&lt;BASE, BinCount&gt;::operator+=</a>(o);
<a name="l05409"></a>05409         <span class="keywordflow">if</span>(scale_ == 0.0)
<a name="l05410"></a>05410         {
<a name="l05411"></a>05411             scale_ = o.scale_;
<a name="l05412"></a>05412             offset_ = o.offset_;
<a name="l05413"></a>05413             inverse_scale_ = o.inverse_scale_;
<a name="l05414"></a>05414         }
<a name="l05415"></a>05415     }
<a name="l05416"></a>05416 
<a name="l05417"></a>05417     <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t)
<a name="l05418"></a>05418     {
<a name="l05419"></a>05419         update(t, 1.0);
<a name="l05420"></a>05420     }
<a name="l05421"></a>05421     
<a name="l05422"></a>05422     <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l05423"></a>05423     {
<a name="l05424"></a>05424         <span class="keywordtype">double</span> m = mapItem(t);
<a name="l05425"></a>05425         <span class="keywordtype">int</span> index =  (m == (double)this-&gt;value_.size())
<a name="l05426"></a>05426                        ? (<span class="keywordtype">int</span>)m - 1
<a name="l05427"></a>05427                        : (int)m;
<a name="l05428"></a>05428         <span class="keywordflow">if</span>(index &lt; 0)
<a name="l05429"></a>05429             this-&gt;left_outliers += weight;
<a name="l05430"></a>05430         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(index &gt;= (<span class="keywordtype">int</span>)this-&gt;value_.size())
<a name="l05431"></a>05431             this-&gt;right_outliers += weight;
<a name="l05432"></a>05432         <span class="keywordflow">else</span>
<a name="l05433"></a>05433             this-&gt;value_[index] += weight;
<a name="l05434"></a>05434     }
<a name="l05435"></a>05435     
<a name="l05436"></a>05436     <span class="keywordtype">void</span> setMinMax(<span class="keywordtype">double</span> mi, <span class="keywordtype">double</span> ma)
<a name="l05437"></a>05437     {
<a name="l05438"></a>05438         vigra_precondition(this-&gt;value_.size() &gt; 0,
<a name="l05439"></a>05439             <span class="stringliteral">&quot;RangeHistogramBase::setMinMax(...): setBinCount(...) has not been called.&quot;</span>);
<a name="l05440"></a>05440         vigra_precondition(mi &lt; ma,
<a name="l05441"></a>05441             <span class="stringliteral">&quot;RangeHistogramBase::setMinMax(...): min &lt; max required.&quot;</span>);
<a name="l05442"></a>05442         offset_ = mi;
<a name="l05443"></a>05443         scale_ = (double)this-&gt;value_.size() / (ma - mi);
<a name="l05444"></a>05444         inverse_scale_ = 1.0 / scale_;
<a name="l05445"></a>05445     }
<a name="l05446"></a>05446     
<a name="l05447"></a>05447     <span class="keywordtype">double</span> mapItem(<span class="keywordtype">double</span> t)<span class="keyword"> const</span>
<a name="l05448"></a>05448 <span class="keyword">    </span>{
<a name="l05449"></a>05449         <span class="keywordflow">return</span> scale_ * (t - offset_);
<a name="l05450"></a>05450     }
<a name="l05451"></a>05451     
<a name="l05452"></a>05452     <span class="keywordtype">double</span> mapItemInverse(<span class="keywordtype">double</span> t)<span class="keyword"> const</span>
<a name="l05453"></a>05453 <span class="keyword">    </span>{
<a name="l05454"></a>05454         <span class="keywordflow">return</span> inverse_scale_ * t + offset_;
<a name="l05455"></a>05455     }
<a name="l05456"></a>05456     
<a name="l05457"></a>05457     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ArrayLike&gt;
<a name="l05458"></a>05458     <span class="keywordtype">void</span> computeStandardQuantiles(<span class="keywordtype">double</span> minimum, <span class="keywordtype">double</span> maximum, <span class="keywordtype">double</span> count, 
<a name="l05459"></a>05459                                   ArrayLike <span class="keyword">const</span> &amp; desiredQuantiles, ArrayLike &amp; res)<span class="keyword"> const</span>
<a name="l05460"></a>05460 <span class="keyword">    </span>{
<a name="l05461"></a>05461         <span class="keywordflow">if</span>(count == 0.0) {
<a name="l05462"></a>05462             <span class="keywordflow">return</span>;
<a name="l05463"></a>05463         }
<a name="l05464"></a>05464         
<a name="l05465"></a>05465         ArrayVector&lt;double&gt; keypoints, cumhist;
<a name="l05466"></a>05466         <span class="keywordtype">double</span> mappedMinimum = mapItem(minimum);
<a name="l05467"></a>05467         <span class="keywordtype">double</span> mappedMaximum = mapItem(maximum);
<a name="l05468"></a>05468         
<a name="l05469"></a>05469         keypoints.push_back(mappedMinimum);
<a name="l05470"></a>05470         cumhist.push_back(0.0);
<a name="l05471"></a>05471         
<a name="l05472"></a>05472         <span class="keywordflow">if</span>(this-&gt;left_outliers &gt; 0.0)
<a name="l05473"></a>05473         {
<a name="l05474"></a>05474             keypoints.push_back(0.0);
<a name="l05475"></a>05475             cumhist.push_back(this-&gt;left_outliers);
<a name="l05476"></a>05476         }
<a name="l05477"></a>05477         
<a name="l05478"></a>05478         <span class="keywordtype">int</span> size = (int)this-&gt;value_.size();
<a name="l05479"></a>05479         <span class="keywordtype">double</span> cumulative = this-&gt;left_outliers;
<a name="l05480"></a>05480         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;size; ++k)
<a name="l05481"></a>05481         {
<a name="l05482"></a>05482             <span class="keywordflow">if</span>(this-&gt;value_[k] &gt; 0.0)
<a name="l05483"></a>05483             {
<a name="l05484"></a>05484                 <span class="keywordflow">if</span>(keypoints.back() &lt;= k)
<a name="l05485"></a>05485                 {
<a name="l05486"></a>05486                     keypoints.push_back(k);
<a name="l05487"></a>05487                     cumhist.push_back(cumulative);
<a name="l05488"></a>05488                 }
<a name="l05489"></a>05489                 cumulative += this-&gt;value_[k];
<a name="l05490"></a>05490                 keypoints.push_back(k+1);
<a name="l05491"></a>05491                 cumhist.push_back(cumulative);
<a name="l05492"></a>05492             }
<a name="l05493"></a>05493         }
<a name="l05494"></a>05494         
<a name="l05495"></a>05495         <span class="keywordflow">if</span>(this-&gt;right_outliers &gt; 0.0)
<a name="l05496"></a>05496         {
<a name="l05497"></a>05497             <span class="keywordflow">if</span>(keypoints.back() != size)
<a name="l05498"></a>05498             {
<a name="l05499"></a>05499                 keypoints.push_back(size);
<a name="l05500"></a>05500                 cumhist.push_back(cumulative);
<a name="l05501"></a>05501             }
<a name="l05502"></a>05502             keypoints.push_back(mappedMaximum);
<a name="l05503"></a>05503             cumhist.push_back(count);
<a name="l05504"></a>05504         }
<a name="l05505"></a>05505         <span class="keywordflow">else</span>
<a name="l05506"></a>05506         {
<a name="l05507"></a>05507             keypoints.back() = mappedMaximum;
<a name="l05508"></a>05508             cumhist.back() = count;
<a name="l05509"></a>05509         }
<a name="l05510"></a>05510         
<a name="l05511"></a>05511         <span class="keywordtype">int</span> quantile = 0, end = (int)desiredQuantiles.size();
<a name="l05512"></a>05512         
<a name="l05513"></a>05513         <span class="keywordflow">if</span>(desiredQuantiles[0] == 0.0)
<a name="l05514"></a>05514         {
<a name="l05515"></a>05515             res[0] = minimum;
<a name="l05516"></a>05516             ++quantile;
<a name="l05517"></a>05517         }
<a name="l05518"></a>05518         <span class="keywordflow">if</span>(desiredQuantiles[end-1] == 1.0)
<a name="l05519"></a>05519         {
<a name="l05520"></a>05520             res[end-1] = maximum;
<a name="l05521"></a>05521             --end;
<a name="l05522"></a>05522         }
<a name="l05523"></a>05523         
<a name="l05524"></a>05524         <span class="keywordtype">int</span> point = 0;
<a name="l05525"></a>05525         <span class="keywordtype">double</span> qcount = count * desiredQuantiles[quantile];
<a name="l05526"></a>05526         <span class="keywordflow">while</span>(quantile &lt; end)
<a name="l05527"></a>05527         {
<a name="l05528"></a>05528             <span class="keywordflow">if</span>(cumhist[point] &lt; qcount &amp;&amp; cumhist[point+1] &gt;= qcount)
<a name="l05529"></a>05529             {
<a name="l05530"></a>05530                 <span class="keywordtype">double</span> t = (qcount - cumhist[point]) / (cumhist[point+1] - cumhist[point]) * (keypoints[point+1] - keypoints[point]);
<a name="l05531"></a>05531                 res[quantile] = mapItemInverse(t + keypoints[point]);
<a name="l05532"></a>05532                 ++quantile;
<a name="l05533"></a>05533                 qcount = count * desiredQuantiles[quantile];
<a name="l05534"></a>05534             }
<a name="l05535"></a>05535             <span class="keywordflow">else</span>
<a name="l05536"></a>05536             {
<a name="l05537"></a>05537                 ++point;
<a name="l05538"></a>05538             }
<a name="l05539"></a>05539         }
<a name="l05540"></a>05540     }
<a name="l05541"></a>05541 };
<a name="l05542"></a>05542 <span class="comment"></span>
<a name="l05543"></a>05543 <span class="comment">/** \brief Histogram where data values are equal to bin indices.</span>
<a name="l05544"></a>05544 <span class="comment"></span>
<a name="l05545"></a>05545 <span class="comment">    - If BinCount != 0, the return type of the accumulator is TinyVector&lt;double, BinCount&gt; .</span>
<a name="l05546"></a>05546 <span class="comment">    - If BinCount == 0, the return type of the accumulator is MultiArray&lt;1, double&gt; . BinCount can be set by calling getAccumulator&lt;IntegerHistogram&lt;0&gt; &gt;(acc_chain).setBinCount(bincount).  </span>
<a name="l05547"></a>05547 <span class="comment">    - Outliers can be accessed via getAccumulator&lt;IntegerHistogram&lt;Bincount&gt;&gt;(a).left_outliers and getAccumulator&lt;...&gt;(acc_chain).right_outliers.</span>
<a name="l05548"></a>05548 <span class="comment">    - Note that histogram options (for all histograms in the accumulator chain) can also be set by passing an instance of HistogramOptions to the accumulator chain via acc_chain.setHistogramOptions().</span>
<a name="l05549"></a>05549 <span class="comment">    Works in pass 1, %operator+=() supported (merging supported).</span>
<a name="l05550"></a>05550 <span class="comment">*/</span>
<a name="l05551"></a>05551 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> BinCount&gt;
<a name="l05552"></a><a class="code" href="classvigra_1_1acc_1_1IntegerHistogram.html">05552</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1IntegerHistogram.html" title="Histogram where data values are equal to bin indices.">IntegerHistogram</a>
<a name="l05553"></a>05553 {
<a name="l05554"></a>05554   <span class="keyword">public</span>:
<a name="l05555"></a>05555     
<a name="l05556"></a>05556     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l05557"></a>05557     
<a name="l05558"></a>05558     <span class="keyword">static</span> std::string name() 
<a name="l05559"></a>05559     { 
<a name="l05560"></a>05560         <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;IntegerHistogram&lt;&quot;</span>) + <a class="code" href="namespacevigra.html#abefdd44c2db13a2b64f36c82d3647b82">asString</a>(BinCount) + <span class="stringliteral">&quot;&gt;&quot;</span>;
<a name="l05561"></a>05561         <span class="comment">// static const std::string n = std::string(&quot;IntegerHistogram&lt;&quot;) + asString(BinCount) + &quot;&gt;&quot;;</span>
<a name="l05562"></a>05562         <span class="comment">// return n;</span>
<a name="l05563"></a>05563     }
<a name="l05564"></a>05564     
<a name="l05565"></a>05565     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l05566"></a>05566     <span class="keyword">struct </span>Impl
<a name="l05567"></a>05567     : <span class="keyword">public</span> HistogramBase&lt;BASE, BinCount&gt;
<a name="l05568"></a>05568     {
<a name="l05569"></a>05569         <span class="keywordtype">void</span> update(<span class="keywordtype">int</span> index)
<a name="l05570"></a>05570         {
<a name="l05571"></a>05571             <span class="keywordflow">if</span>(index &lt; 0)
<a name="l05572"></a>05572                 ++this-&gt;left_outliers;
<a name="l05573"></a>05573             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(index &gt;= (<span class="keywordtype">int</span>)this-&gt;value_.size())
<a name="l05574"></a>05574                 ++this-&gt;right_outliers;
<a name="l05575"></a>05575             <span class="keywordflow">else</span>
<a name="l05576"></a>05576                 ++this-&gt;value_[index];
<a name="l05577"></a>05577         }
<a name="l05578"></a>05578         
<a name="l05579"></a>05579         <span class="keywordtype">void</span> update(<span class="keywordtype">int</span> index, <span class="keywordtype">double</span> weight)
<a name="l05580"></a>05580         {
<a name="l05581"></a>05581             <span class="comment">// cannot compute quantile from weighted integer histograms,</span>
<a name="l05582"></a>05582             <span class="comment">// so force people to use UserRangeHistogram or AutoRangeHistogram</span>
<a name="l05583"></a>05583             vigra_precondition(<span class="keyword">false</span>, <span class="stringliteral">&quot;IntegerHistogram::update(): weighted histograms not supported, use another histogram type.&quot;</span>);
<a name="l05584"></a>05584         }
<a name="l05585"></a>05585     
<a name="l05586"></a>05586         <span class="keyword">template</span> &lt;<span class="keyword">class</span> ArrayLike&gt;
<a name="l05587"></a>05587         <span class="keywordtype">void</span> computeStandardQuantiles(<span class="keywordtype">double</span> minimum, <span class="keywordtype">double</span> maximum, <span class="keywordtype">double</span> count, 
<a name="l05588"></a>05588                                       ArrayLike <span class="keyword">const</span> &amp; desiredQuantiles, ArrayLike &amp; res)<span class="keyword"> const</span>
<a name="l05589"></a>05589 <span class="keyword">        </span>{
<a name="l05590"></a>05590             <span class="keywordtype">int</span> quantile = 0, end = (int)desiredQuantiles.size();
<a name="l05591"></a>05591             
<a name="l05592"></a>05592             <span class="keywordflow">if</span>(desiredQuantiles[0] == 0.0)
<a name="l05593"></a>05593             {
<a name="l05594"></a>05594                 res[0] = minimum;
<a name="l05595"></a>05595                 ++quantile;
<a name="l05596"></a>05596             }
<a name="l05597"></a>05597             <span class="keywordflow">if</span>(desiredQuantiles[end-1] == 1.0)
<a name="l05598"></a>05598             {
<a name="l05599"></a>05599                 res[end-1] = maximum;
<a name="l05600"></a>05600                 --end;
<a name="l05601"></a>05601             }
<a name="l05602"></a>05602             
<a name="l05603"></a>05603             count -= 1.0;
<a name="l05604"></a>05604             <span class="keywordtype">int</span> currentBin = 0, size = (int)this-&gt;value_.size();
<a name="l05605"></a>05605             <span class="keywordtype">double</span> cumulative1 = this-&gt;left_outliers,
<a name="l05606"></a>05606                    cumulative2 = this-&gt;value_[currentBin] + cumulative1;
<a name="l05607"></a>05607             
<a name="l05608"></a>05608             <span class="comment">// add a to the quantiles to account for the fact that counting</span>
<a name="l05609"></a>05609             <span class="comment">// corresponds to 1-based indexing (one element == index 1)</span>
<a name="l05610"></a>05610             <span class="keywordtype">double</span> qcount = desiredQuantiles[quantile]*count + 1.0;
<a name="l05611"></a>05611             
<a name="l05612"></a>05612             <span class="keywordflow">while</span>(quantile &lt; end)
<a name="l05613"></a>05613             {
<a name="l05614"></a>05614                 <span class="keywordflow">if</span>(cumulative2 == qcount)
<a name="l05615"></a>05615                 {
<a name="l05616"></a>05616                     res[quantile] = currentBin;
<a name="l05617"></a>05617                     ++quantile;
<a name="l05618"></a>05618                     qcount = desiredQuantiles[quantile]*count + 1.0;
<a name="l05619"></a>05619                 }
<a name="l05620"></a>05620                 <span class="keywordflow">else</span> <span class="keywordflow">if</span>(cumulative2 &gt; qcount)
<a name="l05621"></a>05621                 {
<a name="l05622"></a>05622                     <span class="keywordflow">if</span>(cumulative1 &gt; qcount) <span class="comment">// in left_outlier bin</span>
<a name="l05623"></a>05623                     {
<a name="l05624"></a>05624                         res[quantile] = minimum;
<a name="l05625"></a>05625                     }
<a name="l05626"></a>05626                     <span class="keywordflow">if</span>(cumulative1 + 1.0 &gt; qcount) <span class="comment">// between bins</span>
<a name="l05627"></a>05627                     {
<a name="l05628"></a>05628                         res[quantile] = currentBin - 1 + qcount - <a class="code" href="group__FixedPointOperations.html#gaf8fe85520fc0bc2d77ec8e6cf26f3c5d" title="rounding down.">std::floor</a>(qcount);
<a name="l05629"></a>05629                     }
<a name="l05630"></a>05630                     <span class="keywordflow">else</span> <span class="comment">// standard case</span>
<a name="l05631"></a>05631                     {
<a name="l05632"></a>05632                         res[quantile] = currentBin;
<a name="l05633"></a>05633                     }
<a name="l05634"></a>05634                     ++quantile;
<a name="l05635"></a>05635                     qcount = desiredQuantiles[quantile]*count + 1.0;
<a name="l05636"></a>05636                 }
<a name="l05637"></a>05637                 <span class="keywordflow">else</span> <span class="keywordflow">if</span>(currentBin == size-1) <span class="comment">// in right outlier bin</span>
<a name="l05638"></a>05638                 {
<a name="l05639"></a>05639                     res[quantile] = maximum;
<a name="l05640"></a>05640                     ++quantile;
<a name="l05641"></a>05641                     qcount = desiredQuantiles[quantile]*count + 1.0;
<a name="l05642"></a>05642                 }
<a name="l05643"></a>05643                 <span class="keywordflow">else</span>
<a name="l05644"></a>05644                 {
<a name="l05645"></a>05645                     ++currentBin;
<a name="l05646"></a>05646                     cumulative1 = cumulative2;
<a name="l05647"></a>05647                     cumulative2 += this-&gt;value_[currentBin];
<a name="l05648"></a>05648                 }
<a name="l05649"></a>05649             }
<a name="l05650"></a>05650         }
<a name="l05651"></a>05651     };
<a name="l05652"></a>05652 };
<a name="l05653"></a>05653 <span class="comment"></span>
<a name="l05654"></a>05654 <span class="comment">/** \brief Histogram where user provides bounds for linear range mapping from values to indices.</span>
<a name="l05655"></a>05655 <span class="comment"></span>
<a name="l05656"></a>05656 <span class="comment">    - If BinCount != 0, the return type of the accumulator is TinyVector&lt;double, BinCount&gt; .</span>
<a name="l05657"></a>05657 <span class="comment">    - If BinCount == 0, the return type of the accumulator is MultiArray&lt;1, double&gt; . BinCount can be set by calling getAccumulator&lt;UserRangeHistogram&lt;0&gt; &gt;(acc_chain).setBinCount(bincount).</span>
<a name="l05658"></a>05658 <span class="comment">    - Bounds for the mapping (min/max) must be set before seeing data by calling getAccumulator&lt;UserRangeHistogram&lt;BinCount&gt; &gt;.setMinMax(min, max).</span>
<a name="l05659"></a>05659 <span class="comment">    - Options can also be passed to the accumulator chain via an instance of HistogramOptions .</span>
<a name="l05660"></a>05660 <span class="comment">    - Works in pass 1, %operator+=() is supported (merging) if both histograms have the same data mapping.</span>
<a name="l05661"></a>05661 <span class="comment">    - Outliers can be accessed via getAccumulator&lt;...&gt;(a).left_outliers and getAccumulator&lt;...&gt;(a).right_outliers.</span>
<a name="l05662"></a>05662 <span class="comment">    - Note that histogram options (for all histograms in the accumulator chain) can also be set by passing an instance of HistogramOptions to the accumulator chain via acc_chain.setHistogramOptions().</span>
<a name="l05663"></a>05663 <span class="comment">*/</span>
<a name="l05664"></a>05664 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> BinCount&gt;
<a name="l05665"></a><a class="code" href="classvigra_1_1acc_1_1UserRangeHistogram.html">05665</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1UserRangeHistogram.html" title="Histogram where user provides bounds for linear range mapping from values to indices.">UserRangeHistogram</a>
<a name="l05666"></a>05666 {
<a name="l05667"></a>05667   <span class="keyword">public</span>:
<a name="l05668"></a>05668     
<a name="l05669"></a>05669     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l05670"></a>05670     
<a name="l05671"></a>05671     <span class="keyword">static</span> std::string name() 
<a name="l05672"></a>05672     { 
<a name="l05673"></a>05673         <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;UserRangeHistogram&lt;&quot;</span>) + <a class="code" href="namespacevigra.html#abefdd44c2db13a2b64f36c82d3647b82">asString</a>(BinCount) + <span class="stringliteral">&quot;&gt;&quot;</span>;
<a name="l05674"></a>05674         <span class="comment">// static const std::string n = std::string(&quot;UserRangeHistogram&lt;&quot;) + asString(BinCount) + &quot;&gt;&quot;;</span>
<a name="l05675"></a>05675         <span class="comment">// return n;</span>
<a name="l05676"></a>05676     }
<a name="l05677"></a>05677     
<a name="l05678"></a>05678     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l05679"></a>05679     <span class="keyword">struct </span>Impl
<a name="l05680"></a>05680     : <span class="keyword">public</span> RangeHistogramBase&lt;BASE, BinCount, U&gt;
<a name="l05681"></a>05681     {
<a name="l05682"></a>05682         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t)
<a name="l05683"></a>05683         {
<a name="l05684"></a>05684             update(t, 1.0);
<a name="l05685"></a>05685         }
<a name="l05686"></a>05686         
<a name="l05687"></a>05687         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l05688"></a>05688         {
<a name="l05689"></a>05689             vigra_precondition(this-&gt;scale_ != 0.0,
<a name="l05690"></a>05690                 <span class="stringliteral">&quot;UserRangeHistogram::update(): setMinMax(...) has not been called.&quot;</span>);
<a name="l05691"></a>05691                 
<a name="l05692"></a>05692             RangeHistogramBase&lt;BASE, BinCount, U&gt;::update(t, weight);
<a name="l05693"></a>05693         }
<a name="l05694"></a>05694     };
<a name="l05695"></a>05695 };
<a name="l05696"></a>05696 <span class="comment"></span>
<a name="l05697"></a>05697 <span class="comment">/** \brief Histogram where range mapping bounds are defined by minimum and maximum of data.</span>
<a name="l05698"></a>05698 <span class="comment"></span>
<a name="l05699"></a>05699 <span class="comment">    - If BinCount != 0, the return type of the accumulator is TinyVector&lt;double, BinCount&gt; .</span>
<a name="l05700"></a>05700 <span class="comment">    - If BinCount == 0, the return type of the accumulator is MultiArray&lt;1, double&gt; . BinCount can be set by calling getAccumulator&lt;AutoRangeHistogram&gt;(acc_chain).setBinCount(bincount).</span>
<a name="l05701"></a>05701 <span class="comment">    - Becomes a UserRangeHistogram if min/max is set.</span>
<a name="l05702"></a>05702 <span class="comment">    - Works in pass 2, %operator+=() is supported (merging) if both histograms have the same data mapping.</span>
<a name="l05703"></a>05703 <span class="comment">    - Outliers can be accessed via getAccumulator&lt;...&gt;(acc_chain).left_outliers and getAccumulator&lt;...&gt;(acc_chain).right_outliers .</span>
<a name="l05704"></a>05704 <span class="comment">    - Note that histogram options (for all histograms in the accumulator chain) can also be set by passing an instance of HistogramOptions to the accumulator chain via acc_chain.setHistogramOptions().</span>
<a name="l05705"></a>05705 <span class="comment">*/</span>
<a name="l05706"></a>05706 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> BinCount&gt;
<a name="l05707"></a><a class="code" href="classvigra_1_1acc_1_1AutoRangeHistogram.html">05707</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1AutoRangeHistogram.html" title="Histogram where range mapping bounds are defined by minimum and maximum of data.">AutoRangeHistogram</a>
<a name="l05708"></a>05708 {
<a name="l05709"></a>05709   <span class="keyword">public</span>:
<a name="l05710"></a>05710     
<a name="l05711"></a>05711     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;Minimum, Maximum&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l05712"></a>05712     
<a name="l05713"></a>05713     <span class="keyword">static</span> std::string name() 
<a name="l05714"></a>05714     { 
<a name="l05715"></a>05715         <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;AutoRangeHistogram&lt;&quot;</span>) + <a class="code" href="namespacevigra.html#abefdd44c2db13a2b64f36c82d3647b82">asString</a>(BinCount) + <span class="stringliteral">&quot;&gt;&quot;</span>;
<a name="l05716"></a>05716         <span class="comment">// static const std::string n = std::string(&quot;AutoRangeHistogram&lt;&quot;) + asString(BinCount) + &quot;&gt;&quot;;</span>
<a name="l05717"></a>05717         <span class="comment">// return n;</span>
<a name="l05718"></a>05718     }
<a name="l05719"></a>05719     
<a name="l05720"></a>05720     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l05721"></a>05721     <span class="keyword">struct </span>Impl
<a name="l05722"></a>05722     : <span class="keyword">public</span> RangeHistogramBase&lt;BASE, BinCount, U&gt;
<a name="l05723"></a>05723     {
<a name="l05724"></a>05724         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> workInPass = LookupDependency&lt;Minimum, BASE&gt;::type::workInPass + 1;
<a name="l05725"></a>05725         
<a name="l05726"></a>05726         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t)
<a name="l05727"></a>05727         {
<a name="l05728"></a>05728             update(t, 1.0);
<a name="l05729"></a>05729         }
<a name="l05730"></a>05730         
<a name="l05731"></a>05731         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l05732"></a>05732         {
<a name="l05733"></a>05733             <span class="keywordflow">if</span>(this-&gt;scale_ == 0.0)
<a name="l05734"></a>05734                 this-&gt;setMinMax(getDependency&lt;Minimum&gt;(*<span class="keyword">this</span>), getDependency&lt;Maximum&gt;(*<span class="keyword">this</span>));
<a name="l05735"></a>05735                 
<a name="l05736"></a>05736             RangeHistogramBase&lt;BASE, BinCount, U&gt;::update(t, weight);
<a name="l05737"></a>05737         }
<a name="l05738"></a>05738     };
<a name="l05739"></a>05739 };
<a name="l05740"></a>05740 <span class="comment"></span>
<a name="l05741"></a>05741 <span class="comment">/** \brief Like AutoRangeHistogram, but use global min/max rather than region min/max.</span>
<a name="l05742"></a>05742 <span class="comment"></span>
<a name="l05743"></a>05743 <span class="comment">    - If BinCount != 0, the return type of the accumulator is TinyVector&lt;double, BinCount&gt; .</span>
<a name="l05744"></a>05744 <span class="comment">    - If BinCount == 0, the return type of the accumulator is MultiArray&lt;1, double&gt; . BinCount can be set by calling getAccumulator&lt;GlobalRangeHistogram&lt;0&gt;&gt;(acc_chain).setBinCount(bincount).</span>
<a name="l05745"></a>05745 <span class="comment">    - Becomes a UserRangeHistogram if min/max is set.</span>
<a name="l05746"></a>05746 <span class="comment">    - Works in pass 2, %operator+=() is supported (merging) if both histograms have the same data mapping.</span>
<a name="l05747"></a>05747 <span class="comment">    - Outliers can be accessed via getAccumulator&lt;GlobalRangeHistogram&lt;Bincount&gt;&gt;(acc_chain).left_outliers and getAccumulator&lt;...&gt;(acc_chain).right_outliers .</span>
<a name="l05748"></a>05748 <span class="comment">    - Histogram options (for all histograms in the accumulator chain) can also be set by passing an instance of HistogramOptions to the accumulator chain via acc_chain.setHistogramOptions().</span>
<a name="l05749"></a>05749 <span class="comment">*/</span>
<a name="l05750"></a>05750 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> BinCount&gt;
<a name="l05751"></a><a class="code" href="classvigra_1_1acc_1_1GlobalRangeHistogram.html">05751</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1GlobalRangeHistogram.html" title="Like AutoRangeHistogram, but use global min/max rather than region min/max.">GlobalRangeHistogram</a>
<a name="l05752"></a>05752 {
<a name="l05753"></a>05753   <span class="keyword">public</span>:
<a name="l05754"></a>05754     
<a name="l05755"></a>05755     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;Global&lt;Minimum&gt;</a>, <a class="code" href="classvigra_1_1acc_1_1Global.html" title="Modifier. Compute statistic globally rather than per region.">Global&lt;Maximum&gt;</a>, <a class="code" href="classvigra_1_1acc_1_1Minimum.html" title="Basic statistic. Minimum value.">Minimum</a>, <a class="code" href="classvigra_1_1acc_1_1Maximum.html" title="Basic statistic. Maximum value.">Maximum</a>&gt; <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l05756"></a>05756     
<a name="l05757"></a>05757     <span class="keyword">static</span> std::string name() 
<a name="l05758"></a>05758     { 
<a name="l05759"></a>05759         <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;GlobalRangeHistogram&lt;&quot;</span>) + <a class="code" href="namespacevigra.html#abefdd44c2db13a2b64f36c82d3647b82">asString</a>(BinCount) + <span class="stringliteral">&quot;&gt;&quot;</span>;
<a name="l05760"></a>05760         <span class="comment">// static const std::string n = std::string(&quot;GlobalRangeHistogram&lt;&quot;) + asString(BinCount) + &quot;&gt;&quot;;</span>
<a name="l05761"></a>05761         <span class="comment">// return n;</span>
<a name="l05762"></a>05762     }
<a name="l05763"></a>05763     
<a name="l05764"></a>05764     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l05765"></a>05765     <span class="keyword">struct </span>Impl
<a name="l05766"></a>05766     : <span class="keyword">public</span> RangeHistogramBase&lt;BASE, BinCount, U&gt;
<a name="l05767"></a>05767     {
<a name="l05768"></a>05768         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> workInPass = LookupDependency&lt;Minimum, BASE&gt;::type::workInPass + 1;
<a name="l05769"></a>05769         
<a name="l05770"></a>05770         <span class="keywordtype">bool</span> useLocalMinimax_;
<a name="l05771"></a>05771         
<a name="l05772"></a>05772         Impl()
<a name="l05773"></a>05773         : useLocalMinimax_(<span class="keyword">false</span>)
<a name="l05774"></a>05774         {}
<a name="l05775"></a>05775         
<a name="l05776"></a>05776         <span class="keywordtype">void</span> setRegionAutoInit(<span class="keywordtype">bool</span> locally)
<a name="l05777"></a>05777         {
<a name="l05778"></a>05778             this-&gt;scale_ = 0.0;
<a name="l05779"></a>05779             useLocalMinimax_ = locally;
<a name="l05780"></a>05780         }
<a name="l05781"></a>05781         
<a name="l05782"></a>05782         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t)
<a name="l05783"></a>05783         {
<a name="l05784"></a>05784             update(t, 1.0);
<a name="l05785"></a>05785         }
<a name="l05786"></a>05786         
<a name="l05787"></a>05787         <span class="keywordtype">void</span> update(U <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span> weight)
<a name="l05788"></a>05788         {
<a name="l05789"></a>05789             <span class="keywordflow">if</span>(this-&gt;scale_ == 0.0)
<a name="l05790"></a>05790             {
<a name="l05791"></a>05791                 <span class="keywordflow">if</span>(useLocalMinimax_)
<a name="l05792"></a>05792                     this-&gt;setMinMax(getDependency&lt;Minimum&gt;(*<span class="keyword">this</span>), getDependency&lt;Maximum&gt;(*<span class="keyword">this</span>));
<a name="l05793"></a>05793                 <span class="keywordflow">else</span>
<a name="l05794"></a>05794                     this-&gt;setMinMax(getDependency&lt;<a class="code" href="classvigra_1_1acc_1_1Global.html" title="Modifier. Compute statistic globally rather than per region.">Global&lt;Minimum&gt;</a> &gt;(*<span class="keyword">this</span>), getDependency&lt;<a class="code" href="classvigra_1_1acc_1_1Global.html" title="Modifier. Compute statistic globally rather than per region.">Global&lt;Maximum&gt;</a> &gt;(*<span class="keyword">this</span>));
<a name="l05795"></a>05795             }
<a name="l05796"></a>05796             
<a name="l05797"></a>05797             RangeHistogramBase&lt;BASE, BinCount, U&gt;::update(t, weight);
<a name="l05798"></a>05798         }
<a name="l05799"></a>05799     };
<a name="l05800"></a>05800 };
<a name="l05801"></a>05801 <span class="comment"></span>
<a name="l05802"></a>05802 <span class="comment">/** \brief Compute (0%, 10%, 25%, 50%, 75%, 90%, 100%) quantiles from given histogram.</span>
<a name="l05803"></a>05803 <span class="comment"></span>
<a name="l05804"></a>05804 <span class="comment">    Return type is TinyVector&lt;double, 7&gt; . </span>
<a name="l05805"></a>05805 <span class="comment">*/</span>
<a name="l05806"></a>05806 <span class="keyword">template</span> &lt;<span class="keyword">class</span> HistogramAccumulator&gt; 
<a name="l05807"></a><a class="code" href="classvigra_1_1acc_1_1StandardQuantiles.html">05807</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1acc_1_1StandardQuantiles.html" title="Compute (0%, 10%, 25%, 50%, 75%, 90%, 100%) quantiles from given histogram.">StandardQuantiles</a>
<a name="l05808"></a>05808 {
<a name="l05809"></a>05809   <span class="keyword">public</span>:
<a name="l05810"></a>05810     
<a name="l05811"></a>05811     <span class="keyword">typedef</span> <span class="keyword">typename</span> StandardizeTag&lt;HistogramAccumulator&gt;::type HistogramTag;
<a name="l05812"></a>05812     <span class="keyword">typedef</span> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Select&lt;HistogramTag, Minimum, Maximum, Count&gt;</a> <a class="code" href="structvigra_1_1acc_1_1Select.html" title="Wrapper for MakeTypeList that additionally performs tag standardization.">Dependencies</a>;
<a name="l05813"></a>05813 
<a name="l05814"></a>05814     <span class="keyword">static</span> std::string name() 
<a name="l05815"></a>05815     { 
<a name="l05816"></a>05816         <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;StandardQuantiles&lt;&quot;</span>) + HistogramTag::name() + <span class="stringliteral">&quot; &gt;&quot;</span>;
<a name="l05817"></a>05817         <span class="comment">// static const std::string n = std::string(&quot;StandardQuantiles&lt;&quot;) + HistogramTag::name() + &quot; &gt;&quot;;</span>
<a name="l05818"></a>05818         <span class="comment">// return n;</span>
<a name="l05819"></a>05819     }
<a name="l05820"></a>05820     
<a name="l05821"></a>05821     <span class="keyword">template</span> &lt;<span class="keyword">class</span> U, <span class="keyword">class</span> BASE&gt;
<a name="l05822"></a>05822     <span class="keyword">struct </span>Impl
<a name="l05823"></a>05823     : <span class="keyword">public</span> CachedResultBase&lt;BASE, TinyVector&lt;double, 7&gt;, U&gt;
<a name="l05824"></a>05824     {
<a name="l05825"></a>05825         <span class="keyword">typedef</span> <span class="keyword">typename</span> CachedResultBase&lt;BASE, TinyVector&lt;double, 7&gt;, U&gt;::result_type result_type;
<a name="l05826"></a>05826         <span class="keyword">typedef</span> <span class="keyword">typename</span> CachedResultBase&lt;BASE, TinyVector&lt;double, 7&gt;, U&gt;::value_type  value_type;
<a name="l05827"></a>05827         
<a name="l05828"></a>05828         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> workInPass = LookupDependency&lt;HistogramTag, BASE&gt;::type::workInPass;
<a name="l05829"></a>05829         
<a name="l05830"></a>05830         result_type operator()()<span class="keyword"> const</span>
<a name="l05831"></a>05831 <span class="keyword">        </span>{
<a name="l05832"></a>05832             <span class="keywordflow">if</span>(this-&gt;isDirty())
<a name="l05833"></a>05833             {
<a name="l05834"></a>05834                 <span class="keywordtype">double</span> desiredQuantiles[] = {0.0, 0.1, 0.25, 0.5, 0.75, 0.9, 1.0 };
<a name="l05835"></a>05835                 getAccumulator&lt;HistogramTag&gt;(*this).computeStandardQuantiles(getDependency&lt;Minimum&gt;(*<span class="keyword">this</span>), getDependency&lt;Maximum&gt;(*<span class="keyword">this</span>), 
<a name="l05836"></a>05836                                                                              getDependency&lt;Count&gt;(*<span class="keyword">this</span>), value_type(desiredQuantiles), 
<a name="l05837"></a>05837                                                                              this-&gt;value_);
<a name="l05838"></a>05838                 this-&gt;setClean();
<a name="l05839"></a>05839             }
<a name="l05840"></a>05840             <span class="keywordflow">return</span> this-&gt;value_;
<a name="l05841"></a>05841         }
<a name="l05842"></a>05842     };
<a name="l05843"></a>05843 };
<a name="l05844"></a>05844 
<a name="l05845"></a>05845 }} <span class="comment">// namespace vigra::acc</span>
<a name="l05846"></a>05846 
<a name="l05847"></a>05847 <span class="preprocessor">#endif // VIGRA_ACCUMULATOR_HXX</span>
</pre></div></div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.9.1 (Thu Sep 5 2013)
</i>
</tr>
</table>


</BODY>
</HTML>
