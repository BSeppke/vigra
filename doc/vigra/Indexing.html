<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Indexing</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://hci.iwr.uni-heidelberg.de/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="contents">
<table class="main_heading">
<tr>
<td width="100%">Indexing 
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<div class="textblock"><h2>Access via coordinates </h2>
<p>Regarding matrices it is common to index the elements with a tuple of coordinates. Using a 3x2 matrix from the section above we can access for instance the element of <code> matrix </code> in the second column and third row by using the MultiArrayShape::type, which is a kind of a TinyVector. For this example we use the type Shape2(x,y), the specific type definition for 2-dimensional arrays.</p>
<p><b> Note: </b> Don't get confused with the indexing of our arrays and matrices. Unfortunately a 3x2-matrix means that the matrix has 3 rows (y-coordinate!) and 2 columns (x-coordinate!). So with Shape2(x,y) you create a y-x-matrix.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #include &lt;vigra/multi_array.hxx&gt;</span>
<span class="preprocessor">    #include &lt;iostream&gt;</span>
          
    <span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv) {

        <span class="comment">// declare 2-dimensional MultiArray with 2 integer elements in first dimension  </span>
        <span class="comment">// and 3 integer elements in second dimension</span>
        <a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;2, int&gt;</a> matrix(<a class="code" href="classvigra_1_1TinyVector.html" title="Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE...">vigra::Shape2</a>(2,3));

        <span class="comment">// set all elements to 3</span>
        matrix.init(3);

        <span class="comment">// print element in second column and third row</span>
        std::cout &lt;&lt; matrix[<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">vigra::Shape2</a>(1,2)] &lt;&lt; std::endl;      <span class="comment">// output: 3</span>

        <span class="keywordflow">return</span> 0;
    }
</pre></div><p>A convenient and equivalent way is just to use the coordinates with round brackets (x,y):</p>
<div class="fragment"><pre class="fragment">        <span class="comment">// access via simple coordinates, set element in second column and third row</span>
        matrix(1,2) = 22;
</pre></div><p>This kind of indexing is only possible if the array's dimension is well known. For generic methods you have to use indexing via Shape-object. In combination with the method size(n), that gives us the size of the n-th dimension, we can use the coordinates to set the element of an entire row or column:</p>
<div class="fragment"><pre class="fragment">        <span class="comment">// set all elements of second column to 13</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; matrix.size(1); i++) {
            matrix(1,i) = 13;
        }
</pre></div><p>Every call with round brackets creates a new Shape-Object. It is better to iterate over a Shape-Object. In the following example, we want to set the 3rd column of a 8x4-matrix (initialized with 5) to 7.</p>
<div class="fragment"><pre class="fragment">        <span class="comment">// iterating over a Shape-Object</span>
        <a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;2, int&gt;</a> matrix84(<a class="code" href="classvigra_1_1TinyVector.html" title="Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE...">vigra::Shape2</a>(4,8));
        matrix84.init(5);
        <span class="comment">// instantiate Shape-Object</span>
        <a class="code" href="classvigra_1_1TinyVector.html" title="Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE...">vigra::Shape2</a> p;
        <span class="comment">// iterate over 3rd column :</span>
        <span class="comment">// set first dimension on 2 (equals 3rd column)</span>
        <span class="comment">// then iterate over second dimension (equals rows)</span>
        p[0] = 2;                                  
        <span class="keywordflow">for</span>(p[1]=0; p[1]&lt;matrix84.<a class="code" href="classvigra_1_1TinyVectorBase.html#a503ab01f6c0142145d3434f6924714e7">size</a>(1); p[1]++) {   
            matrix84[p] = 7;
        }
</pre></div><p>Later in this tutorial, we will discuss special methods to set certain parts of the array.</p>
<hr/>
<h2>One-dimensional []-Operator and StridedScanOrderIterator </h2>
<p>The access via <code> intArray[0] </code> refers to the index of the scan order. Scan order means, that you iterate the dimensions from front to back.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">        #include &lt;vigra/multi_array.hxx&gt;</span>
<span class="preprocessor">        #include &lt;iostream&gt;</span>
        
        <span class="keyword">using namespace </span>vigra;
        
        <span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv) {
        
            <span class="comment">// declare 2-dimensional MultiArray with 3 integer elements in first dimension  </span>
            <span class="comment">// and 2 integer elements in second dimension</span>
            <a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;2, int&gt;</a> intArray(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(3,2));
        
            <span class="comment">// set all elements on 3</span>
            intArray.init(3);
        
            <span class="comment">// print the first element on console</span>
            std::cout &lt;&lt; intArray[0] &lt;&lt; std::endl;
        
            <span class="keywordflow">return</span> 0;
        }
</pre></div><p>The <code> <a class="el" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray</a> </code> - class provides methods to determine the scan order index of given coordinates and vice versa. The <code>StridedScanOrderIterator</code> lets you iterate over the array elements in scan order. You can easily build instances of this Iterator by calling the <code>MultiArrayView::begin()</code> and <code>MultiArrayView::end()</code> methods. To give an example we iterate over all elements and set a new value:</p>
<div class="fragment"><pre class="fragment">        <span class="comment">// declare iterator</span>
        <a class="code" href="classvigra_1_1MultiArray.html#a35c955cacac6aacaa1e82874b1628865">vigra::MultiArray&lt;2, int&gt;::iterator</a> iter;
        <span class="keywordtype">int</span> count = 0;
        <span class="comment">// iterate over intArray, set a new value and print the element</span>
        <span class="keywordflow">for</span> (iter = intArray.<a class="code" href="classvigra_1_1MultiArray.html#ad69bd11391be1a1dba5c8202259664f8">begin</a>(); iter != intArray.<a class="code" href="classvigra_1_1MultiArray.html#acad38d52497a975bfb6f2f6acd76631f">end</a>(); iter++) {
            *iter = ++count;
            std::cout &lt;&lt; *iter &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
        }
        std::cout &lt;&lt; std::endl;
</pre></div><p>This creates the output:</p>
<div class="fragment"><pre class="fragment">
        1 2 3 4 5 6
    </pre></div><p>Let's do some maths: We use the MultiArray class to represent matrices and want to add two 3x3-matrices by adding the elements on the same position. The result will be stored in the first matrix. We can implement the addition like this:</p>
<div class="fragment"><pre class="fragment">        <a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;2, int&gt;</a> matrix1(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(3,3));
        <a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;2, int&gt;</a> matrix2(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(3,3));
        matrix1.init(1);
        matrix2.init(3);
    
        <span class="keywordtype">int</span> size = matrix1.size();          <span class="comment">// number of array elements</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; size; i++) {
            matrix1[i] += matrix2[i];
        }
</pre></div><p>Be careful: The StridedScanOrderIterator doesn't check if the matrices' shapes match to each other.</p>
<div class="fragment"><pre class="fragment">        <a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;2, int&gt;</a> matrix32(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(2,3));
        <a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;2, int&gt;</a> matrix23(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(3,2));
        matrix32.init(1);
        matrix23.init(3);
    
        <span class="keywordtype">int</span> size = matrix32.size();         <span class="comment">// number of array elements</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; size; i++) {
            matrix32[i] += matrix23[i];
        }
</pre></div><p><b> This implementation works but it's probably not what you're mathematically intending to do! </b></p>
<p>By the way: VIGRA provides the += Operator for this purpose and throws an exception if the matrix-sizes don't match:</p>
<div class="fragment"><pre class="fragment">        matrix1 += matrix2;                   <span class="comment">// works fine!</span>
        matrix32 += matrix23;                 <span class="comment">// error: wrong matrix sizes!</span>
</pre></div><p>For further mathematical implementations see <a class="el" href="group__MultiMathModule.html">vigra::multi_math</a> .</p>
<p>VIGRA's scan order is similar to the NumPy-method <code> array.flatten </code>. You use it, to copy a multidimensional array into an one-dimensional array. The only difference is that NumPy uses "C-order" (that means the outmost dimension first), but VIGRA from first to last dimension. A method like flatten can be implemented in VIGRA like this:</p>
<div class="fragment"><pre class="fragment">        <span class="comment">// initialize array for flattening</span>
        <span class="comment">// set first row of matrix23 to 1 2 3, second row to 4 5 6</span>
        count = 0;
        <span class="keywordflow">for</span> (iter = matrix23.<a class="code" href="classvigra_1_1MultiArray.html#ad69bd11391be1a1dba5c8202259664f8">begin</a>(); iter != matrix23.<a class="code" href="classvigra_1_1MultiArray.html#acad38d52497a975bfb6f2f6acd76631f">end</a>(); iter++) {
            *iter = count++;
        }

        <span class="comment">// flatten an array in scan order</span>
        <span class="comment">// create 1D-array of appropriate size</span>
        <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;1, int&gt;</a> flatArray(<a class="code" href="group__MultiIteratorGroup.html#gaf6799170bf47f30c42a3f164f6ccf8ce" title="shape type for MultiArray&lt;1, T&gt;">Shape1</a>(matrix23.size()));
        <span class="comment">// copy 2D-array into 1D-array</span>
        std::copy(matrix23.begin(), matrix23.end(), flatArray.begin());
        
        <span class="comment">// print 1D-array on console; </span>
        <span class="keywordflow">for</span> (iter = flatArray.<a class="code" href="classvigra_1_1MultiArray.html#ad69bd11391be1a1dba5c8202259664f8">begin</a>(); iter != flatArray.<a class="code" href="classvigra_1_1MultiArray.html#acad38d52497a975bfb6f2f6acd76631f">end</a>(); iter++) {
             std::cout &lt;&lt; *iter &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
        }
        std::cout &lt;&lt; std::endl;
</pre></div><p>To show the difference between VIGRA and NumPy we'll add the NumPy output if we had used the flatten-method to the output of the code above</p>
<div class="fragment"><pre class="fragment">
    flatarray - index     0       1       2       3       4       5 
    -----------------------------------------------------------------
    VIGRA-output:         0       1       2       3       4       5
    matrix23 - index    [0,0]   [1,0]   [2,0]   [0,1]   [1,1]   [2,1]
    -----------------------------------------------------------------
    NumPy-output:         0       3       1       4       2       5
    matrix23 - index    [0,0]   [0,1]   [1,0]   [1,1]   [2,0]   [2,1]
    </pre></div><p>However, NumPy's flat-method returns an iterator like matrix23.begin() in VIGRA.</p>
<p>To change the direction of the StridedScanOrderIterator, look at the transpose-function in <a class="el" href="ImportantMethods.html">Important Methods</a> </p>
</div></div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.9.0 (Tue Apr 23 2013)
</i>
</tr>
</table>


</BODY>
</HTML>
