<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Convolution filters for multi-dimensional arrays.</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{ 
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://hci.iwr.uni-heidelberg.de/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" title="Detailed Description" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Convolution filters for multi-dimensional arrays.
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">convolveFFT</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve an array with a kernel by means of the Fourier transform.  <a href="#gaaf819a613a16ee9807d69ecb2d91b2ae"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#ga014b4e7d6d5154d5ad83170c6cb547f6">convolveFFTComplex</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve a complex-valued array by means of the Fourier transform.  <a href="#ga014b4e7d6d5154d5ad83170c6cb547f6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#gaf555ec81ad059261e2bb8b5d03a0aa83">convolveFFTComplexMany</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve a complex-valued array with a sequence of kernels by means of the Fourier transform.  <a href="#gaf555ec81ad059261e2bb8b5d03a0aa83"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#gae2598869b328eae9ff709387e0b758a0">convolveFFTMany</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve a real-valued array with a sequence of kernels by means of the Fourier transform.  <a href="#gae2598869b328eae9ff709387e0b758a0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b">convolveMultiArrayOneDimension</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolution along a single dimension of a multi-dimensional arrays.  <a href="#gac82f89797cb83810e5a9ebddac36259b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe">gaussianDivergenceMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the divergence of a vector field using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative filters.  <a href="#ga63e603a8303c5af14dd8e709a63141fe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552">gaussianGradientMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> gradient of a multi-dimensional arrays.  <a href="#ga4d5e9021732f13248ca3a0fe1b7c0552"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d">gaussianSmoothMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Isotropic <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> smoothing of a multi-dimensional arrays.  <a href="#ga11d81ef630205d44b8517c464217207d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da">hessianOfGaussianMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate Hessian matrix of a N-dimensional arrays using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative filters.  <a href="#gae419814e55fb3191a87e7b75f505d4da"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970">laplacianOfGaussianMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate Laplacian of a N-dimensional arrays using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative filters.  <a href="#gac165234c3bca25d3162cac15ceb2b970"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Separated convolution on multi-dimensional arrays.  <a href="#ga1c43f1c6fd2f6391c7a26de88545b8db"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d">structureTensorMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate th structure tensor of a multi-dimensional arrays.  <a href="#ga6be0fb8e178b6b589e2441cc4ae0f54d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#ga99cfc937dc06355aaf71b551a7c31faa">symmetricGradientMultiArray</a> (...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate gradient of a multi-dimensional arrays using symmetric difference filters.  <a href="#ga99cfc937dc06355aaf71b551a7c31faa"></a><br/></td></tr>
</table>
<hr/><a name="_details" id="details"></a><h2 class="details_section">Detailed Description</h2>
<p>These functions realize a separable convolution on an arbitrary dimensional array that is specified by iterators (compatible to <a class="el" href="MultiIteratorPage.html">Multi-dimensional Array Iterators</a>) and shape objects. It can therefore be applied to a wide range of data structures (<a class="el" href="classvigra_1_1MultiArrayView.html">vigra::MultiArrayView</a>, <a class="el" href="classvigra_1_1MultiArray.html">vigra::MultiArray</a> etc.). </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga1c43f1c6fd2f6391c7a26de88545b8db"></a><!-- doxytag: member="vigra::separableConvolveMultiArray" ref="ga1c43f1c6fd2f6391c7a26de88545b8db" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">vigra::separableConvolveMultiArray</a> </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Separated convolution on multi-dimensional arrays. </p>
<p>This function computes a separated convolution on all dimensions of the given multi-dimensional array. Both source and destination arrays are represented by iterators, shape objects and accessors. The destination array is required to already have the correct size.</p>
<p>There are two variants of this functions: one takes a single kernel of type <a class="el" href="classvigra_1_1Kernel1D.html">vigra::Kernel1D</a> which is then applied to all dimensions, whereas the other requires an iterator referencing a sequence of <a class="el" href="classvigra_1_1Kernel1D.html">vigra::Kernel1D</a> objects, one for every dimension of the data. Then the first kernel in this sequence is applied to the innermost dimension (e.g. the x-axis of an image), while the last is applied to the outermost dimension (e.g. the z-axis in a 3D image).</p>
<p>This function may work in-place, which means that <code>source.data() == dest.data()</code> is allowed. A full-sized internal array is only allocated if working on the destination array directly would cause round-off errors (i.e. if <code>typeid(typename NumericTraits&lt;T2&gt;::RealPromote) != typeid(T2)</code>).</p>
<p>If <code>start</code> and <code>stop</code> have non-default values, they must represent a valid subarray of the input array. The convolution is then restricted to that subarray, and it is assumed that the output array only refers to the subarray (i.e. <code>dest.shape() == stop - start</code>). Negative ROI boundaries are interpreted relative to the end of the respective dimension (i.e. <code>if(stop[k] &lt; 0) stop[k] += source.shape(k);</code>).</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="comment">// apply each kernel from the sequence &#39;kernels&#39; in turn</span>
        <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,
                                  <span class="keyword">class </span>T2, <span class="keyword">class </span>S2, 
                  <span class="keyword">class </span>KernelIterator&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,
                                    MultiArrayView&lt;N, T2, S2&gt; dest, 
                                    KernelIterator kernels,
                                    <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type start = <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type(),
                                    <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type stop  = <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type());

        <span class="comment">// apply the same kernel to all dimensions</span>
        <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,
                                  <span class="keyword">class </span>T2, <span class="keyword">class </span>S2, 
                  <span class="keyword">class </span>T&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,
                                    MultiArrayView&lt;N, T2, S2&gt; dest,
                                    Kernel1D&lt;T&gt; <span class="keyword">const</span> &amp; kernel,
                                    <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type <span class="keyword">const</span> &amp; start = <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type(),
                                    <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type <span class="keyword">const</span> &amp; stop = <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type());
    }
</pre></div><p><a href="#" id="separableConvolveMultiArray_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;separableConvolveMultiArray_OldAPI&apos;, &apos;separableConvolveMultiArray_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="separableConvolveMultiArray_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="comment">// apply the same kernel to all dimensions</span>
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>T&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,
                                    DestIterator diter, DestAccessor dest,
                                    Kernel1D&lt;T&gt; <span class="keyword">const</span> &amp; kernel,
                                    SrcShape <span class="keyword">const</span> &amp; start = SrcShape(),
                                    SrcShape <span class="keyword">const</span> &amp; stop = SrcShape());

        <span class="comment">// apply each kernel from the sequence &#39;kernels&#39; in turn</span>
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>KernelIterator&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,
                                    DestIterator diter, DestAccessor dest,
                                    KernelIterator kernels,
                                    SrcShape <span class="keyword">const</span> &amp; start = SrcShape(),
                                    SrcShape <span class="keyword">const</span> &amp; stop = SrcShape());
    }
</pre></div><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="comment">// apply the same kernel to all dimensions</span>
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>T&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,
                                    pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,
                                    Kernel1D&lt;T&gt; <span class="keyword">const</span> &amp; kernel,
                                    SrcShape <span class="keyword">const</span> &amp; start = SrcShape(),
                                    SrcShape <span class="keyword">const</span> &amp; stop = SrcShape());

        <span class="comment">// apply each kernel from the sequence &#39;kernels&#39; in turn</span>
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>KernelIterator&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,
                                    pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,
                                    KernelIterator kernels,
                                    SrcShape <span class="keyword">const</span> &amp; start = SrcShape(),
                                    SrcShape <span class="keyword">const</span> &amp; stop = SrcShape());
    }
</pre></div> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379" title="shape type for MultiArray&lt;3, T&gt;">Shape3</a> shape(width, height, depth);
    MultiArray&lt;3, unsigned char&gt; source(shape);
    MultiArray&lt;3, float&gt;         dest(shape);
    ...
    Kernel1D&lt;float&gt; gauss;
    gauss.initGaussian(sigma);

    <span class="comment">// smooth all dimensions with the same kernel</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray</a>(source, dest, gauss);
    
    <span class="comment">// create 3 Gauss kernels, one for each dimension, but smooth the z-axis less</span>
    ArrayVector&lt;Kernel1D&lt;float&gt; &gt; kernels(3, gauss);
    kernels[2].initGaussian(sigma / 2.0);

    <span class="comment">// perform Gaussian smoothing on all dimensions</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray</a>(source, dest, kernels.begin());
    
    <span class="comment">// create output array for a ROI</span>
    MultiArray&lt;3, float&gt; destROI(shape - <a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379" title="shape type for MultiArray&lt;3, T&gt;">Shape3</a>(10,10,10));
     
    <span class="comment">// only smooth the given ROI (ignore 5 pixels on all sides of the array)</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray</a>(source, destROI, gauss, <a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379" title="shape type for MultiArray&lt;3, T&gt;">Shape3</a>(5,5,5), <a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379" title="shape type for MultiArray&lt;3, T&gt;">Shape3</a>(-5,-5,-5));
</pre></div><p><a href="#" id="separableConvolveMultiArray_OldUsageToggle" onclick="return toggleHiddenDocumentation(&apos;separableConvolveMultiArray_OldUsage&apos;, &apos;separableConvolveMultiArray_OldUsageToggle&apos;, &apos;deprecated examples&apos;);">show deprecated examples</a></p>
<div id="separableConvolveMultiArray_OldUsage" style="display:none"> <div class="fragment"><pre class="fragment">    MultiArray&lt;3, unsigned char&gt;::size_type shape(width, height, depth);
    MultiArray&lt;3, unsigned char&gt; source(shape);
    MultiArray&lt;3, float&gt; dest(shape);
    ...
    Kernel1D&lt;float&gt; gauss;
    gauss.initGaussian(sigma);
    <span class="comment">// create 3 Gauss kernels, one for each dimension</span>
    ArrayVector&lt;Kernel1D&lt;float&gt; &gt; kernels(3, gauss);

    <span class="comment">// perform Gaussian smoothing on all dimensions</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray</a>(source, dest, 
                                kernels.begin());
</pre></div><p> <b> Required Interface:</b> </p>
<div class="fragment"><pre class="fragment">    see \ref separableConvolveImage(), in addition:

    NumericTraits&lt;T1&gt;::RealPromote s = src[0];

    s = s + s;
    s = kernel(0) * s;
</pre></div> </div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classvigra_1_1Kernel1D.html" title="Generic 1 dimensional convolution kernel.">vigra::Kernel1D</a>, <a class="el" href="group__SeparableConvolution.html#ga68b1efe52c497cfbaece1452515b6307" title="Performs a 1-dimensional convolution of the source signal using the given kernel.">convolveLine()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac82f89797cb83810e5a9ebddac36259b"></a><!-- doxytag: member="vigra::convolveMultiArrayOneDimension" ref="gac82f89797cb83810e5a9ebddac36259b" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__MultiArrayConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b">vigra::convolveMultiArrayOneDimension</a> </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convolution along a single dimension of a multi-dimensional arrays. </p>
<p>This function computes a convolution along one dimension (specified by the parameter <code>dim</code> of the given multi-dimensional array with the given <code>kernel</code>. The destination array must already have the correct size.</p>
<p>If <code>start</code> and <code>stop</code> have non-default values, they must represent a valid subarray of the input array. The convolution is then restricted to that subarray, and it is assumed that the output array only refers to the subarray (i.e. <code>dest.shape() == stop - start</code>). Negative ROI boundaries are interpreted relative to the end of the respective dimension (i.e. <code>if(stop[k] &lt; 0) stop[k] += source.shape(k);</code>).</p>
<p>This function may work in-place, which means that <code>source.data() == dest.data()</code> is allowed.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,
                                  <span class="keyword">class </span>T2, <span class="keyword">class </span>S2, 
                  <span class="keyword">class </span>T&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b" title="Convolution along a single dimension of a multi-dimensional arrays.">convolveMultiArrayOneDimension</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,
                                       MultiArrayView&lt;N, T2, S2&gt; dest,
                                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, 
                                       Kernel1D&lt;T&gt; <span class="keyword">const</span> &amp; kernel,
                                       <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type start = <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type(),
                                       <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type stop  = <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type());
    }
</pre></div><p><a href="#" id="convolveMultiArrayOneDimension_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;convolveMultiArrayOneDimension_OldAPI&apos;, &apos;convolveMultiArrayOneDimension_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="convolveMultiArrayOneDimension_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>T&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b" title="Convolution along a single dimension of a multi-dimensional arrays.">convolveMultiArrayOneDimension</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,
                                       DestIterator diter, DestAccessor dest,
                                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <a class="code" href="classvigra_1_1Kernel1D.html" title="Generic 1 dimensional convolution kernel.">vigra::Kernel1D&lt;T&gt;</a> <span class="keyword">const</span> &amp; kernel,
                                       SrcShape <span class="keyword">const</span> &amp; start = SrcShape(),
                                       SrcShape <span class="keyword">const</span> &amp; stop = SrcShape());
    }
</pre></div><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>T&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b" title="Convolution along a single dimension of a multi-dimensional arrays.">convolveMultiArrayOneDimension</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,
                                       pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,
                                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <a class="code" href="classvigra_1_1Kernel1D.html" title="Generic 1 dimensional convolution kernel.">vigra::Kernel1D&lt;T&gt;</a> <span class="keyword">const</span> &amp; kernel,
                                       SrcShape <span class="keyword">const</span> &amp; start = SrcShape(),
                                       SrcShape <span class="keyword">const</span> &amp; stop = SrcShape());
    }
</pre></div> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379" title="shape type for MultiArray&lt;3, T&gt;">Shape3</a> shape(width, height, depth);
    MultiArray&lt;3, unsigned char&gt; source(shape);
    MultiArray&lt;3, float&gt; dest(shape);
    ...
    Kernel1D&lt;float&gt; gauss;
    gauss.initGaussian(sigma);

    <span class="comment">// perform Gaussian smoothing along dimension 1 (height)</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b" title="Convolution along a single dimension of a multi-dimensional arrays.">convolveMultiArrayOneDimension</a>(source, dest, 1, gauss);
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga11d81ef630205d44b8517c464217207d"></a><!-- doxytag: member="vigra::gaussianSmoothMultiArray" ref="ga11d81ef630205d44b8517c464217207d" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__MultiArrayConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d">vigra::gaussianSmoothMultiArray</a> </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Isotropic <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> smoothing of a multi-dimensional arrays. </p>
<p>This function computes an isotropic convolution of the given N-dimensional array with a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> filter at the given standard deviation <code>sigma</code>. Both source and destination arrays are represented by iterators, shape objects and accessors. The destination array is required to already have the correct size. This function may work in-place, which means that <code>source.data() == dest.data()</code> is allowed. It is implemented by a call to <a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray()</a> with the appropriate kernel.</p>
<p>Anisotropic data should be passed with appropriate <a class="el" href="classvigra_1_1ConvolutionOptions.html">ConvolutionOptions</a>, the parameter <code>opt</code> is otherwise optional unless the parameter <code>sigma</code> is omitted.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="comment">// pass filter scale explicitly</span>
        <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,
                                  <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d" title="Isotropic Gaussian smoothing of a multi-dimensional arrays.">gaussianSmoothMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,
                                 MultiArrayView&lt;N, T2, S2&gt; dest,
                                 <span class="keywordtype">double</span> sigma,
                                 ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());

        <span class="comment">// pass filer scale(s) in the option object</span>
        <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,
                                  <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d" title="Isotropic Gaussian smoothing of a multi-dimensional arrays.">gaussianSmoothMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,
                                 MultiArrayView&lt;N, T2, S2&gt; dest,
                                 ConvolutionOptions&lt;N&gt; opt);
    }
</pre></div><p><a href="#" id="gaussianSmoothMultiArray_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;gaussianSmoothMultiArray_OldAPI&apos;, &apos;gaussianSmoothMultiArray_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="gaussianSmoothMultiArray_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d" title="Isotropic Gaussian smoothing of a multi-dimensional arrays.">gaussianSmoothMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,
                                 DestIterator diter, DestAccessor dest,
                                 <span class="keywordtype">double</span> sigma,
                                 <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());
    }
</pre></div><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d" title="Isotropic Gaussian smoothing of a multi-dimensional arrays.">gaussianSmoothMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,
                                 pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,
                                 <span class="keywordtype">double</span> sigma,
                                 <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());
    }
</pre></div> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379" title="shape type for MultiArray&lt;3, T&gt;">Shape3</a> shape(width, height, depth);
    MultiArray&lt;3, unsigned char&gt; source(shape);
    MultiArray&lt;3, float&gt;         dest(shape);
    ...
    <span class="comment">// perform isotropic Gaussian smoothing at scale &#39;sigma&#39;</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d" title="Isotropic Gaussian smoothing of a multi-dimensional arrays.">gaussianSmoothMultiArray</a>(source, dest, sigma);
</pre></div><p><b> Usage with anisotropic data:</b></p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379" title="shape type for MultiArray&lt;3, T&gt;">Shape3</a> shape(width, height, depth);
    MultiArray&lt;3, unsigned char&gt; source(shape);
    MultiArray&lt;3, float&gt;         dest(shape);
    TinyVector&lt;float, 3&gt; step_size;
    TinyVector&lt;float, 3&gt; resolution_sigmas;
    ...
    <span class="comment">// perform anisotropic Gaussian smoothing at scale &#39;sigma&#39;</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d" title="Isotropic Gaussian smoothing of a multi-dimensional arrays.">gaussianSmoothMultiArray</a>(source, dest, sigma,
                             ConvolutionOptions&lt;3&gt;().stepSize(step_size).resolutionStdDev(resolution_sigmas));
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d5e9021732f13248ca3a0fe1b7c0552"></a><!-- doxytag: member="vigra::gaussianGradientMultiArray" ref="ga4d5e9021732f13248ca3a0fe1b7c0552" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__MultiArrayConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552">vigra::gaussianGradientMultiArray</a> </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> gradient of a multi-dimensional arrays. </p>
<p>This function computes the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> gradient of the given N-dimensional array with a sequence of first-derivative-of-Gaussian filters at the given standard deviation <code>sigma</code> (differentiation is applied to each dimension in turn, starting with the innermost dimension). The destination array is required to have a vector valued pixel type with as many elements as the number of dimensions. This function is implemented by calls to <a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray()</a> with the appropriate kernels.</p>
<p>Anisotropic data should be passed with appropriate <a class="el" href="classvigra_1_1ConvolutionOptions.html">ConvolutionOptions</a>, the parameter <code>opt</code> is otherwise optional unless the parameter <code>sigma</code> is omitted.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="comment">// pass filter scale explicitly</span>
        <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,
                  <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552" title="Calculate Gaussian gradient of a multi-dimensional arrays.">gaussianGradientMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,
                                   MultiArrayView&lt;N, TinyVector&lt;T2, N&gt;, S2&gt; dest,
                                   <span class="keywordtype">double</span> sigma,
                                   ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());

        <span class="comment">// pass filter scale(s) in option object</span>
        <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,
                                  <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552" title="Calculate Gaussian gradient of a multi-dimensional arrays.">gaussianGradientMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,
                                   MultiArrayView&lt;N, TinyVector&lt;T2, N&gt;, S2&gt; dest,
                                   ConvolutionOptions&lt;N&gt; opt);
    }
</pre></div><p><a href="#" id="gaussianGradientMultiArray_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;gaussianGradientMultiArray_OldAPI&apos;, &apos;gaussianGradientMultiArray_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="gaussianGradientMultiArray_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552" title="Calculate Gaussian gradient of a multi-dimensional arrays.">gaussianGradientMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,
                                   DestIterator diter, DestAccessor dest,
                                   <span class="keywordtype">double</span> sigma, 
                                   <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());
    }
</pre></div><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552" title="Calculate Gaussian gradient of a multi-dimensional arrays.">gaussianGradientMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,
                                   pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,
                                   <span class="keywordtype">double</span> sigma,
                                   <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());
    }
</pre></div> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379" title="shape type for MultiArray&lt;3, T&gt;">Shape3</a> shape(width, height, depth);
    MultiArray&lt;3, unsigned char&gt; source(shape);
    MultiArray&lt;3, TinyVector&lt;float, 3&gt; &gt; dest(shape);
    ...
    <span class="comment">// compute Gaussian gradient at scale sigma</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552" title="Calculate Gaussian gradient of a multi-dimensional arrays.">gaussianGradientMultiArray</a>(source, dest, sigma);
</pre></div><p><b> Usage with anisotropic data:</b></p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379" title="shape type for MultiArray&lt;3, T&gt;">Shape3</a> shape(width, height, depth);
    MultiArray&lt;3, unsigned char&gt; source(shape);
    MultiArray&lt;3, TinyVector&lt;float, 3&gt; &gt; dest(shape);
    TinyVector&lt;float, 3&gt; step_size;
    TinyVector&lt;float, 3&gt; resolution_sigmas;
    ...
    <span class="comment">// compute Gaussian gradient at scale sigma</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552" title="Calculate Gaussian gradient of a multi-dimensional arrays.">gaussianGradientMultiArray</a>(source, dest, sigma,
                               ConvolutionOptions&lt;3&gt;().stepSize(step_size).resolutionStdDev(resolution_sigmas));
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga99cfc937dc06355aaf71b551a7c31faa"></a><!-- doxytag: member="vigra::symmetricGradientMultiArray" ref="ga99cfc937dc06355aaf71b551a7c31faa" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__MultiArrayConvolutionFilters.html#ga99cfc937dc06355aaf71b551a7c31faa">vigra::symmetricGradientMultiArray</a> </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate gradient of a multi-dimensional arrays using symmetric difference filters. </p>
<p>This function computes the gradient of the given N-dimensional array with a sequence of symmetric difference filters a (differentiation is applied to each dimension in turn, starting with the innermost dimension). The destination array is required to have a vector valued pixel type with as many elements as the number of dimensions. This function is implemented by calls to <a class="el" href="group__MultiArrayConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b">convolveMultiArrayOneDimension()</a> with the symmetric difference kernel.</p>
<p>Anisotropic data should be passed with appropriate <a class="el" href="classvigra_1_1ConvolutionOptions.html">ConvolutionOptions</a>, the parameter <code>opt</code> is optional otherwise.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,
                                  <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga99cfc937dc06355aaf71b551a7c31faa" title="Calculate gradient of a multi-dimensional arrays using symmetric difference filters.">symmetricGradientMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,
                                    MultiArrayView&lt;N, TinyVector&lt;T2, N&gt;, S2&gt; dest,
                                    ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());
    }
</pre></div><p><a href="#" id="symmetricGradientMultiArray_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;symmetricGradientMultiArray_OldAPI&apos;, &apos;symmetricGradientMultiArray_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="symmetricGradientMultiArray_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga99cfc937dc06355aaf71b551a7c31faa" title="Calculate gradient of a multi-dimensional arrays using symmetric difference filters.">symmetricGradientMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,
                                    DestIterator diter, DestAccessor dest,
                                    <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());
    }
</pre></div><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga99cfc937dc06355aaf71b551a7c31faa" title="Calculate gradient of a multi-dimensional arrays using symmetric difference filters.">symmetricGradientMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,
                                    pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,
                                    <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());
    }
</pre></div> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;3, unsigned char&gt;::size_type shape(width, height, depth);
    MultiArray&lt;3, unsigned char&gt; source(shape);
    MultiArray&lt;3, TinyVector&lt;float, 3&gt; &gt; dest(shape);
    ...
    <span class="comment">// compute gradient</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga99cfc937dc06355aaf71b551a7c31faa" title="Calculate gradient of a multi-dimensional arrays using symmetric difference filters.">symmetricGradientMultiArray</a>(srcMultiArrayRange(source), destMultiArray(dest));
</pre></div><p><b> Usage with anisotropic data:</b></p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379" title="shape type for MultiArray&lt;3, T&gt;">Shape3</a> shape(width, height, depth);
    MultiArray&lt;3, unsigned char&gt; source(shape);
    MultiArray&lt;3, TinyVector&lt;float, 3&gt; &gt; dest(shape);
    TinyVector&lt;float, 3&gt; step_size;
    ...
    <span class="comment">// compute gradient</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga99cfc937dc06355aaf71b551a7c31faa" title="Calculate gradient of a multi-dimensional arrays using symmetric difference filters.">symmetricGradientMultiArray</a>(source, dest,
                                ConvolutionOptions&lt;3&gt;().stepSize(step_size));
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__MultiArrayConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b" title="Convolution along a single dimension of a multi-dimensional arrays.">convolveMultiArrayOneDimension()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac165234c3bca25d3162cac15ceb2b970"></a><!-- doxytag: member="vigra::laplacianOfGaussianMultiArray" ref="gac165234c3bca25d3162cac15ceb2b970" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__MultiArrayConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970">vigra::laplacianOfGaussianMultiArray</a> </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate Laplacian of a N-dimensional arrays using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative filters. </p>
<p>This function computes the Laplacian of the given N-dimensional array with a sequence of second-derivative-of-Gaussian filters at the given standard deviation <code>sigma</code>. Both source and destination arrays must have scalar value_type. This function is implemented by calls to <a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray()</a> with the appropriate kernels, followed by summation.</p>
<p>Anisotropic data should be passed with appropriate <a class="el" href="classvigra_1_1ConvolutionOptions.html">ConvolutionOptions</a>, the parameter <code>opt</code> is otherwise optional unless the parameter <code>sigma</code> is left out.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="comment">// pass scale explicitly</span>
        <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,
                  <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970" title="Calculate Laplacian of a N-dimensional arrays using Gaussian derivative filters.">laplacianOfGaussianMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,
                                      MultiArrayView&lt;N, T2, S2&gt; dest,
                                      <span class="keywordtype">double</span> sigma,
                                      ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());
        
        <span class="comment">// pass scale(s) in option object</span>
        <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,
                  <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970" title="Calculate Laplacian of a N-dimensional arrays using Gaussian derivative filters.">laplacianOfGaussianMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,
                                      MultiArrayView&lt;N, T2, S2&gt; dest,
                                      ConvolutionOptions&lt;N&gt; opt );
    }
</pre></div><p><a href="#" id="laplacianOfGaussianMultiArray_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;laplacianOfGaussianMultiArray_OldAPI&apos;, &apos;laplacianOfGaussianMultiArray_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="laplacianOfGaussianMultiArray_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970" title="Calculate Laplacian of a N-dimensional arrays using Gaussian derivative filters.">laplacianOfGaussianMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,
                                      DestIterator diter, DestAccessor dest,
                                      <span class="keywordtype">double</span> sigma,
                                      <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());
    }
</pre></div><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970" title="Calculate Laplacian of a N-dimensional arrays using Gaussian derivative filters.">laplacianOfGaussianMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,
                                      pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,
                                      <span class="keywordtype">double</span> sigma,
                                      <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());
    }
</pre></div> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379" title="shape type for MultiArray&lt;3, T&gt;">Shape3</a> shape(width, height, depth);
    MultiArray&lt;3, float&gt; source(shape);
    MultiArray&lt;3, float&gt; laplacian(shape);
    ...
    <span class="comment">// compute Laplacian at scale sigma</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970" title="Calculate Laplacian of a N-dimensional arrays using Gaussian derivative filters.">laplacianOfGaussianMultiArray</a>(source, laplacian, sigma);
</pre></div><p><b> Usage with anisotropic data:</b></p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;3, float&gt; source(shape);
    MultiArray&lt;3, float&gt; laplacian(shape);
    TinyVector&lt;float, 3&gt; step_size;
    TinyVector&lt;float, 3&gt; resolution_sigmas;
    ...
    <span class="comment">// compute Laplacian at scale sigma</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970" title="Calculate Laplacian of a N-dimensional arrays using Gaussian derivative filters.">laplacianOfGaussianMultiArray</a>(source, laplacian, sigma,
                                  ConvolutionOptions&lt;3&gt;().stepSize(step_size).resolutionStdDev(resolution_sigmas));
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga63e603a8303c5af14dd8e709a63141fe"></a><!-- doxytag: member="vigra::gaussianDivergenceMultiArray" ref="ga63e603a8303c5af14dd8e709a63141fe" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__MultiArrayConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe">vigra::gaussianDivergenceMultiArray</a> </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the divergence of a vector field using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative filters. </p>
<p>This function computes the divergence of the given N-dimensional vector field with a sequence of first-derivative-of-Gaussian filters at the given standard deviation <code>sigma</code>. The input vector field can either be given as a sequence of scalar array views (one for each vector field component), represented by an iterator range, or by a single vector array with the appropriate shape. This function is implemented by calls to <a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray()</a> with the suitable kernels, followed by summation.</p>
<p>Anisotropic data should be passed with appropriate <a class="el" href="classvigra_1_1ConvolutionOptions.html">ConvolutionOptions</a>, the parameter <code>opt</code> is otherwise optional unless the parameter <code>sigma</code> is omitted.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="comment">// specify input vector field as a sequence of scalar arrays</span>
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>Iterator, 
                  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T, <span class="keyword">class </span>S&gt;
        <span class="keywordtype">void</span> 
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe" title="Calculate the divergence of a vector field using Gaussian derivative filters.">gaussianDivergenceMultiArray</a>(Iterator vectorField, Iterator vectorFieldEnd,
                                     MultiArrayView&lt;N, T, S&gt; divergence,
                                     ConvolutionOptions&lt;N&gt; <span class="keyword">const</span> &amp; opt);
        
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>Iterator, 
                  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T, <span class="keyword">class </span>S&gt;
        <span class="keywordtype">void</span> 
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe" title="Calculate the divergence of a vector field using Gaussian derivative filters.">gaussianDivergenceMultiArray</a>(Iterator vectorField, Iterator vectorFieldEnd,
                                     MultiArrayView&lt;N, T, S&gt; divergence,
                                     <span class="keywordtype">double</span> sigma,
                                     ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());
        
        <span class="comment">// pass input vector field as an array of vectors</span>
        <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,
                                  <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;
        <span class="keywordtype">void</span> 
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe" title="Calculate the divergence of a vector field using Gaussian derivative filters.">gaussianDivergenceMultiArray</a>(MultiArrayView&lt;N, TinyVector&lt;T1, N&gt;, S1&gt; <span class="keyword">const</span> &amp; vectorField,
                                     MultiArrayView&lt;N, T2, S2&gt; divergence,
                                     ConvolutionOptions&lt;N&gt; <span class="keyword">const</span> &amp; opt);
                                     
        <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,
                                  <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;
        <span class="keywordtype">void</span> 
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe" title="Calculate the divergence of a vector field using Gaussian derivative filters.">gaussianDivergenceMultiArray</a>(MultiArrayView&lt;N, TinyVector&lt;T1, N&gt;, S1&gt; <span class="keyword">const</span> &amp; vectorField,
                                     MultiArrayView&lt;N, T2, S2&gt; divergence,
                                     <span class="keywordtype">double</span> sigma,
                                     ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());
    }
</pre></div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379" title="shape type for MultiArray&lt;3, T&gt;">Shape3</a> shape(width, height, depth);
    MultiArray&lt;3, TinyVector&lt;float, 3&gt; &gt; source(shape);
    MultiArray&lt;3, float&gt; laplacian(shape);
    ...
    <span class="comment">// compute divergence at scale sigma</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe" title="Calculate the divergence of a vector field using Gaussian derivative filters.">gaussianDivergenceMultiArray</a>(source, laplacian, sigma);
</pre></div><p><b> Usage with anisotropic data:</b></p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;3, TinyVector&lt;float, 3&gt; &gt; source(shape);
    MultiArray&lt;3, float&gt; laplacian(shape);
    TinyVector&lt;float, 3&gt; step_size;
    TinyVector&lt;float, 3&gt; resolution_sigmas;
    ...
    <span class="comment">// compute divergence at scale sigma</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe" title="Calculate the divergence of a vector field using Gaussian derivative filters.">gaussianDivergenceMultiArray</a>(source, laplacian, sigma,
                                 ConvolutionOptions&lt;3&gt;().stepSize(step_size).resolutionStdDev(resolution_sigmas));
</pre></div> 
</div>
</div>
<a class="anchor" id="gae419814e55fb3191a87e7b75f505d4da"></a><!-- doxytag: member="vigra::hessianOfGaussianMultiArray" ref="gae419814e55fb3191a87e7b75f505d4da" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__MultiArrayConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da">vigra::hessianOfGaussianMultiArray</a> </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate Hessian matrix of a N-dimensional arrays using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative filters. </p>
<p>This function computes the Hessian matrix the given scalar N-dimensional array with a sequence of second-derivative-of-Gaussian filters at the given standard deviation <code>sigma</code>. The destination array must have a vector valued element type with N*(N+1)/2 elements (it represents the upper triangular part of the symmetric Hessian matrix, flattened row-wise). This function is implemented by calls to <a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray()</a> with the appropriate kernels.</p>
<p>Anisotropic data should be passed with appropriate <a class="el" href="classvigra_1_1ConvolutionOptions.html">ConvolutionOptions</a>, the parameter <code>opt</code> is otherwise optional unless the parameter <code>sigma</code> is omitted.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="comment">// pass scale explicitly</span>
        <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,
                                  <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da" title="Calculate Hessian matrix of a N-dimensional arrays using Gaussian derivative filters.">hessianOfGaussianMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,
                                    MultiArrayView&lt;N, TinyVector&lt;T2, <span class="keywordtype">int</span>(N*(N+1)/2)&gt;, S2&gt; dest,
                                    <span class="keywordtype">double</span> sigma,
                                    ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());
        
        <span class="comment">// pass scale(s) in option object</span>
        <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,
                                  <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da" title="Calculate Hessian matrix of a N-dimensional arrays using Gaussian derivative filters.">hessianOfGaussianMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,
                                    MultiArrayView&lt;N, TinyVector&lt;T2, <span class="keywordtype">int</span>(N*(N+1)/2)&gt;, S2&gt; dest,
                                    ConvolutionOptions&lt;N&gt; opt);
    }
</pre></div><p><a href="#" id="hessianOfGaussianMultiArray_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;hessianOfGaussianMultiArray_OldAPI&apos;, &apos;hessianOfGaussianMultiArray_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="hessianOfGaussianMultiArray_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da" title="Calculate Hessian matrix of a N-dimensional arrays using Gaussian derivative filters.">hessianOfGaussianMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,
                                    DestIterator diter, DestAccessor dest,
                                    <span class="keywordtype">double</span> sigma,
                                    <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());
    }
</pre></div><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da" title="Calculate Hessian matrix of a N-dimensional arrays using Gaussian derivative filters.">hessianOfGaussianMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,
                                    pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,
                                    <span class="keywordtype">double</span> sigma,
                                    <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());
    }
</pre></div> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379" title="shape type for MultiArray&lt;3, T&gt;">Shape3</a> shape(width, height, depth);
    MultiArray&lt;3, float&gt; source(shape);
    MultiArray&lt;3, TinyVector&lt;float, 6&gt; &gt; dest(shape);
    ...
    <span class="comment">// compute Hessian at scale sigma</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da" title="Calculate Hessian matrix of a N-dimensional arrays using Gaussian derivative filters.">hessianOfGaussianMultiArray</a>(source, dest, sigma);
</pre></div><p><b> Usage with anisotropic data:</b></p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;3, float&gt; source(shape);
    MultiArray&lt;3, TinyVector&lt;float, 6&gt; &gt; dest(shape);
    TinyVector&lt;float, 3&gt; step_size;
    TinyVector&lt;float, 3&gt; resolution_sigmas;
    ...
    <span class="comment">// compute Hessian at scale sigma</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da" title="Calculate Hessian matrix of a N-dimensional arrays using Gaussian derivative filters.">hessianOfGaussianMultiArray</a>(source, dest, sigma,
                                ConvolutionOptions&lt;3&gt;().stepSize(step_size).resolutionStdDev(resolution_sigmas));
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray()</a>, <a class="el" href="group__MultiPointoperators.html#gad869b7b263b104e005a1ddc66b5c1f80" title="Calculate the tensor (outer) product of a N-D vector with itself.">vectorToTensorMultiArray()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6be0fb8e178b6b589e2441cc4ae0f54d"></a><!-- doxytag: member="vigra::structureTensorMultiArray" ref="ga6be0fb8e178b6b589e2441cc4ae0f54d" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__MultiArrayConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d">vigra::structureTensorMultiArray</a> </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate th structure tensor of a multi-dimensional arrays. </p>
<p>This function computes the gradient (outer product) tensor for each element of the given N-dimensional array with first-derivative-of-Gaussian filters at the given <code>innerScale</code>, followed by <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> smoothing at <code>outerScale</code>. The destination array must have a vector valued pixel type with N*(N+1)/2 elements (it represents the upper triangular part of the symmetric structure tensor matrix, flattened row-wise). If the source array is also vector valued, the resulting structure tensor is the sum of the individual tensors for each channel. This function is implemented by calls to <a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray()</a> with the appropriate kernels.</p>
<p>Anisotropic data should be passed with appropriate <a class="el" href="classvigra_1_1ConvolutionOptions.html">ConvolutionOptions</a>, the parameter <code>opt</code> is otherwise optional unless the parameters <code>innerScale</code> and <code>outerScale</code> are both omitted.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="comment">// pass scales explicitly</span>
        <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,
                                  <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d" title="Calculate th structure tensor of a multi-dimensional arrays.">structureTensorMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,
                                  MultiArrayView&lt;N, TinyVector&lt;T2, <span class="keywordtype">int</span>(N*(N+1)/2)&gt;, S2&gt; dest,
                                  <span class="keywordtype">double</span> innerScale, <span class="keywordtype">double</span> outerScale,
                                  ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());
        
        <span class="comment">// pass scales in option object</span>
        <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,
                                  <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d" title="Calculate th structure tensor of a multi-dimensional arrays.">structureTensorMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,
                                  MultiArrayView&lt;N, TinyVector&lt;T2, <span class="keywordtype">int</span>(N*(N+1)/2)&gt;, S2&gt; dest, 
                                  ConvolutionOptions&lt;N&gt; opt );
    }
</pre></div><p><a href="#" id="structureTensorMultiArray_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;structureTensorMultiArray_OldAPI&apos;, &apos;structureTensorMultiArray_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="structureTensorMultiArray_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d" title="Calculate th structure tensor of a multi-dimensional arrays.">structureTensorMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,
                                  DestIterator diter, DestAccessor dest,
                                  <span class="keywordtype">double</span> innerScale, <span class="keywordtype">double</span> outerScale,
                                  ConvolutionOptions&lt;N&gt; opt);
    }
</pre></div><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d" title="Calculate th structure tensor of a multi-dimensional arrays.">structureTensorMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,
                                  pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,
                                  <span class="keywordtype">double</span> innerScale, <span class="keywordtype">double</span> outerScale,
                                  <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt);
    }
</pre></div> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379" title="shape type for MultiArray&lt;3, T&gt;">Shape3</a> shape(width, height, depth);
    MultiArray&lt;3, RGBValue&lt;float&gt; &gt; source(shape);
    MultiArray&lt;3, TinyVector&lt;float, 6&gt; &gt; dest(shape);
    ...
    <span class="comment">// compute structure tensor at scales innerScale and outerScale</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d" title="Calculate th structure tensor of a multi-dimensional arrays.">structureTensorMultiArray</a>(source, dest, innerScale, outerScale);
</pre></div><p><b> Usage with anisotropic data:</b></p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;3, RGBValue&lt;float&gt; &gt; source(shape);
    MultiArray&lt;3, TinyVector&lt;float, 6&gt; &gt; dest(shape);
    TinyVector&lt;float, 3&gt; step_size;
    TinyVector&lt;float, 3&gt; resolution_sigmas;
    ...
    <span class="comment">// compute structure tensor at scales innerScale and outerScale</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d" title="Calculate th structure tensor of a multi-dimensional arrays.">structureTensorMultiArray</a>(source, dest, innerScale, outerScale,
                              ConvolutionOptions&lt;3&gt;().stepSize(step_size).resolutionStdDev(resolution_sigmas));
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray()</a>, <a class="el" href="group__MultiPointoperators.html#gad869b7b263b104e005a1ddc66b5c1f80" title="Calculate the tensor (outer) product of a N-D vector with itself.">vectorToTensorMultiArray()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf819a613a16ee9807d69ecb2d91b2ae"></a><!-- doxytag: member="vigra::convolveFFT" ref="gaaf819a613a16ee9807d69ecb2d91b2ae" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__MultiArrayConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">vigra::convolveFFT</a> </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convolve an array with a kernel by means of the Fourier transform. </p>
<p>Thanks to the convolution theorem of Fourier theory, a convolution in the spatial domain is equivalent to a multiplication in the frequency domain. Thus, for certain kernels (especially large, non-separable ones), it is advantageous to perform the convolution by first transforming both array and kernel to the frequency domain, multiplying the frequency representations, and transforming the result back into the spatial domain. Some kernels have a much simpler definition in the frequency domain, so that they are readily computed there directly, avoiding Fourier transformation of those kernels.</p>
<p>The following functions implement various variants of FFT-based convolution:</p>
<dl>
<dt><b>convolveFFT</b></dt>
<dd>Convolve a real-valued input array with a kernel such that the result is also real-valued. That is, the kernel is either provided as a real-valued array in the spatial domain, or as a complex-valued array in the Fourier domain, using the half-space format of the R2C Fourier transform (see below). </dd>
<dt><b>convolveFFTMany</b></dt>
<dd>Like <code>convolveFFT</code>, but you may provide many kernels at once (using an iterator pair specifying the kernel sequence). This has the advantage that the forward transform of the input array needs to be executed only once. </dd>
<dt><b>convolveFFTComplex</b></dt>
<dd>Convolve a complex-valued input array with a complex-valued kernel, resulting in a complex-valued output array. An additional flag is used to specify whether the kernel is defined in the spatial or frequency domain. </dd>
<dt><b>convolveFFTComplexMany</b></dt>
<dd>Like <code>convolveFFTComplex</code>, but you may provide many kernels at once (using an iterator pair specifying the kernel sequence). This has the advantage that the forward transform of the input array needs to be executed only once. </dd>
</dl>
<p>The output arrays must have the same shape as the input arrays. In the "Many" variants of the convolution functions, the kernels must all have the same shape.</p>
<p>The origin of the kernel is always assumed to be in the center of the kernel array (precisely, at the point <code>floor(kernel.shape() / 2.0)</code>, except when the half-space format is used, see below). The function <a class="el" href="group__FourierTransform.html#gaee27c376079af99e8e2148e7d23ffbbb">moveDCToUpperLeft()</a> will be called internally to align the kernel with the transformed input as appropriate.</p>
<p>If a real input is combined with a real kernel, the kernel is automatically assumed to be defined in the spatial domain. If a real input is combined with a complex kernel, the kernel is assumed to be defined in the Fourier domain in half-space format. If the input array is complex, a flag <code>fourierDomainKernel</code> determines where the kernel is defined.</p>
<p>When the kernel is defined in the spatial domain, the convolution functions will automatically pad (enlarge) the input array by at least the kernel radius in each direction. The newly added space is filled according to reflective boundary conditions in order to minimize border artifacts during convolution. It is thus ensured that convolution in the Fourier domain yields the same results as convolution in the spatial domain (e.g. when <a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray()</a> is called with the same kernel). A little further padding may be added to make sure that the padded array shape uses integers which have only small prime factors, because FFTW is then able to use the fastest possible algorithms. Any padding is automatically removed from the result arrays before the function returns.</p>
<p>When the kernel is defined in the frequency domain, it must be complex-valued, and its shape determines the shape of the Fourier representation (i.e. the input is padded according to the shape of the kernel). If we are going to perform a complex-valued convolution, the kernel must be defined for the entire frequency domain, and its shape directly determines the size of the FFT.</p>
<p>In contrast, a frequency domain kernel for a real-valued convolution must have symmetry properties that allow to drop half of the kernel coefficients, as in the <a href="http://www.fftw.org/doc/Multi_002dDimensional-DFTs-of-Real-Data.html">R2C transform</a>. That is, the kernel must have the <em>half-space format</em>, that is the shape returned by <code>fftwCorrespondingShapeR2C(fourier_shape)</code>, where <code>fourier_shape</code> is the desired logical shape of the frequency representation (and thus the size of the padded input). The origin of the kernel must be at the point <code>(0, floor(fourier_shape[0] / 2.0), ..., floor(fourier_shape[N-1] / 2.0))</code> (i.e. as in a regular kernel except for the first dimension).</p>
<p>The <code>Real</code> type in the declarations can be <code>double</code>, <code>float</code>, and <code>long double</code>. Your program must always link against <code>libfftw3</code>. If you use <code>float</code> or <code>long double</code> arrays, you must <em>additionally</em> link against <code>libfftw3f</code> and <code>libfftw3l</code> respectively.</p>
<p>The Fourier transform functions internally create <a href="http://www.fftw.org/doc/Using-Plans.html">FFTW plans</a> which control the algorithm details. The plans are creates with the flag <code>FFTW_ESTIMATE</code>, i.e. optimal settings are guessed or read from saved "wisdom" files. If you need more control over planning, you can use the class <a class="el" href="classvigra_1_1FFTWConvolvePlan.html">FFTWConvolvePlan</a>.</p>
<p>See also <a class="el" href="group__FourierTransform.html#gad51931cfe91ece316e28ff9d7ff28377">applyFourierFilter()</a> for corresponding functionality on the basis of the old image iterator interface.</p>
<p><b> Declarations:</b></p>
<p>Real-valued convolution with kernel in the spatial domain: </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;
        <span class="keywordtype">void</span> 
        <a class="code" href="group__MultiArrayConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae" title="Convolve an array with a kernel by means of the Fourier transform.">convolveFFT</a>(MultiArrayView&lt;N, Real, C1&gt; in, 
                    MultiArrayView&lt;N, Real, C2&gt; kernel,
                    MultiArrayView&lt;N, Real, C3&gt; out);
    }
</pre></div><p>Real-valued convolution with kernel in the Fourier domain (half-space format): </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;
        <span class="keywordtype">void</span> 
        <a class="code" href="group__MultiArrayConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae" title="Convolve an array with a kernel by means of the Fourier transform.">convolveFFT</a>(MultiArrayView&lt;N, Real, C1&gt; in, 
                    MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C2&gt; kernel,
                    MultiArrayView&lt;N, Real, C3&gt; out);
    }
</pre></div><p>Series of real-valued convolutions with kernels in the spatial or Fourier domain (the kernel and out sequences must have the same length): </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>Real, <span class="keyword">class </span>C1, 
                  <span class="keyword">class </span>KernelIterator, <span class="keyword">class </span>OutIterator&gt;
        <span class="keywordtype">void</span> 
        <a class="code" href="group__MultiArrayConvolutionFilters.html#gae2598869b328eae9ff709387e0b758a0" title="Convolve a real-valued array with a sequence of kernels by means of the Fourier transform.">convolveFFTMany</a>(MultiArrayView&lt;N, Real, C1&gt; in, 
                        KernelIterator kernels, KernelIterator kernelsEnd,
                        OutIterator outs);
    }
</pre></div><p>Complex-valued convolution (parameter <code>fourierDomainKernel</code> determines if the kernel is defined in the spatial or Fourier domain): </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#ga014b4e7d6d5154d5ad83170c6cb547f6" title="Convolve a complex-valued array by means of the Fourier transform.">convolveFFTComplex</a>(MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C1&gt; in,
                           MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C2&gt; kernel,
                           MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C3&gt; out,
                           <span class="keywordtype">bool</span> fourierDomainKernel);
    }
</pre></div><p>Series of complex-valued convolutions (parameter <code>fourierDomainKernel</code> determines if the kernels are defined in the spatial or Fourier domain, the kernel and out sequences must have the same length): </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>Real, <span class="keyword">class </span>C1, 
                  <span class="keyword">class </span>KernelIterator, <span class="keyword">class </span>OutIterator&gt;
        <span class="keywordtype">void</span> 
        <a class="code" href="group__MultiArrayConvolutionFilters.html#gaf555ec81ad059261e2bb8b5d03a0aa83" title="Convolve a complex-valued array with a sequence of kernels by means of the Fourier transform...">convolveFFTComplexMany</a>(MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C1&gt; in, 
                               KernelIterator kernels, KernelIterator kernelsEnd,
                               OutIterator outs,
                               <span class="keywordtype">bool</span> fourierDomainKernel);
    }
</pre></div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__fft_8hxx_source.html">vigra/multi_fft.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><pre class="fragment">    <span class="comment">// convolve real array with a Gaussian (sigma=1) defined in the spatial domain</span>
    <span class="comment">// (implicitly uses padding by at least 4 pixels)</span>
    MultiArray&lt;2, double&gt; src(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(w, h)), dest(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(w,h));
    
    MultiArray&lt;2, double&gt; spatial_kernel(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(9, 9));
    Gaussian&lt;double&gt; gauss(1.0);
    
    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y=0; y&lt;9; ++y)
        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x=0; x&lt;9; ++x)
            spatial_kernel(x, y) = gauss(x-4.0)*gauss(y-4.0);

    <a class="code" href="group__MultiArrayConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae" title="Convolve an array with a kernel by means of the Fourier transform.">convolveFFT</a>(src, spatial_kernel, dest);
    
    <span class="comment">// convolve real array with a Gaussian (sigma=1) defined in the Fourier domain</span>
    <span class="comment">// (uses no padding, because the kernel size corresponds to the input size)</span>
    MultiArray&lt;2, FFTWComplex&lt;double&gt; &gt; fourier_kernel(<a class="code" href="group__FourierTransform.html#gafbea828444f49163293b1d81fcd05da8" title="Find frequency domain shape for a R2C Fourier transform.">fftwCorrespondingShapeR2C</a>(src.shape()));
    <span class="keywordtype">int</span> y0 = h / 2;
        
    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y=0; y&lt;fourier_kernel.shape(1); ++y)
        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x=0; x&lt;fourier_kernel.shape(0); ++x)
            fourier_kernel(x, y) = <a class="code" href="group__LinearAlgebraFunctions.html#ga2a9e01ae7ae7b39a618e9f4a6afaee5b">exp</a>(-0.5*<a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>(x / <span class="keywordtype">double</span>(w))) * <a class="code" href="group__LinearAlgebraFunctions.html#ga2a9e01ae7ae7b39a618e9f4a6afaee5b">exp</a>(-0.5*<a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function.">sq</a>((y-y0)/<span class="keywordtype">double</span>(h)));

    <a class="code" href="group__MultiArrayConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae" title="Convolve an array with a kernel by means of the Fourier transform.">convolveFFT</a>(src, fourier_kernel, dest);
</pre></div> 
</div>
</div>
<a class="anchor" id="ga014b4e7d6d5154d5ad83170c6cb547f6"></a><!-- doxytag: member="vigra::convolveFFTComplex" ref="ga014b4e7d6d5154d5ad83170c6cb547f6" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__MultiArrayConvolutionFilters.html#ga014b4e7d6d5154d5ad83170c6cb547f6">vigra::convolveFFTComplex</a> </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convolve a complex-valued array by means of the Fourier transform. </p>
<p>See <a class="el" href="group__MultiArrayConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">convolveFFT()</a> for details. </p>

</div>
</div>
<a class="anchor" id="gae2598869b328eae9ff709387e0b758a0"></a><!-- doxytag: member="vigra::convolveFFTMany" ref="gae2598869b328eae9ff709387e0b758a0" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__MultiArrayConvolutionFilters.html#gae2598869b328eae9ff709387e0b758a0">vigra::convolveFFTMany</a> </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convolve a real-valued array with a sequence of kernels by means of the Fourier transform. </p>
<p>See <a class="el" href="group__MultiArrayConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">convolveFFT()</a> for details. </p>

</div>
</div>
<a class="anchor" id="gaf555ec81ad059261e2bb8b5d03a0aa83"></a><!-- doxytag: member="vigra::convolveFFTComplexMany" ref="gaf555ec81ad059261e2bb8b5d03a0aa83" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__MultiArrayConvolutionFilters.html#gaf555ec81ad059261e2bb8b5d03a0aa83">vigra::convolveFFTComplexMany</a> </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convolve a complex-valued array with a sequence of kernels by means of the Fourier transform. </p>
<p>See <a class="el" href="group__MultiArrayConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">convolveFFT()</a> for details. </p>

</div>
</div>
</div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.9.1 (Thu Sep 5 2013)
</i>
</tr>
</table>


</BODY>
</HTML>
