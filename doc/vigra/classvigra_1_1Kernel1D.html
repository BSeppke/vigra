<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Kernel1D&lt; ARITHTYPE &gt; Class Template Reference</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{ 
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://hci.iwr.uni-heidelberg.de/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" title="Detailed Description" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Kernel1D&lt; ARITHTYPE &gt; Class Template Reference
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<!-- doxytag: class="vigra::Kernel1D" -->
<p>Generic 1 dimensional convolution kernel.  
 <a href="classvigra_1_1Kernel1D.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="separableconvolution_8hxx_source.html">vigra/separableconvolution.hxx</a>&gt;</code></p>

<p><a href="classvigra_1_1Kernel1D-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1StandardAccessor.html">StandardAccessor</a><br class="typebreak"/>
&lt; ARITHTYPE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a6c53fe234330a9d1604e0948fa47174b">Accessor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
InternalVector::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#ab5a64d70f2934a8cb54eb8d81f059773">const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
InternalVector::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#ab6c87d7921339cc42075571aaf0c6534">const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1StandardConstAccessor.html">StandardConstAccessor</a><br class="typebreak"/>
&lt; ARITHTYPE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#aa78445962f8673a1e2c1393dab7c7ad8">ConstAccessor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef InternalVector::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#adef84b9c9d4f014effcfecbca87629d2">Iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef InternalVector::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a8c0b17e9965a56ba56cb5fedc7119a92">iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef InternalVector::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a130b31490ce7ba9051094274b190940d">reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvigra_1_1ArrayVector.html#adee9ba124f2423126f678c913667a229">InternalVector::value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Kernel1D.html#aa78445962f8673a1e2c1393dab7c7ad8">ConstAccessor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a40e8567a7e13dacc22cadde2f9d1dcd0">accessor</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Kernel1D.html#a6c53fe234330a9d1604e0948fa47174b">Accessor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#ac1e543db9ce291e86b9023cdb9202b5b">accessor</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BorderTreatmentMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Kernel1D.html#a8c0b17e9965a56ba56cb5fedc7119a92">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#afa906590f3f139cdfeb292a15add8e1f">center</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#ab7fe279fbc6c3e2ce60ec778109b9923">initAveraging</a> (int radius, <a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a> <a class="el" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a97c19fd629e175e9b97af74733b2bbd4">initAveraging</a> (int radius)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a192eec53d760d825b0eedab01a6a2ed2">initBackwardDifference</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#ac919a292dea182575c698495de0430b2">initBinomial</a> (int radius, <a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a> <a class="el" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a01c5f04a39f4a11736e787f7d27f6666">initBinomial</a> (int radius)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a1406a301a1cc659b3098bbcc0a827228">initBurtFilter</a> (double a=0.04785)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a80922d43665cec4f4378e8378997feb0">initDiscreteGaussian</a> (double std_dev, <a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a> <a class="el" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a15901db2903a004e09e86ae5fbd66ca2">initDiscreteGaussian</a> (double std_dev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a1164e5b808619971ebc0e9783f972dc9">initExplicitly</a> (int <a class="el" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>, int <a class="el" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#acf8d30d2b69f8f6771d6804d15df5072">initForwardDifference</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a48c46ac7770600ec38f55c1dc498244a">initGaussian</a> (double std_dev, <a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a> <a class="el" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>, double windowRatio=0.0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#abba907ac90270c3dd8aac14af93f7b58">initGaussian</a> (double std_dev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a825b69c78f7b71bc33dea8d461849161">initGaussianDerivative</a> (double std_dev, int order, <a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a> <a class="el" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>, double windowRatio=0.0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a7eec7322d05865b857efb1449888d918">initGaussianDerivative</a> (double std_dev, int order)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a1eeff31c2ffd35f352631fbe27d1dcdc">initOptimalFirstDerivative5</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#af5677b3c7ffdc1586c4e9e4a5394daac">initOptimalFirstDerivativeSmoothing3</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a068e7beed066f292a4ba8e777897526f">initOptimalFirstDerivativeSmoothing5</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#ab50c7edfcedf325996e21eb74a69a4d0">initOptimalSecondDerivative5</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a0fe353a930022de958b75e9e6311189e">initOptimalSecondDerivativeSmoothing3</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#abbe3a4b86ffdaf0e8e85d5ab7e75ed71">initOptimalSecondDerivativeSmoothing5</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#af4902fcc6fe66ab6646cbe1fdc5e7121">initOptimalSmoothing3</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a75b3593dd18b43b1d5f81532617d8010">initOptimalSmoothing5</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a072b8efc06e0bd9c6f1fd395becebf17">initSecondDifference3</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a8feea4952f1c61fc8643bbcd23afe103">initSymmetricDifference</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#ab9c9a9ebb3b89ac2c8aff5e985923d18">initSymmetricGradient</a> (<a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a> <a class="el" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a50d0fbcbdb93cbbdfa5d497d5afb5b13">initSymmetricGradient</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#ac4bc39b4e951c1da5c7d14e79774842b">Kernel1D</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#aafb70f6879284a8f74ae53ab656094e6">Kernel1D</a> (<a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a> const &amp;k)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a4302a66e41af59782c71e1103e6ded00">Kernel1D</a> (<a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a>&lt; U &gt; const &amp;k)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a7f10c82d42dacf3b4c9b691fb0840e35">normalize</a> (<a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a> <a class="el" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>, unsigned int derivativeOrder=0, double offset=0.0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#acd0de676568888d848beb97dcc53ae47">normalize</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a4d661136561636b764e9689d41db9349">operator=</a> (<a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a> const &amp;k)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">InitProxy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a4fd821bdc684b1cdad02afe53dd043dc">operator=</a> (<a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a> const &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1Kernel1D.html#a130b31490ce7ba9051094274b190940d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a42bf8c098fec92f08714fdf0c72a66ff">operator[]</a> (int location)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a647df9e68cc4da54a5c9d2ba13768c9a">setBorderTreatment</a> (BorderTreatmentMode new_mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#ab8e4e3e2a7bf18888b71bdf9dda0770b">size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a8dce5d31376d099a6f6a940dd1b1fa28">~Kernel1D</a> ()</td></tr>
</table>
<hr/><a name="_details" id="details"></a><h2 class="details_section">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class ARITHTYPE = double&gt;<br/>
class vigra::Kernel1D&lt; ARITHTYPE &gt;</h3>

<p>Generic 1 dimensional convolution kernel. </p>
<p>This kernel may be used for convolution of 1 dimensional signals or for separable convolution of multidimensional signals.</p>
<p>Convolution functions access the kernel via a 1 dimensional random access iterator which they get by calling <a class="el" href="classvigra_1_1Kernel1D.html#afa906590f3f139cdfeb292a15add8e1f">center()</a>. This iterator points to the center of the kernel. The kernel's size is given by its <a class="el" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left()</a> (&lt;=0) and <a class="el" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right()</a> (&gt;= 0) methods. The desired border treatment mode is returned by <a class="el" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment()</a>.</p>
<p>The different init functions create a kernel with the specified properties. The kernel's value_type must be a linear space, i.e. it must define multiplication with doubles and NumericTraits.</p>
<p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="separableconvolution_8hxx_source.html">vigra/separableconvolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;2, float&gt; src(w,h), dest(w,h);
    ...

    <span class="comment">// define Gaussian kernel with std. deviation 3.0</span>
    <a class="code" href="classvigra_1_1Kernel1D.html#ac4bc39b4e951c1da5c7d14e79774842b">Kernel1D</a> kernel;
    kernel.<a class="code" href="classvigra_1_1Kernel1D.html#a48c46ac7770600ec38f55c1dc498244a">initGaussian</a>(3.0);

    <span class="comment">// apply 1D kernel along the x-axis</span>
    <a class="code" href="group__SeparableConvolution.html#ga34459275af4134198dfc1a75c9993848" title="Performs a 1 dimensional convolution in x direction.">separableConvolveX</a>(src, dest, kernel);
</pre></div><p><a href="#" id="Kernel1D_OldUsageToggle" onclick="return toggleHiddenDocumentation(&apos;Kernel1D_OldUsage&apos;, &apos;Kernel1D_OldUsageToggle&apos;, &apos;deprecated examples&apos;);">show deprecated examples</a></p>
<div id="Kernel1D_OldUsage" style="display:none"> The kernel defines a factory function kernel1d() to create an argument object (see <a class="el" href="KernelArgumentObjectFactories.html">Kernel Argument Object Factories</a>). </p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::FImage</a> src(w,h), dest(w,h);
    ...

    <span class="comment">// define Gaussian kernel with std. deviation 3.0</span>
    <a class="code" href="classvigra_1_1Kernel1D.html" title="Generic 1 dimensional convolution kernel.">vigra::Kernel1D</a> kernel;
    kernel.<a class="code" href="classvigra_1_1Kernel1D.html#a48c46ac7770600ec38f55c1dc498244a">initGaussian</a>(3.0);

    <a class="code" href="group__SeparableConvolution.html#ga34459275af4134198dfc1a75c9993848" title="Performs a 1 dimensional convolution in x direction.">vigra::separableConvolveX</a>(srcImageRange(src), destImage(dest), kernel1d(kernel));
</pre></div><p> <b> Required Interface:</b> </p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a> v = vigra::NumericTraits&lt;value_type&gt;::one(); <span class="comment">// if norm is not</span>
                                                            <span class="comment">// given explicitly</span>
    <span class="keywordtype">double</span> d;

    v = d * v;
</pre></div> </div> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="pyramid_8cxx-example.html#_a0">pyramid.cxx</a>, and <a class="el" href="smooth_convolve_8cxx-example.html#_a3">smooth_convolve.cxx</a>.</dd>
</dl></div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a821b18fa86c2bc45ccf17716429d438b"></a><!-- doxytag: member="vigra::Kernel1D::value_type" ref="a821b18fa86c2bc45ccf17716429d438b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classvigra_1_1ArrayVector.html#adee9ba124f2423126f678c913667a229">InternalVector::value_type</a> <a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>the kernel's value type </p>

</div>
</div>
<a class="anchor" id="a130b31490ce7ba9051094274b190940d"></a><!-- doxytag: member="vigra::Kernel1D::reference" ref="a130b31490ce7ba9051094274b190940d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalVector::reference <a class="el" href="classvigra_1_1Kernel1D.html#a130b31490ce7ba9051094274b190940d">reference</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>the kernel's reference type </p>

</div>
</div>
<a class="anchor" id="ab6c87d7921339cc42075571aaf0c6534"></a><!-- doxytag: member="vigra::Kernel1D::const_reference" ref="ab6c87d7921339cc42075571aaf0c6534" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalVector::const_reference <a class="el" href="classvigra_1_1Kernel1D.html#ab6c87d7921339cc42075571aaf0c6534">const_reference</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>the kernel's const reference type </p>

</div>
</div>
<a class="anchor" id="adef84b9c9d4f014effcfecbca87629d2"></a><!-- doxytag: member="vigra::Kernel1D::Iterator" ref="adef84b9c9d4f014effcfecbca87629d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalVector::iterator <a class="el" href="classvigra_1_1Kernel1D.html#adef84b9c9d4f014effcfecbca87629d2">Iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>deprecated -- use <a class="el" href="classvigra_1_1Kernel1D.html#a8c0b17e9965a56ba56cb5fedc7119a92">Kernel1D::iterator</a> </p>

</div>
</div>
<a class="anchor" id="a8c0b17e9965a56ba56cb5fedc7119a92"></a><!-- doxytag: member="vigra::Kernel1D::iterator" ref="a8c0b17e9965a56ba56cb5fedc7119a92" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalVector::iterator <a class="el" href="classvigra_1_1Kernel1D.html#a8c0b17e9965a56ba56cb5fedc7119a92">iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>1D random access iterator over the kernel's values </p>

</div>
</div>
<a class="anchor" id="ab5a64d70f2934a8cb54eb8d81f059773"></a><!-- doxytag: member="vigra::Kernel1D::const_iterator" ref="ab5a64d70f2934a8cb54eb8d81f059773" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalVector::const_iterator <a class="el" href="classvigra_1_1Kernel1D.html#ab5a64d70f2934a8cb54eb8d81f059773">const_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>const 1D random access iterator over the kernel's values </p>

</div>
</div>
<a class="anchor" id="a6c53fe234330a9d1604e0948fa47174b"></a><!-- doxytag: member="vigra::Kernel1D::Accessor" ref="a6c53fe234330a9d1604e0948fa47174b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classvigra_1_1StandardAccessor.html">StandardAccessor</a>&lt;ARITHTYPE&gt; <a class="el" href="classvigra_1_1Kernel1D.html#a6c53fe234330a9d1604e0948fa47174b">Accessor</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>the kernel's accessor </p>

</div>
</div>
<a class="anchor" id="aa78445962f8673a1e2c1393dab7c7ad8"></a><!-- doxytag: member="vigra::Kernel1D::ConstAccessor" ref="aa78445962f8673a1e2c1393dab7c7ad8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classvigra_1_1StandardConstAccessor.html">StandardConstAccessor</a>&lt;ARITHTYPE&gt; <a class="el" href="classvigra_1_1Kernel1D.html#aa78445962f8673a1e2c1393dab7c7ad8">ConstAccessor</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>the kernel's const accessor </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac4bc39b4e951c1da5c7d14e79774842b"></a><!-- doxytag: member="vigra::Kernel1D::Kernel1D" ref="ac4bc39b4e951c1da5c7d14e79774842b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default constructor. Creates a kernel of size 1 which would copy the signal unchanged. </p>

</div>
</div>
<a class="anchor" id="aafb70f6879284a8f74ae53ab656094e6"></a><!-- doxytag: member="vigra::Kernel1D::Kernel1D" ref="aafb70f6879284a8f74ae53ab656094e6" args="(Kernel1D const &amp;k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a>&lt; ARITHTYPE &gt; const &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy constructor. </p>

</div>
</div>
<a class="anchor" id="a4302a66e41af59782c71e1103e6ded00"></a><!-- doxytag: member="vigra::Kernel1D::Kernel1D" ref="a4302a66e41af59782c71e1103e6ded00" args="(Kernel1D&lt; U &gt; const &amp;k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct from kernel with different element type, e.g. double =&gt; <a class="el" href="classvigra_1_1FixedPoint16.html">FixedPoint16</a>. </p>

</div>
</div>
<a class="anchor" id="a8dce5d31376d099a6f6a940dd1b1fa28"></a><!-- doxytag: member="vigra::Kernel1D::~Kernel1D" ref="a8dce5d31376d099a6f6a940dd1b1fa28" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4d661136561636b764e9689d41db9349"></a><!-- doxytag: member="vigra::Kernel1D::operator=" ref="a4d661136561636b764e9689d41db9349" args="(Kernel1D const &amp;k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a>&lt; ARITHTYPE &gt; const &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy assignment. </p>

</div>
</div>
<a class="anchor" id="a4fd821bdc684b1cdad02afe53dd043dc"></a><!-- doxytag: member="vigra::Kernel1D::operator=" ref="a4fd821bdc684b1cdad02afe53dd043dc" args="(value_type const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InitProxy operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialization. This initializes the kernel with the given constant. The norm becomes v*size().</p>
<p>Instead of a single value an initializer list of length <a class="el" href="classvigra_1_1Kernel1D.html#ab8e4e3e2a7bf18888b71bdf9dda0770b">size()</a> can be used like this:</p>
<div class="fragment"><pre class="fragment">            <a class="code" href="classvigra_1_1Kernel1D.html" title="Generic 1 dimensional convolution kernel.">vigra::Kernel1D&lt;float&gt;</a> roberts_gradient_x;

            roberts_gradient_x.<a class="code" href="classvigra_1_1Kernel1D.html#a1164e5b808619971ebc0e9783f972dc9">initExplicitly</a>(0, 1) = 1.0, -1.0;
</pre></div><p>In this case, the norm will be set to the sum of the init values. An initializer list of wrong length will result in a run-time error. </p>

</div>
</div>
<a class="anchor" id="a48c46ac7770600ec38f55c1dc498244a"></a><!-- doxytag: member="vigra::Kernel1D::initGaussian" ref="a48c46ac7770600ec38f55c1dc498244a" args="(double std_dev, value_type norm, double windowRatio=0.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#a48c46ac7770600ec38f55c1dc498244a">initGaussian</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>std_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a>&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>windowRatio</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init as a sampled <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> function. The radius of the kernel is always 3*std_dev. '<code>norm</code>' denotes the sum of all bins of the kernel (i.e. the kernel is corrected for the normalization error introduced by windowing the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> to a finite interval). However, if <code>norm</code> is 0.0, the kernel is normalized to 1 by the analytic expression for the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a>, and <b>no</b> correction for the windowing error is performed. If <code>windowRatio = 0.0</code>, the radius of the filter window is <code>radius = round(3.0 * std_dev)</code>, otherwise it is <code>radius = round(windowRatio * std_dev)</code> (where <code>windowRatio &gt; 0.0</code> is required).</p>
<p>Precondition: </p>
<div class="fragment"><pre class="fragment">            std_dev &gt;= 0.0
</pre></div><p>Postconditions: </p>
<div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -(int)(3.0*std_dev + 0.5)
            2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  (int)(3.0*std_dev + 0.5)
            3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>
</pre></div> 
</div>
</div>
<a class="anchor" id="abba907ac90270c3dd8aac14af93f7b58"></a><!-- doxytag: member="vigra::Kernel1D::initGaussian" ref="abba907ac90270c3dd8aac14af93f7b58" args="(double std_dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#a48c46ac7770600ec38f55c1dc498244a">initGaussian</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>std_dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init as a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> function with norm 1. </p>

</div>
</div>
<a class="anchor" id="a80922d43665cec4f4378e8378997feb0"></a><!-- doxytag: member="vigra::Kernel1D::initDiscreteGaussian" ref="a80922d43665cec4f4378e8378997feb0" args="(double std_dev, value_type norm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#a80922d43665cec4f4378e8378997feb0">initDiscreteGaussian</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>std_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a>&#160;</td>
          <td class="paramname"><em>norm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init as Lindeberg's discrete analog of the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> function. The radius of the kernel is always 3*std_dev. 'norm' denotes the sum of all bins of the kernel.</p>
<p>Precondition: </p>
<div class="fragment"><pre class="fragment">            std_dev &gt;= 0.0
</pre></div><p>Postconditions: </p>
<div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -(int)(3.0*std_dev + 0.5)
            2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  (int)(3.0*std_dev + 0.5)
            3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>
</pre></div> 
</div>
</div>
<a class="anchor" id="a15901db2903a004e09e86ae5fbd66ca2"></a><!-- doxytag: member="vigra::Kernel1D::initDiscreteGaussian" ref="a15901db2903a004e09e86ae5fbd66ca2" args="(double std_dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#a80922d43665cec4f4378e8378997feb0">initDiscreteGaussian</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>std_dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init as a Lindeberg's discrete analog of the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> function with norm 1. </p>

</div>
</div>
<a class="anchor" id="a825b69c78f7b71bc33dea8d461849161"></a><!-- doxytag: member="vigra::Kernel1D::initGaussianDerivative" ref="a825b69c78f7b71bc33dea8d461849161" args="(double std_dev, int order, value_type norm, double windowRatio=0.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#a825b69c78f7b71bc33dea8d461849161">initGaussianDerivative</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>std_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a>&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>windowRatio</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init as a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative of order '<code>order</code>'. The radius of the kernel is always <code>3*std_dev + 0.5*order</code>. '<code>norm</code>' denotes the norm of the kernel so that the following condition is fulfilled:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{i=left()}^{right()} \frac{(-i)^{order}kernel[i]}{order!} = norm \]" src="form_83.png"/>
</p>
<p>Thus, the kernel will be corrected for the error introduced by windowing the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> to a finite interval. However, if <code>norm</code> is 0.0, the kernel is normalized to 1 by the analytic expression for the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative, and <b>no</b> correction for the windowing error is performed. If <code>windowRatio = 0.0</code>, the radius of the filter window is <code>radius = round(3.0 * std_dev + 0.5 * order)</code>, otherwise it is <code>radius = round(windowRatio * std_dev)</code> (where <code>windowRatio &gt; 0.0</code> is required).</p>
<p>Preconditions: </p>
<div class="fragment"><pre class="fragment">            1. std_dev &gt;= 0.0
            2. order   &gt;= 1
</pre></div><p>Postconditions: </p>
<div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -(int)(3.0*std_dev + 0.5*order + 0.5)
            2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  (int)(3.0*std_dev + 0.5*order + 0.5)
            3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>
</pre></div> 
</div>
</div>
<a class="anchor" id="a7eec7322d05865b857efb1449888d918"></a><!-- doxytag: member="vigra::Kernel1D::initGaussianDerivative" ref="a7eec7322d05865b857efb1449888d918" args="(double std_dev, int order)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#a825b69c78f7b71bc33dea8d461849161">initGaussianDerivative</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>std_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init as a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative with norm 1. </p>

</div>
</div>
<a class="anchor" id="af4902fcc6fe66ab6646cbe1fdc5e7121"></a><!-- doxytag: member="vigra::Kernel1D::initOptimalSmoothing3" ref="af4902fcc6fe66ab6646cbe1fdc5e7121" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#af4902fcc6fe66ab6646cbe1fdc5e7121">initOptimalSmoothing3</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init an optimal 3-tap smoothing filter. The filter values are</p>
<div class="fragment"><pre class="fragment">            [0.216, 0.568, 0.216]
</pre></div><p>These values are optimal in the sense that the 3x3 filter obtained by separable application of this filter is the best possible 3x3 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.680.</p>
<p>Postconditions: </p>
<div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -1
            2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  1
            3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0
</pre></div> 
</div>
</div>
<a class="anchor" id="af5677b3c7ffdc1586c4e9e4a5394daac"></a><!-- doxytag: member="vigra::Kernel1D::initOptimalFirstDerivativeSmoothing3" ref="af5677b3c7ffdc1586c4e9e4a5394daac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#af5677b3c7ffdc1586c4e9e4a5394daac">initOptimalFirstDerivativeSmoothing3</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init an optimal 3-tap smoothing filter to be used in the context of first derivative computation. This filter must be used in conjunction with the symmetric difference filter (see <a class="el" href="classvigra_1_1Kernel1D.html#a8feea4952f1c61fc8643bbcd23afe103">initSymmetricDifference()</a>), such that the difference filter is applied along one dimension, and the smoothing filter along the other. The filter values are</p>
<div class="fragment"><pre class="fragment">            [0.224365, 0.55127, 0.224365]
</pre></div><p>These values are optimal in the sense that the 3x3 filter obtained by combining this filter with the symmetric difference is the best possible 3x3 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> first derivative filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.675.</p>
<p>Postconditions: </p>
<div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -1
            2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  1
            3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0
</pre></div> 
</div>
</div>
<a class="anchor" id="a0fe353a930022de958b75e9e6311189e"></a><!-- doxytag: member="vigra::Kernel1D::initOptimalSecondDerivativeSmoothing3" ref="a0fe353a930022de958b75e9e6311189e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#a0fe353a930022de958b75e9e6311189e">initOptimalSecondDerivativeSmoothing3</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init an optimal 3-tap smoothing filter to be used in the context of second derivative computation. This filter must be used in conjunction with the 3-tap second difference filter (see <a class="el" href="classvigra_1_1Kernel1D.html#a072b8efc06e0bd9c6f1fd395becebf17">initSecondDifference3()</a>), such that the difference filter is applied along one dimension, and the smoothing filter along the other. The filter values are</p>
<div class="fragment"><pre class="fragment">            [0.13, 0.74, 0.13]
</pre></div><p>These values are optimal in the sense that the 3x3 filter obtained by combining this filter with the 3-tap second difference is the best possible 3x3 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> second derivative filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.433.</p>
<p>Postconditions: </p>
<div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -1
            2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  1
            3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0
</pre></div> 
</div>
</div>
<a class="anchor" id="a75b3593dd18b43b1d5f81532617d8010"></a><!-- doxytag: member="vigra::Kernel1D::initOptimalSmoothing5" ref="a75b3593dd18b43b1d5f81532617d8010" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#a75b3593dd18b43b1d5f81532617d8010">initOptimalSmoothing5</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init an optimal 5-tap smoothing filter. The filter values are</p>
<div class="fragment"><pre class="fragment">            [0.03134, 0.24, 0.45732, 0.24, 0.03134]
</pre></div><p>These values are optimal in the sense that the 5x5 filter obtained by separable application of this filter is the best possible 5x5 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.867.</p>
<p>Postconditions: </p>
<div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -2
            2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  2
            3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0
</pre></div> 
</div>
</div>
<a class="anchor" id="a068e7beed066f292a4ba8e777897526f"></a><!-- doxytag: member="vigra::Kernel1D::initOptimalFirstDerivativeSmoothing5" ref="a068e7beed066f292a4ba8e777897526f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#a068e7beed066f292a4ba8e777897526f">initOptimalFirstDerivativeSmoothing5</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init an optimal 5-tap smoothing filter to be used in the context of first derivative computation. This filter must be used in conjunction with the optimal 5-tap first derivative filter (see <a class="el" href="classvigra_1_1Kernel1D.html#a1eeff31c2ffd35f352631fbe27d1dcdc">initOptimalFirstDerivative5()</a>), such that the derivative filter is applied along one dimension, and the smoothing filter along the other. The filter values are</p>
<div class="fragment"><pre class="fragment">            [0.04255, 0.241, 0.4329, 0.241, 0.04255]
</pre></div><p>These values are optimal in the sense that the 5x5 filter obtained by combining this filter with the optimal 5-tap first derivative is the best possible 5x5 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> first derivative filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.906.</p>
<p>Postconditions: </p>
<div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -2
            2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  2
            3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0
</pre></div> 
</div>
</div>
<a class="anchor" id="abbe3a4b86ffdaf0e8e85d5ab7e75ed71"></a><!-- doxytag: member="vigra::Kernel1D::initOptimalSecondDerivativeSmoothing5" ref="abbe3a4b86ffdaf0e8e85d5ab7e75ed71" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#abbe3a4b86ffdaf0e8e85d5ab7e75ed71">initOptimalSecondDerivativeSmoothing5</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init an optimal 5-tap smoothing filter to be used in the context of second derivative computation. This filter must be used in conjunction with the optimal 5-tap second derivative filter (see <a class="el" href="classvigra_1_1Kernel1D.html#ab50c7edfcedf325996e21eb74a69a4d0">initOptimalSecondDerivative5()</a>), such that the derivative filter is applied along one dimension, and the smoothing filter along the other. The filter values are</p>
<div class="fragment"><pre class="fragment">            [0.0243, 0.23556, 0.48028, 0.23556, 0.0243]
</pre></div><p>These values are optimal in the sense that the 5x5 filter obtained by combining this filter with the optimal 5-tap second derivative is the best possible 5x5 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> second derivative filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.817.</p>
<p>Postconditions: </p>
<div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -2
            2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  2
            3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0
</pre></div> 
</div>
</div>
<a class="anchor" id="a1406a301a1cc659b3098bbcc0a827228"></a><!-- doxytag: member="vigra::Kernel1D::initBurtFilter" ref="a1406a301a1cc659b3098bbcc0a827228" args="(double a=0.04785)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#a1406a301a1cc659b3098bbcc0a827228">initBurtFilter</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em> = <code>0.04785</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init a 5-tap filter as defined by Peter Burt in the context of pyramid creation. The filter values are</p>
<div class="fragment"><pre class="fragment">            [a, 0.25, 0.5-2*a, 0.25, a]
</pre></div><p>The default <code>a = 0.04785</code> is optimal in the sense that it minimizes the difference to a true <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> filter (which would have sigma = 0.975). For other values of <code>a</code>, the scale of the most similar <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> can be approximated by</p>
<div class="fragment"><pre class="fragment">            sigma = 5.1 * a + 0.731
</pre></div><p>Preconditions: </p>
<div class="fragment"><pre class="fragment">            0 &lt;= a &lt;= 0.125
</pre></div><p>Postconditions: </p>
<div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -2
            2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  2
            3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0
</pre></div> 
</div>
</div>
<a class="anchor" id="ac919a292dea182575c698495de0430b2"></a><!-- doxytag: member="vigra::Kernel1D::initBinomial" ref="ac919a292dea182575c698495de0430b2" args="(int radius, value_type norm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#ac919a292dea182575c698495de0430b2">initBinomial</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a>&#160;</td>
          <td class="paramname"><em>norm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init as a Binomial filter. 'norm' denotes the sum of all bins of the kernel.</p>
<p>Precondition: </p>
<div class="fragment"><pre class="fragment">            radius   &gt;= 0
</pre></div><p>Postconditions: </p>
<div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -radius
            2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  radius
            3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>
</pre></div> 
</div>
</div>
<a class="anchor" id="a01c5f04a39f4a11736e787f7d27f6666"></a><!-- doxytag: member="vigra::Kernel1D::initBinomial" ref="a01c5f04a39f4a11736e787f7d27f6666" args="(int radius)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#ac919a292dea182575c698495de0430b2">initBinomial</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init as a Binomial filter with norm 1. </p>

</div>
</div>
<a class="anchor" id="ab7fe279fbc6c3e2ce60ec778109b9923"></a><!-- doxytag: member="vigra::Kernel1D::initAveraging" ref="ab7fe279fbc6c3e2ce60ec778109b9923" args="(int radius, value_type norm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#ab7fe279fbc6c3e2ce60ec778109b9923">initAveraging</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a>&#160;</td>
          <td class="paramname"><em>norm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init as an Averaging filter. 'norm' denotes the sum of all bins of the kernel. The window size is (2*radius+1) * (2*radius+1)</p>
<p>Precondition: </p>
<div class="fragment"><pre class="fragment">            radius   &gt;= 0
</pre></div><p>Postconditions: </p>
<div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -radius
            2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  radius
            3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_CLIP
            4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>
</pre></div> 
</div>
</div>
<a class="anchor" id="a97c19fd629e175e9b97af74733b2bbd4"></a><!-- doxytag: member="vigra::Kernel1D::initAveraging" ref="a97c19fd629e175e9b97af74733b2bbd4" args="(int radius)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#ab7fe279fbc6c3e2ce60ec778109b9923">initAveraging</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init as an Averaging filter with norm 1. </p>

</div>
</div>
<a class="anchor" id="ab9c9a9ebb3b89ac2c8aff5e985923d18"></a><!-- doxytag: member="vigra::Kernel1D::initSymmetricGradient" ref="ab9c9a9ebb3b89ac2c8aff5e985923d18" args="(value_type norm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#ab9c9a9ebb3b89ac2c8aff5e985923d18">initSymmetricGradient</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a>&#160;</td>
          <td class="paramname"><em>norm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init as a symmetric gradient filter of the form <code>[ 0.5 * norm, 0.0 * norm, -0.5 * norm]</code></p>
<p><b>Deprecated</b>. Use <a class="el" href="classvigra_1_1Kernel1D.html#a8feea4952f1c61fc8643bbcd23afe103">initSymmetricDifference()</a> instead.</p>
<p>Postconditions: </p>
<div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -1
            2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  1
            3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REPEAT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>
</pre></div> 
</div>
</div>
<a class="anchor" id="a50d0fbcbdb93cbbdfa5d497d5afb5b13"></a><!-- doxytag: member="vigra::Kernel1D::initSymmetricGradient" ref="a50d0fbcbdb93cbbdfa5d497d5afb5b13" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#ab9c9a9ebb3b89ac2c8aff5e985923d18">initSymmetricGradient</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init as a symmetric gradient filter with norm 1.</p>
<p><b>Deprecated</b>. Use <a class="el" href="classvigra_1_1Kernel1D.html#a8feea4952f1c61fc8643bbcd23afe103">initSymmetricDifference()</a> instead. </p>

</div>
</div>
<a class="anchor" id="acf8d30d2b69f8f6771d6804d15df5072"></a><!-- doxytag: member="vigra::Kernel1D::initForwardDifference" ref="acf8d30d2b69f8f6771d6804d15df5072" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#acf8d30d2b69f8f6771d6804d15df5072">initForwardDifference</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init as the 2-tap forward difference filter. The filter values are</p>
<div class="fragment"><pre class="fragment">            [1.0, -1.0]
</pre></div><p>(note that filters are reflected by the convolution algorithm, and we get a forward difference after reflection).</p>
<p>Postconditions: </p>
<div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -1
            2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  0
            3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0
</pre></div> 
</div>
</div>
<a class="anchor" id="a192eec53d760d825b0eedab01a6a2ed2"></a><!-- doxytag: member="vigra::Kernel1D::initBackwardDifference" ref="a192eec53d760d825b0eedab01a6a2ed2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#a192eec53d760d825b0eedab01a6a2ed2">initBackwardDifference</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init as the 2-tap backward difference filter. The filter values are</p>
<div class="fragment"><pre class="fragment">            [1.0, -1.0]
</pre></div><p>(note that filters are reflected by the convolution algorithm, and we get a forward difference after reflection).</p>
<p>Postconditions: </p>
<div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == 0
            2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  1
            3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0
</pre></div> 
</div>
</div>
<a class="anchor" id="a8feea4952f1c61fc8643bbcd23afe103"></a><!-- doxytag: member="vigra::Kernel1D::initSymmetricDifference" ref="a8feea4952f1c61fc8643bbcd23afe103" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initSymmetricDifference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init as the 3-tap symmetric difference filter The filter values are</p>
<div class="fragment"><pre class="fragment">            [0.5, 0, -0.5]
</pre></div><p>Postconditions: </p>
<div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -1
            2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  1
            3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0
</pre></div> 
</div>
</div>
<a class="anchor" id="a072b8efc06e0bd9c6f1fd395becebf17"></a><!-- doxytag: member="vigra::Kernel1D::initSecondDifference3" ref="a072b8efc06e0bd9c6f1fd395becebf17" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#a072b8efc06e0bd9c6f1fd395becebf17">initSecondDifference3</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init the 3-tap second difference filter. The filter values are</p>
<div class="fragment"><pre class="fragment">            [1, -2, 1]
</pre></div><p>Postconditions: </p>
<div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -1
            2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  1
            3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1
</pre></div> 
</div>
</div>
<a class="anchor" id="a1eeff31c2ffd35f352631fbe27d1dcdc"></a><!-- doxytag: member="vigra::Kernel1D::initOptimalFirstDerivative5" ref="a1eeff31c2ffd35f352631fbe27d1dcdc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#a1eeff31c2ffd35f352631fbe27d1dcdc">initOptimalFirstDerivative5</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init an optimal 5-tap first derivative filter. This filter must be used in conjunction with the corresponding 5-tap smoothing filter (see <a class="el" href="classvigra_1_1Kernel1D.html#a068e7beed066f292a4ba8e777897526f">initOptimalFirstDerivativeSmoothing5()</a>), such that the derivative filter is applied along one dimension, and the smoothing filter along the other. The filter values are</p>
<div class="fragment"><pre class="fragment">            [0.1, 0.3, 0.0, -0.3, -0.1]
</pre></div><p>These values are optimal in the sense that the 5x5 filter obtained by combining this filter with the corresponding 5-tap smoothing filter is the best possible 5x5 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> first derivative filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.906.</p>
<p>If the filter is instead separably combined with itself, an almost optimal approximation of the mixed second <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative at scale sigma = 0.899 results.</p>
<p>Postconditions: </p>
<div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -2
            2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  2
            3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0
</pre></div> 
</div>
</div>
<a class="anchor" id="ab50c7edfcedf325996e21eb74a69a4d0"></a><!-- doxytag: member="vigra::Kernel1D::initOptimalSecondDerivative5" ref="ab50c7edfcedf325996e21eb74a69a4d0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#ab50c7edfcedf325996e21eb74a69a4d0">initOptimalSecondDerivative5</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init an optimal 5-tap second derivative filter. This filter must be used in conjunction with the corresponding 5-tap smoothing filter (see <a class="el" href="classvigra_1_1Kernel1D.html#abbe3a4b86ffdaf0e8e85d5ab7e75ed71">initOptimalSecondDerivativeSmoothing5()</a>), such that the derivative filter is applied along one dimension, and the smoothing filter along the other. The filter values are</p>
<div class="fragment"><pre class="fragment">            [0.22075, 0.117, -0.6755, 0.117, 0.22075]
</pre></div><p>These values are optimal in the sense that the 5x5 filter obtained by combining this filter with the corresponding 5-tap smoothing filter is the best possible 5x5 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> second derivative filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.817.</p>
<p>Postconditions: </p>
<div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -2
            2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>() ==  2
            3. <a class="code" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0
</pre></div> 
</div>
</div>
<a class="anchor" id="a1164e5b808619971ebc0e9783f972dc9"></a><!-- doxytag: member="vigra::Kernel1D::initExplicitly" ref="a1164e5b808619971ebc0e9783f972dc9" args="(int left, int right)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a>&amp; <a class="el" href="classvigra_1_1Kernel1D.html#a1164e5b808619971ebc0e9783f972dc9">initExplicitly</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Init the kernel by an explicit initializer list. The left and right boundaries of the kernel must be passed. A comma-separated initializer list is given after the assignment operator. This function is used like this:</p>
<div class="fragment"><pre class="fragment">            <span class="comment">// define horizontal Roberts filter</span>
            <a class="code" href="classvigra_1_1Kernel1D.html" title="Generic 1 dimensional convolution kernel.">vigra::Kernel1D&lt;float&gt;</a> roberts_gradient_x;

            roberts_gradient_x.<a class="code" href="classvigra_1_1Kernel1D.html#a1164e5b808619971ebc0e9783f972dc9">initExplicitly</a>(0, 1) = 1.0, -1.0;
</pre></div><p>The norm is set to the sum of the initializer values. If the wrong number of values is given, a run-time error results. It is, however, possible to give just one initializer. This creates an averaging filter with the given constant:</p>
<div class="fragment"><pre class="fragment">            <a class="code" href="classvigra_1_1Kernel1D.html" title="Generic 1 dimensional convolution kernel.">vigra::Kernel1D&lt;float&gt;</a> average5x1;

            average5x1.<a class="code" href="classvigra_1_1Kernel1D.html#a1164e5b808619971ebc0e9783f972dc9">initExplicitly</a>(-2, 2) = 1.0/5.0;
</pre></div><p>Here, the norm is set to value*size().</p>
<p><b> Preconditions:</b></p>
<div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a> &lt;= 0
            2. <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a> &gt;= 0
            3. the number of values in the initializer list
               is 1 or equals the size of the kernel.
</pre></div> 
</div>
</div>
<a class="anchor" id="afa906590f3f139cdfeb292a15add8e1f"></a><!-- doxytag: member="vigra::Kernel1D::center" ref="afa906590f3f139cdfeb292a15add8e1f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html#a8c0b17e9965a56ba56cb5fedc7119a92">iterator</a> <a class="el" href="classvigra_1_1Kernel1D.html#afa906590f3f139cdfeb292a15add8e1f">center</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get iterator to center of kernel</p>
<p>Postconditions: </p>
<div class="fragment"><pre class="fragment">            <a class="code" href="classvigra_1_1Kernel1D.html#afa906590f3f139cdfeb292a15add8e1f">center</a>()[<a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>()] ... <a class="code" href="classvigra_1_1Kernel1D.html#afa906590f3f139cdfeb292a15add8e1f">center</a>()[<a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>()] are valid kernel positions
</pre></div> 
</div>
</div>
<a class="anchor" id="a42bf8c098fec92f08714fdf0c72a66ff"></a><!-- doxytag: member="vigra::Kernel1D::operator[]" ref="a42bf8c098fec92f08714fdf0c72a66ff" args="(int location)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html#a130b31490ce7ba9051094274b190940d">reference</a> operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>location</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Access kernel value at specified location.</p>
<p>Preconditions: </p>
<div class="fragment"><pre class="fragment">            <a class="code" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a>() &lt;= location &lt;= <a class="code" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a>()
</pre></div> 
</div>
</div>
<a class="anchor" id="a265321ef4c7ad76f60e512fc09eef7c2"></a><!-- doxytag: member="vigra::Kernel1D::left" ref="a265321ef4c7ad76f60e512fc09eef7c2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>left border of kernel (inclusive), always &lt;= 0 </p>

</div>
</div>
<a class="anchor" id="ad04ec796f4e7db479575644d114974ef"></a><!-- doxytag: member="vigra::Kernel1D::right" ref="ad04ec796f4e7db479575644d114974ef" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>right border of kernel (inclusive), always &gt;= 0 </p>

</div>
</div>
<a class="anchor" id="ab8e4e3e2a7bf18888b71bdf9dda0770b"></a><!-- doxytag: member="vigra::Kernel1D::size" ref="ab8e4e3e2a7bf18888b71bdf9dda0770b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvigra_1_1Kernel1D.html#ab8e4e3e2a7bf18888b71bdf9dda0770b">size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>size of kernel (<a class="el" href="classvigra_1_1Kernel1D.html#ad04ec796f4e7db479575644d114974ef">right()</a> - <a class="el" href="classvigra_1_1Kernel1D.html#a265321ef4c7ad76f60e512fc09eef7c2">left()</a> + 1) </p>

</div>
</div>
<a class="anchor" id="a69dbff83a4127cc415a7eb796d95051e"></a><!-- doxytag: member="vigra::Kernel1D::borderTreatment" ref="a69dbff83a4127cc415a7eb796d95051e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BorderTreatmentMode <a class="el" href="classvigra_1_1Kernel1D.html#a69dbff83a4127cc415a7eb796d95051e">borderTreatment</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>current border treatment mode </p>

</div>
</div>
<a class="anchor" id="a647df9e68cc4da54a5c9d2ba13768c9a"></a><!-- doxytag: member="vigra::Kernel1D::setBorderTreatment" ref="a647df9e68cc4da54a5c9d2ba13768c9a" args="(BorderTreatmentMode new_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#a647df9e68cc4da54a5c9d2ba13768c9a">setBorderTreatment</a> </td>
          <td>(</td>
          <td class="paramtype">BorderTreatmentMode&#160;</td>
          <td class="paramname"><em>new_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set border treatment mode. </p>

</div>
</div>
<a class="anchor" id="aac41cd63a48de00144dbd94e4c38ead6"></a><!-- doxytag: member="vigra::Kernel1D::norm" ref="aac41cd63a48de00144dbd94e4c38ead6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a> <a class="el" href="classvigra_1_1Kernel1D.html#aac41cd63a48de00144dbd94e4c38ead6">norm</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>norm of kernel </p>

</div>
</div>
<a class="anchor" id="a7f10c82d42dacf3b4c9b691fb0840e35"></a><!-- doxytag: member="vigra::Kernel1D::normalize" ref="a7f10c82d42dacf3b4c9b691fb0840e35" args="(value_type norm, unsigned int derivativeOrder=0, double offset=0.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#a7f10c82d42dacf3b4c9b691fb0840e35">normalize</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#a821b18fa86c2bc45ccf17716429d438b">value_type</a>&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>derivativeOrder</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>set a new norm and normalize kernel, use the normalization formula for the given <code>derivativeOrder</code>. </p>

</div>
</div>
<a class="anchor" id="acd0de676568888d848beb97dcc53ae47"></a><!-- doxytag: member="vigra::Kernel1D::normalize" ref="acd0de676568888d848beb97dcc53ae47" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvigra_1_1Kernel1D.html#a7f10c82d42dacf3b4c9b691fb0840e35">normalize</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>normalize kernel to norm 1. </p>

</div>
</div>
<a class="anchor" id="a40e8567a7e13dacc22cadde2f9d1dcd0"></a><!-- doxytag: member="vigra::Kernel1D::accessor" ref="a40e8567a7e13dacc22cadde2f9d1dcd0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html#aa78445962f8673a1e2c1393dab7c7ad8">ConstAccessor</a> <a class="el" href="classvigra_1_1Kernel1D.html#a40e8567a7e13dacc22cadde2f9d1dcd0">accessor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>get a const accessor </p>

</div>
</div>
<a class="anchor" id="ac1e543db9ce291e86b9023cdb9202b5b"></a><!-- doxytag: member="vigra::Kernel1D::accessor" ref="ac1e543db9ce291e86b9023cdb9202b5b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html#a6c53fe234330a9d1604e0948fa47174b">Accessor</a> <a class="el" href="classvigra_1_1Kernel1D.html#a40e8567a7e13dacc22cadde2f9d1dcd0">accessor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>get an accessor </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>vigra/<a class="el" href="separableconvolution_8hxx_source.html">separableconvolution.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.9.1 (Thu Sep 5 2013)
</i>
</tr>
</table>


</BODY>
</HTML>
