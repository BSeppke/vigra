<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - vigra/multi_fft.hxx Source File</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{ 
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://hci.iwr.uni-heidelberg.de/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="contents">
<table class="main_heading">
<tr>
<td width="100%">vigra/multi_fft.hxx
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/************************************************************************/</span>
<a name="l00002"></a>00002 <span class="comment">/*                                                                      */</span>
<a name="l00003"></a>00003 <span class="comment">/*               Copyright 2009-2010 by Ullrich Koethe                  */</span>
<a name="l00004"></a>00004 <span class="comment">/*                                                                      */</span>
<a name="l00005"></a>00005 <span class="comment">/*    This file is part of the VIGRA computer vision library.           */</span>
<a name="l00006"></a>00006 <span class="comment">/*    The VIGRA Website is                                              */</span>
<a name="l00007"></a>00007 <span class="comment">/*        http://hci.iwr.uni-heidelberg.de/vigra/                       */</span>
<a name="l00008"></a>00008 <span class="comment">/*    Please direct questions, bug reports, and contributions to        */</span>
<a name="l00009"></a>00009 <span class="comment">/*        ullrich.koethe@iwr.uni-heidelberg.de    or                    */</span>
<a name="l00010"></a>00010 <span class="comment">/*        vigra@informatik.uni-hamburg.de                               */</span>
<a name="l00011"></a>00011 <span class="comment">/*                                                                      */</span>
<a name="l00012"></a>00012 <span class="comment">/*    Permission is hereby granted, free of charge, to any person       */</span>
<a name="l00013"></a>00013 <span class="comment">/*    obtaining a copy of this software and associated documentation    */</span>
<a name="l00014"></a>00014 <span class="comment">/*    files (the &quot;Software&quot;), to deal in the Software without           */</span>
<a name="l00015"></a>00015 <span class="comment">/*    restriction, including without limitation the rights to use,      */</span>
<a name="l00016"></a>00016 <span class="comment">/*    copy, modify, merge, publish, distribute, sublicense, and/or      */</span>
<a name="l00017"></a>00017 <span class="comment">/*    sell copies of the Software, and to permit persons to whom the    */</span>
<a name="l00018"></a>00018 <span class="comment">/*    Software is furnished to do so, subject to the following          */</span>
<a name="l00019"></a>00019 <span class="comment">/*    conditions:                                                       */</span>
<a name="l00020"></a>00020 <span class="comment">/*                                                                      */</span>
<a name="l00021"></a>00021 <span class="comment">/*    The above copyright notice and this permission notice shall be    */</span>
<a name="l00022"></a>00022 <span class="comment">/*    included in all copies or substantial portions of the             */</span>
<a name="l00023"></a>00023 <span class="comment">/*    Software.                                                         */</span>
<a name="l00024"></a>00024 <span class="comment">/*                                                                      */</span>
<a name="l00025"></a>00025 <span class="comment">/*    THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND    */</span>
<a name="l00026"></a>00026 <span class="comment">/*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES   */</span>
<a name="l00027"></a>00027 <span class="comment">/*    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND          */</span>
<a name="l00028"></a>00028 <span class="comment">/*    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT       */</span>
<a name="l00029"></a>00029 <span class="comment">/*    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,      */</span>
<a name="l00030"></a>00030 <span class="comment">/*    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING      */</span>
<a name="l00031"></a>00031 <span class="comment">/*    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR     */</span>
<a name="l00032"></a>00032 <span class="comment">/*    OTHER DEALINGS IN THE SOFTWARE.                                   */</span>
<a name="l00033"></a>00033 <span class="comment">/*                                                                      */</span>
<a name="l00034"></a>00034 <span class="comment">/************************************************************************/</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="preprocessor">#ifndef VIGRA_MULTI_FFT_HXX</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="preprocessor">#define VIGRA_MULTI_FFT_HXX</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;fftw3.hxx&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;multi_array.hxx&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;navigator.hxx&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;copyimage.hxx&quot;</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="keyword">namespace </span>vigra {
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="comment">/********************************************************/</span>
<a name="l00047"></a>00047 <span class="comment">/*                                                      */</span>
<a name="l00048"></a>00048 <span class="comment">/*                    Fourier Transform                 */</span>
<a name="l00049"></a>00049 <span class="comment">/*                                                      */</span>
<a name="l00050"></a>00050 <span class="comment">/********************************************************/</span>
<a name="l00051"></a>00051 <span class="comment"></span>
<a name="l00052"></a>00052 <span class="comment">/** \addtogroup FourierTransform </span>
<a name="l00053"></a>00053 <span class="comment">*/</span><span class="comment"></span>
<a name="l00054"></a>00054 <span class="comment">//@{</span>
<a name="l00055"></a>00055 <span class="comment"></span>
<a name="l00056"></a>00056 <span class="keyword">namespace </span>detail {
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> T, <span class="keyword">class</span> C&gt;
<a name="l00059"></a>00059 <span class="keywordtype">void</span> moveDCToCenterImpl(MultiArrayView&lt;N, T, C&gt; a, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> startDimension)
<a name="l00060"></a>00060 {
<a name="l00061"></a>00061     <span class="keyword">typedef</span> <span class="keyword">typename</span> MultiArrayView&lt;N, T, C&gt;::traverser Traverser;
<a name="l00062"></a>00062     <span class="keyword">typedef</span> MultiArrayNavigator&lt;Traverser, N&gt; Navigator;
<a name="l00063"></a>00063     <span class="keyword">typedef</span> <span class="keyword">typename</span> Navigator::iterator Iterator;
<a name="l00064"></a>00064     
<a name="l00065"></a>00065     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = startDimension; d &lt; N; ++d)
<a name="l00066"></a>00066     {
<a name="l00067"></a>00067         Navigator nav(a.traverser_begin(), a.shape(), d);
<a name="l00068"></a>00068 
<a name="l00069"></a>00069         <span class="keywordflow">for</span>( ; nav.hasMore(); nav++ )
<a name="l00070"></a>00070         {
<a name="l00071"></a>00071             Iterator i = nav.begin();
<a name="l00072"></a>00072             <span class="keywordtype">int</span> s  = nav.end() - i;
<a name="l00073"></a>00073             <span class="keywordtype">int</span> s2 = s/2;
<a name="l00074"></a>00074                 
<a name="l00075"></a>00075             <span class="keywordflow">if</span>(<a class="code" href="group__MathFunctions.html#ga3cf86b8d2300cd08b69024eb89f90115" title="Check if an integer is even.">even</a>(s))
<a name="l00076"></a>00076             {
<a name="l00077"></a>00077                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;s2; ++k)
<a name="l00078"></a>00078                 {
<a name="l00079"></a>00079                     std::swap(i[k], i[k+s2]);
<a name="l00080"></a>00080                 }
<a name="l00081"></a>00081             }
<a name="l00082"></a>00082             <span class="keywordflow">else</span>            
<a name="l00083"></a>00083             {
<a name="l00084"></a>00084                 T v = i[0];
<a name="l00085"></a>00085                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;s2; ++k)
<a name="l00086"></a>00086                 {
<a name="l00087"></a>00087                     i[k] = i[k+s2+1];
<a name="l00088"></a>00088                     i[k+s2+1] = i[k+1];
<a name="l00089"></a>00089                 }
<a name="l00090"></a>00090                 i[s2] = v;
<a name="l00091"></a>00091             }
<a name="l00092"></a>00092         }
<a name="l00093"></a>00093     }
<a name="l00094"></a>00094 }
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> T, <span class="keyword">class</span> C&gt;
<a name="l00097"></a>00097 <span class="keywordtype">void</span> moveDCToUpperLeftImpl(MultiArrayView&lt;N, T, C&gt; a, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> startDimension)
<a name="l00098"></a>00098 {
<a name="l00099"></a>00099     <span class="keyword">typedef</span> <span class="keyword">typename</span> MultiArrayView&lt;N, T, C&gt;::traverser Traverser;
<a name="l00100"></a>00100     <span class="keyword">typedef</span> MultiArrayNavigator&lt;Traverser, N&gt; Navigator;
<a name="l00101"></a>00101     <span class="keyword">typedef</span> <span class="keyword">typename</span> Navigator::iterator Iterator;
<a name="l00102"></a>00102     
<a name="l00103"></a>00103     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = startDimension; d &lt; N; ++d)
<a name="l00104"></a>00104     {
<a name="l00105"></a>00105         Navigator nav(a.traverser_begin(), a.shape(), d);
<a name="l00106"></a>00106 
<a name="l00107"></a>00107         <span class="keywordflow">for</span>( ; nav.hasMore(); nav++ )
<a name="l00108"></a>00108         {
<a name="l00109"></a>00109             Iterator i = nav.begin();
<a name="l00110"></a>00110             <span class="keywordtype">int</span> s  = nav.end() - i;
<a name="l00111"></a>00111             <span class="keywordtype">int</span> s2 = s/2;
<a name="l00112"></a>00112             
<a name="l00113"></a>00113             <span class="keywordflow">if</span>(<a class="code" href="group__MathFunctions.html#ga3cf86b8d2300cd08b69024eb89f90115" title="Check if an integer is even.">even</a>(s))
<a name="l00114"></a>00114             {
<a name="l00115"></a>00115                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;s2; ++k)
<a name="l00116"></a>00116                 {
<a name="l00117"></a>00117                     std::swap(i[k], i[k+s2]);
<a name="l00118"></a>00118                 }
<a name="l00119"></a>00119             }
<a name="l00120"></a>00120             <span class="keywordflow">else</span>            
<a name="l00121"></a>00121             {
<a name="l00122"></a>00122                 T v = i[s2];
<a name="l00123"></a>00123                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=s2; k&gt;0; --k)
<a name="l00124"></a>00124                 {
<a name="l00125"></a>00125                     i[k] = i[k+s2];
<a name="l00126"></a>00126                     i[k+s2] = i[k-1];
<a name="l00127"></a>00127                 }
<a name="l00128"></a>00128                 i[0] = v;
<a name="l00129"></a>00129             }
<a name="l00130"></a>00130         }
<a name="l00131"></a>00131     }
<a name="l00132"></a>00132 }
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 } <span class="comment">// namespace detail</span>
<a name="l00135"></a>00135 
<a name="l00136"></a>00136 <span class="comment">/********************************************************/</span>
<a name="l00137"></a>00137 <span class="comment">/*                                                      */</span>
<a name="l00138"></a>00138 <span class="comment">/*                     moveDCToCenter                   */</span>
<a name="l00139"></a>00139 <span class="comment">/*                                                      */</span>
<a name="l00140"></a>00140 <span class="comment">/********************************************************/</span>
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> T, <span class="keyword">class</span> C&gt;
<a name="l00143"></a>00143 <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__FourierTransform.html#gaecb29642aab8a911b4f53e289d31e5e5" title="Rearrange the quadrants of a Fourier image so that the origin is in the image center.">moveDCToCenter</a>(MultiArrayView&lt;N, T, C&gt; a)
<a name="l00144"></a>00144 {
<a name="l00145"></a>00145     detail::moveDCToCenterImpl(a, 0);
<a name="l00146"></a>00146 }
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> T, <span class="keyword">class</span> C&gt;
<a name="l00149"></a>00149 <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__FourierTransform.html#gaee27c376079af99e8e2148e7d23ffbbb" title="Rearrange the quadrants of a Fourier image so that the origin is in the image&#39;s upper left...">moveDCToUpperLeft</a>(MultiArrayView&lt;N, T, C&gt; a)
<a name="l00150"></a>00150 {
<a name="l00151"></a>00151     detail::moveDCToUpperLeftImpl(a, 0);
<a name="l00152"></a>00152 }
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> T, <span class="keyword">class</span> C&gt;
<a name="l00155"></a>00155 <span class="keyword">inline</span> <span class="keywordtype">void</span> moveDCToHalfspaceCenter(MultiArrayView&lt;N, T, C&gt; a)
<a name="l00156"></a>00156 {
<a name="l00157"></a>00157     detail::moveDCToCenterImpl(a, 1);
<a name="l00158"></a>00158 }
<a name="l00159"></a>00159 
<a name="l00160"></a>00160 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> T, <span class="keyword">class</span> C&gt;
<a name="l00161"></a>00161 <span class="keyword">inline</span> <span class="keywordtype">void</span> moveDCToHalfspaceUpperLeft(MultiArrayView&lt;N, T, C&gt; a)
<a name="l00162"></a>00162 {
<a name="l00163"></a>00163     detail::moveDCToUpperLeftImpl(a, 1);
<a name="l00164"></a>00164 }
<a name="l00165"></a>00165 
<a name="l00166"></a>00166 <span class="keyword">namespace </span>detail
<a name="l00167"></a>00167 {
<a name="l00168"></a>00168 
<a name="l00169"></a>00169 <span class="keyword">inline</span> fftw_plan 
<a name="l00170"></a>00170 fftwPlanCreate(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span>* shape, 
<a name="l00171"></a>00171                FFTWComplex&lt;double&gt; * in,  <span class="keywordtype">int</span>* instrides,  <span class="keywordtype">int</span> instep,
<a name="l00172"></a>00172                FFTWComplex&lt;double&gt; * out, <span class="keywordtype">int</span>* outstrides, <span class="keywordtype">int</span> outstep,
<a name="l00173"></a>00173                <span class="keywordtype">int</span> <a class="code" href="group__MathFunctions.html#ga99756ca23b738bdc82afba3b0e49df74" title="The sign function.">sign</a>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags)
<a name="l00174"></a>00174 {
<a name="l00175"></a>00175     <span class="keywordflow">return</span> fftw_plan_many_dft(N, shape, 1,
<a name="l00176"></a>00176                               (fftw_complex *)in, instrides, instep, 0,
<a name="l00177"></a>00177                               (fftw_complex *)out, outstrides, outstep, 0,
<a name="l00178"></a>00178                               sign, planner_flags);
<a name="l00179"></a>00179 }
<a name="l00180"></a>00180 
<a name="l00181"></a>00181 <span class="keyword">inline</span> fftw_plan 
<a name="l00182"></a>00182 fftwPlanCreate(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span>* shape, 
<a name="l00183"></a>00183                <span class="keywordtype">double</span> * in,  <span class="keywordtype">int</span>* instrides,  <span class="keywordtype">int</span> instep,
<a name="l00184"></a>00184                FFTWComplex&lt;double&gt; * out, <span class="keywordtype">int</span>* outstrides, <span class="keywordtype">int</span> outstep,
<a name="l00185"></a>00185                <span class="keywordtype">int</span> <span class="comment">/*sign is ignored*/</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags)
<a name="l00186"></a>00186 {
<a name="l00187"></a>00187     <span class="keywordflow">return</span> fftw_plan_many_dft_r2c(N, shape, 1,
<a name="l00188"></a>00188                                    in, instrides, instep, 0,
<a name="l00189"></a>00189                                    (fftw_complex *)out, outstrides, outstep, 0,
<a name="l00190"></a>00190                                    planner_flags);
<a name="l00191"></a>00191 }
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 <span class="keyword">inline</span> fftw_plan 
<a name="l00194"></a>00194 fftwPlanCreate(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span>* shape, 
<a name="l00195"></a>00195                FFTWComplex&lt;double&gt; * in,  <span class="keywordtype">int</span>* instrides,  <span class="keywordtype">int</span> instep,
<a name="l00196"></a>00196                <span class="keywordtype">double</span> * out, <span class="keywordtype">int</span>* outstrides, <span class="keywordtype">int</span> outstep,
<a name="l00197"></a>00197                <span class="keywordtype">int</span> <span class="comment">/*sign is ignored*/</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags)
<a name="l00198"></a>00198 {
<a name="l00199"></a>00199     <span class="keywordflow">return</span> fftw_plan_many_dft_c2r(N, shape, 1,
<a name="l00200"></a>00200                                   (fftw_complex *)in, instrides, instep, 0,
<a name="l00201"></a>00201                                   out, outstrides, outstep, 0,
<a name="l00202"></a>00202                                   planner_flags);
<a name="l00203"></a>00203 }
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 <span class="keyword">inline</span> fftwf_plan 
<a name="l00206"></a>00206 fftwPlanCreate(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span>* shape, 
<a name="l00207"></a>00207                FFTWComplex&lt;float&gt; * in,  <span class="keywordtype">int</span>* instrides,  <span class="keywordtype">int</span> instep,
<a name="l00208"></a>00208                FFTWComplex&lt;float&gt; * out, <span class="keywordtype">int</span>* outstrides, <span class="keywordtype">int</span> outstep,
<a name="l00209"></a>00209                <span class="keywordtype">int</span> sign, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags)
<a name="l00210"></a>00210 {
<a name="l00211"></a>00211     <span class="keywordflow">return</span> fftwf_plan_many_dft(N, shape, 1,
<a name="l00212"></a>00212                                (fftwf_complex *)in, instrides, instep, 0,
<a name="l00213"></a>00213                                (fftwf_complex *)out, outstrides, outstep, 0,
<a name="l00214"></a>00214                                sign, planner_flags);
<a name="l00215"></a>00215 }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 <span class="keyword">inline</span> fftwf_plan 
<a name="l00218"></a>00218 fftwPlanCreate(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span>* shape, 
<a name="l00219"></a>00219                <span class="keywordtype">float</span> * in,  <span class="keywordtype">int</span>* instrides,  <span class="keywordtype">int</span> instep,
<a name="l00220"></a>00220                FFTWComplex&lt;float&gt; * out, <span class="keywordtype">int</span>* outstrides, <span class="keywordtype">int</span> outstep,
<a name="l00221"></a>00221                <span class="keywordtype">int</span> <span class="comment">/*sign is ignored*/</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags)
<a name="l00222"></a>00222 {
<a name="l00223"></a>00223     <span class="keywordflow">return</span> fftwf_plan_many_dft_r2c(N, shape, 1,
<a name="l00224"></a>00224                                     in, instrides, instep, 0,
<a name="l00225"></a>00225                                     (fftwf_complex *)out, outstrides, outstep, 0,
<a name="l00226"></a>00226                                     planner_flags);
<a name="l00227"></a>00227 }
<a name="l00228"></a>00228 
<a name="l00229"></a>00229 <span class="keyword">inline</span> fftwf_plan 
<a name="l00230"></a>00230 fftwPlanCreate(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span>* shape, 
<a name="l00231"></a>00231                FFTWComplex&lt;float&gt; * in,  <span class="keywordtype">int</span>* instrides,  <span class="keywordtype">int</span> instep,
<a name="l00232"></a>00232                <span class="keywordtype">float</span> * out, <span class="keywordtype">int</span>* outstrides, <span class="keywordtype">int</span> outstep,
<a name="l00233"></a>00233                <span class="keywordtype">int</span> <span class="comment">/*sign is ignored*/</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags)
<a name="l00234"></a>00234 {
<a name="l00235"></a>00235     <span class="keywordflow">return</span> fftwf_plan_many_dft_c2r(N, shape, 1,
<a name="l00236"></a>00236                                    (fftwf_complex *)in, instrides, instep, 0,
<a name="l00237"></a>00237                                    out, outstrides, outstep, 0,
<a name="l00238"></a>00238                                    planner_flags);
<a name="l00239"></a>00239 }
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 <span class="keyword">inline</span> fftwl_plan 
<a name="l00242"></a>00242 fftwPlanCreate(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span>* shape, 
<a name="l00243"></a>00243                FFTWComplex&lt;long double&gt; * in,  <span class="keywordtype">int</span>* instrides,  <span class="keywordtype">int</span> instep,
<a name="l00244"></a>00244                FFTWComplex&lt;long double&gt; * out, <span class="keywordtype">int</span>* outstrides, <span class="keywordtype">int</span> outstep,
<a name="l00245"></a>00245                <span class="keywordtype">int</span> sign, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags)
<a name="l00246"></a>00246 {
<a name="l00247"></a>00247     <span class="keywordflow">return</span> fftwl_plan_many_dft(N, shape, 1,
<a name="l00248"></a>00248                                (fftwl_complex *)in, instrides, instep, 0,
<a name="l00249"></a>00249                                (fftwl_complex *)out, outstrides, outstep, 0,
<a name="l00250"></a>00250                                sign, planner_flags);
<a name="l00251"></a>00251 }
<a name="l00252"></a>00252 
<a name="l00253"></a>00253 <span class="keyword">inline</span> fftwl_plan 
<a name="l00254"></a>00254 fftwPlanCreate(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span>* shape, 
<a name="l00255"></a>00255                <span class="keywordtype">long</span> <span class="keywordtype">double</span> * in,  <span class="keywordtype">int</span>* instrides,  <span class="keywordtype">int</span> instep,
<a name="l00256"></a>00256                FFTWComplex&lt;long double&gt; * out, <span class="keywordtype">int</span>* outstrides, <span class="keywordtype">int</span> outstep,
<a name="l00257"></a>00257                <span class="keywordtype">int</span> <span class="comment">/*sign is ignored*/</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags)
<a name="l00258"></a>00258 {
<a name="l00259"></a>00259     <span class="keywordflow">return</span> fftwl_plan_many_dft_r2c(N, shape, 1,
<a name="l00260"></a>00260                                     in, instrides, instep, 0,
<a name="l00261"></a>00261                                     (fftwl_complex *)out, outstrides, outstep, 0,
<a name="l00262"></a>00262                                     planner_flags);
<a name="l00263"></a>00263 }
<a name="l00264"></a>00264 
<a name="l00265"></a>00265 <span class="keyword">inline</span> fftwl_plan 
<a name="l00266"></a>00266 fftwPlanCreate(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keywordtype">int</span>* shape, 
<a name="l00267"></a>00267                FFTWComplex&lt;long double&gt; * in,  <span class="keywordtype">int</span>* instrides,  <span class="keywordtype">int</span> instep,
<a name="l00268"></a>00268                <span class="keywordtype">long</span> <span class="keywordtype">double</span> * out, <span class="keywordtype">int</span>* outstrides, <span class="keywordtype">int</span> outstep,
<a name="l00269"></a>00269                <span class="keywordtype">int</span> <span class="comment">/*sign is ignored*/</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags)
<a name="l00270"></a>00270 {
<a name="l00271"></a>00271     <span class="keywordflow">return</span> fftwl_plan_many_dft_c2r(N, shape, 1,
<a name="l00272"></a>00272                                    (fftwl_complex *)in, instrides, instep, 0,
<a name="l00273"></a>00273                                    out, outstrides, outstep, 0,
<a name="l00274"></a>00274                                    planner_flags);
<a name="l00275"></a>00275 }
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 <span class="keyword">inline</span> <span class="keywordtype">void</span> fftwPlanDestroy(fftw_plan plan)
<a name="l00278"></a>00278 {
<a name="l00279"></a>00279     <span class="keywordflow">if</span>(plan != 0)
<a name="l00280"></a>00280         fftw_destroy_plan(plan);
<a name="l00281"></a>00281 }
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 <span class="keyword">inline</span> <span class="keywordtype">void</span> fftwPlanDestroy(fftwf_plan plan)
<a name="l00284"></a>00284 {
<a name="l00285"></a>00285     <span class="keywordflow">if</span>(plan != 0)
<a name="l00286"></a>00286         fftwf_destroy_plan(plan);
<a name="l00287"></a>00287 }
<a name="l00288"></a>00288 
<a name="l00289"></a>00289 <span class="keyword">inline</span> <span class="keywordtype">void</span> fftwPlanDestroy(fftwl_plan plan)
<a name="l00290"></a>00290 {
<a name="l00291"></a>00291     <span class="keywordflow">if</span>(plan != 0)
<a name="l00292"></a>00292         fftwl_destroy_plan(plan);
<a name="l00293"></a>00293 }
<a name="l00294"></a>00294 
<a name="l00295"></a>00295 <span class="keyword">inline</span> <span class="keywordtype">void</span> 
<a name="l00296"></a>00296 fftwPlanExecute(fftw_plan plan) 
<a name="l00297"></a>00297 {
<a name="l00298"></a>00298     fftw_execute(plan);
<a name="l00299"></a>00299 }
<a name="l00300"></a>00300 
<a name="l00301"></a>00301 <span class="keyword">inline</span> <span class="keywordtype">void</span> 
<a name="l00302"></a>00302 fftwPlanExecute(fftwf_plan plan) 
<a name="l00303"></a>00303 {
<a name="l00304"></a>00304     fftwf_execute(plan);
<a name="l00305"></a>00305 }
<a name="l00306"></a>00306 
<a name="l00307"></a>00307 <span class="keyword">inline</span> <span class="keywordtype">void</span> 
<a name="l00308"></a>00308 fftwPlanExecute(fftwl_plan plan) 
<a name="l00309"></a>00309 {
<a name="l00310"></a>00310     fftwl_execute(plan);
<a name="l00311"></a>00311 }
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 <span class="keyword">inline</span> <span class="keywordtype">void</span> 
<a name="l00314"></a>00314 fftwPlanExecute(fftw_plan plan, FFTWComplex&lt;double&gt; * in,  FFTWComplex&lt;double&gt; * out) 
<a name="l00315"></a>00315 {
<a name="l00316"></a>00316     fftw_execute_dft(plan, (fftw_complex *)in, (fftw_complex *)out);
<a name="l00317"></a>00317 }
<a name="l00318"></a>00318 
<a name="l00319"></a>00319 <span class="keyword">inline</span> <span class="keywordtype">void</span> 
<a name="l00320"></a>00320 fftwPlanExecute(fftw_plan plan, <span class="keywordtype">double</span> * in,  FFTWComplex&lt;double&gt; * out) 
<a name="l00321"></a>00321 {
<a name="l00322"></a>00322     fftw_execute_dft_r2c(plan, in, (fftw_complex *)out);
<a name="l00323"></a>00323 }
<a name="l00324"></a>00324 
<a name="l00325"></a>00325 <span class="keyword">inline</span> <span class="keywordtype">void</span> 
<a name="l00326"></a>00326 fftwPlanExecute(fftw_plan plan, FFTWComplex&lt;double&gt; * in,  <span class="keywordtype">double</span> * out) 
<a name="l00327"></a>00327 {
<a name="l00328"></a>00328     fftw_execute_dft_c2r(plan, (fftw_complex *)in, out);
<a name="l00329"></a>00329 }
<a name="l00330"></a>00330 
<a name="l00331"></a>00331 <span class="keyword">inline</span> <span class="keywordtype">void</span> 
<a name="l00332"></a>00332 fftwPlanExecute(fftwf_plan plan, FFTWComplex&lt;float&gt; * in,  FFTWComplex&lt;float&gt; * out) 
<a name="l00333"></a>00333 {
<a name="l00334"></a>00334     fftwf_execute_dft(plan, (fftwf_complex *)in, (fftwf_complex *)out);
<a name="l00335"></a>00335 }
<a name="l00336"></a>00336 
<a name="l00337"></a>00337 <span class="keyword">inline</span> <span class="keywordtype">void</span> 
<a name="l00338"></a>00338 fftwPlanExecute(fftwf_plan plan, <span class="keywordtype">float</span> * in,  FFTWComplex&lt;float&gt; * out) 
<a name="l00339"></a>00339 {
<a name="l00340"></a>00340     fftwf_execute_dft_r2c(plan, in, (fftwf_complex *)out);
<a name="l00341"></a>00341 }
<a name="l00342"></a>00342 
<a name="l00343"></a>00343 <span class="keyword">inline</span> <span class="keywordtype">void</span> 
<a name="l00344"></a>00344 fftwPlanExecute(fftwf_plan plan, FFTWComplex&lt;float&gt; * in,  <span class="keywordtype">float</span> * out) 
<a name="l00345"></a>00345 {
<a name="l00346"></a>00346     fftwf_execute_dft_c2r(plan, (fftwf_complex *)in, out);
<a name="l00347"></a>00347 }
<a name="l00348"></a>00348 
<a name="l00349"></a>00349 <span class="keyword">inline</span> <span class="keywordtype">void</span> 
<a name="l00350"></a>00350 fftwPlanExecute(fftwl_plan plan, FFTWComplex&lt;long double&gt; * in,  FFTWComplex&lt;long double&gt; * out) 
<a name="l00351"></a>00351 {
<a name="l00352"></a>00352     fftwl_execute_dft(plan, (fftwl_complex *)in, (fftwl_complex *)out);
<a name="l00353"></a>00353 }
<a name="l00354"></a>00354 
<a name="l00355"></a>00355 <span class="keyword">inline</span> <span class="keywordtype">void</span> 
<a name="l00356"></a>00356 fftwPlanExecute(fftwl_plan plan, <span class="keywordtype">long</span> <span class="keywordtype">double</span> * in,  FFTWComplex&lt;long double&gt; * out) 
<a name="l00357"></a>00357 {
<a name="l00358"></a>00358     fftwl_execute_dft_r2c(plan, in, (fftwl_complex *)out);
<a name="l00359"></a>00359 }
<a name="l00360"></a>00360 
<a name="l00361"></a>00361 <span class="keyword">inline</span> <span class="keywordtype">void</span> 
<a name="l00362"></a>00362 fftwPlanExecute(fftwl_plan plan, FFTWComplex&lt;long double&gt; * in,  <span class="keywordtype">long</span> <span class="keywordtype">double</span> * out) 
<a name="l00363"></a>00363 {
<a name="l00364"></a>00364     fftwl_execute_dft_c2r(plan, (fftwl_complex *)in, out);
<a name="l00365"></a>00365 }
<a name="l00366"></a>00366 
<a name="l00367"></a>00367 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> DUMMY&gt;
<a name="l00368"></a>00368 <span class="keyword">struct </span>FFTWPaddingSize
<a name="l00369"></a>00369 {
<a name="l00370"></a>00370     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> size = 1330;
<a name="l00371"></a>00371     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> evenSize = 1063;
<a name="l00372"></a>00372     <span class="keyword">static</span> <span class="keywordtype">int</span> goodSizes[size];
<a name="l00373"></a>00373     <span class="keyword">static</span> <span class="keywordtype">int</span> goodEvenSizes[evenSize];
<a name="l00374"></a>00374     
<a name="l00375"></a>00375     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> find(<span class="keywordtype">int</span> s)
<a name="l00376"></a>00376     {
<a name="l00377"></a>00377         <span class="keywordflow">if</span>(s &lt;= 0 || s &gt;= goodSizes[size-1])
<a name="l00378"></a>00378             <span class="keywordflow">return</span> s;
<a name="l00379"></a>00379         <span class="comment">// find the smallest padding size that is at least as large as &#39;s&#39;</span>
<a name="l00380"></a>00380         <span class="keywordtype">int</span> * upperBound = std::upper_bound(goodSizes, goodSizes+size, s);
<a name="l00381"></a>00381         <span class="keywordflow">if</span>(upperBound &gt; goodSizes &amp;&amp; upperBound[-1] == s)
<a name="l00382"></a>00382             <span class="keywordflow">return</span> s;
<a name="l00383"></a>00383         <span class="keywordflow">else</span>
<a name="l00384"></a>00384             <span class="keywordflow">return</span> *upperBound;
<a name="l00385"></a>00385     }
<a name="l00386"></a>00386 
<a name="l00387"></a>00387     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> findEven(<span class="keywordtype">int</span> s)
<a name="l00388"></a>00388     {
<a name="l00389"></a>00389         <span class="keywordflow">if</span>(s &lt;= 0 || s &gt;= goodEvenSizes[evenSize-1])
<a name="l00390"></a>00390             <span class="keywordflow">return</span> s;
<a name="l00391"></a>00391         <span class="comment">// find the smallest padding size that is at least as large as &#39;s&#39;</span>
<a name="l00392"></a>00392         <span class="keywordtype">int</span> * upperBound = std::upper_bound(goodEvenSizes, goodEvenSizes+evenSize, s);
<a name="l00393"></a>00393         <span class="keywordflow">if</span>(upperBound &gt; goodEvenSizes &amp;&amp; upperBound[-1] == s)
<a name="l00394"></a>00394             <span class="keywordflow">return</span> s;
<a name="l00395"></a>00395         <span class="keywordflow">else</span>
<a name="l00396"></a>00396             <span class="keywordflow">return</span> *upperBound;
<a name="l00397"></a>00397     }
<a name="l00398"></a>00398 };
<a name="l00399"></a>00399     
<a name="l00400"></a>00400     <span class="comment">// Image sizes where FFTW is fast. The list contains all</span>
<a name="l00401"></a>00401     <span class="comment">// numbers less than 100000 whose prime decomposition is of the form</span>
<a name="l00402"></a>00402     <span class="comment">// 2^a*3^b*5^c*7^d*11^e*13^f, where e+f is either 0 or 1, and the </span>
<a name="l00403"></a>00403     <span class="comment">// other exponents are arbitrary</span>
<a name="l00404"></a>00404 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> DUMMY&gt;
<a name="l00405"></a>00405 <span class="keywordtype">int</span> FFTWPaddingSize&lt;DUMMY&gt;::goodSizes[size] = {
<a name="l00406"></a>00406         1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 
<a name="l00407"></a>00407         18, 20, 21, 22, 24, 25, 26, 27, 28, 30, 32, 33, 35, 36, 39, 40, 42, 44, 45, 48, 
<a name="l00408"></a>00408         49, 50, 52, 54, 55, 56, 60, 63, 64, 65, 66, 70, 72, 75, 77, 78, 80, 81, 
<a name="l00409"></a>00409         84, 88, 90, 91, 96, 98, 99, 100, 104, 105, 108, 110, 112, 117, 120, 125, 
<a name="l00410"></a>00410         126, 128, 130, 132, 135, 140, 144, 147, 150, 154, 156, 160, 162, 165, 
<a name="l00411"></a>00411         168, 175, 176, 180, 182, 189, 192, 195, 196, 198, 200, 208, 210, 216, 
<a name="l00412"></a>00412         220, 224, 225, 231, 234, 240, 243, 245, 250, 252, 256, 260, 264, 270, 
<a name="l00413"></a>00413         273, 275, 280, 288, 294, 297, 300, 308, 312, 315, 320, 324, 325, 330, 
<a name="l00414"></a>00414         336, 343, 350, 351, 352, 360, 364, 375, 378, 384, 385, 390, 392, 396, 
<a name="l00415"></a>00415         400, 405, 416, 420, 432, 440, 441, 448, 450, 455, 462, 468, 480, 486, 
<a name="l00416"></a>00416         490, 495, 500, 504, 512, 520, 525, 528, 539, 540, 546, 550, 560, 567, 
<a name="l00417"></a>00417         576, 585, 588, 594, 600, 616, 624, 625, 630, 637, 640, 648, 650, 660, 
<a name="l00418"></a>00418         672, 675, 686, 693, 700, 702, 704, 720, 728, 729, 735, 750, 756, 768, 
<a name="l00419"></a>00419         770, 780, 784, 792, 800, 810, 819, 825, 832, 840, 864, 875, 880, 882, 
<a name="l00420"></a>00420         891, 896, 900, 910, 924, 936, 945, 960, 972, 975, 980, 990, 1000, 1008, 
<a name="l00421"></a>00421         1024, 1029, 1040, 1050, 1053, 1056, 1078, 1080, 1092, 1100, 1120, 1125, 
<a name="l00422"></a>00422         1134, 1152, 1155, 1170, 1176, 1188, 1200, 1215, 1225, 1232, 1248, 1250, 
<a name="l00423"></a>00423         1260, 1274, 1280, 1296, 1300, 1320, 1323, 1344, 1350, 1365, 1372, 1375, 
<a name="l00424"></a>00424         1386, 1400, 1404, 1408, 1440, 1456, 1458, 1470, 1485, 1500, 1512, 1536, 
<a name="l00425"></a>00425         1540, 1560, 1568, 1575, 1584, 1600, 1617, 1620, 1625, 1638, 1650, 1664, 
<a name="l00426"></a>00426         1680, 1701, 1715, 1728, 1750, 1755, 1760, 1764, 1782, 1792, 1800, 1820, 
<a name="l00427"></a>00427         1848, 1872, 1875, 1890, 1911, 1920, 1925, 1944, 1950, 1960, 1980, 2000, 
<a name="l00428"></a>00428         2016, 2025, 2048, 2058, 2079, 2080, 2100, 2106, 2112, 2156, 2160, 2184, 
<a name="l00429"></a>00429         2187, 2200, 2205, 2240, 2250, 2268, 2275, 2304, 2310, 2340, 2352, 2376, 
<a name="l00430"></a>00430         2400, 2401, 2430, 2450, 2457, 2464, 2475, 2496, 2500, 2520, 2548, 2560, 
<a name="l00431"></a>00431         2592, 2600, 2625, 2640, 2646, 2673, 2688, 2695, 2700, 2730, 2744, 2750, 
<a name="l00432"></a>00432         2772, 2800, 2808, 2816, 2835, 2880, 2912, 2916, 2925, 2940, 2970, 3000, 
<a name="l00433"></a>00433         3024, 3072, 3080, 3087, 3120, 3125, 3136, 3150, 3159, 3168, 3185, 3200, 
<a name="l00434"></a>00434         3234, 3240, 3250, 3276, 3300, 3328, 3360, 3375, 3402, 3430, 3456, 3465, 
<a name="l00435"></a>00435         3500, 3510, 3520, 3528, 3564, 3584, 3600, 3640, 3645, 3675, 3696, 3744, 
<a name="l00436"></a>00436         3750, 3773, 3780, 3822, 3840, 3850, 3888, 3900, 3920, 3960, 3969, 4000, 
<a name="l00437"></a>00437         4032, 4050, 4095, 4096, 4116, 4125, 4158, 4160, 4200, 4212, 4224, 4312, 
<a name="l00438"></a>00438         4320, 4368, 4374, 4375, 4400, 4410, 4455, 4459, 4480, 4500, 4536, 4550, 
<a name="l00439"></a>00439         4608, 4620, 4680, 4704, 4725, 4752, 4800, 4802, 4851, 4860, 4875, 4900, 
<a name="l00440"></a>00440         4914, 4928, 4950, 4992, 5000, 5040, 5096, 5103, 5120, 5145, 5184, 5200, 
<a name="l00441"></a>00441         5250, 5265, 5280, 5292, 5346, 5376, 5390, 5400, 5460, 5488, 5500, 5544, 
<a name="l00442"></a>00442         5600, 5616, 5625, 5632, 5670, 5733, 5760, 5775, 5824, 5832, 5850, 5880, 
<a name="l00443"></a>00443         5940, 6000, 6048, 6075, 6125, 6144, 6160, 6174, 6237, 6240, 6250, 6272, 
<a name="l00444"></a>00444         6300, 6318, 6336, 6370, 6400, 6468, 6480, 6500, 6552, 6561, 6600, 6615, 
<a name="l00445"></a>00445         6656, 6720, 6750, 6804, 6825, 6860, 6875, 6912, 6930, 7000, 7020, 7040, 
<a name="l00446"></a>00446         7056, 7128, 7168, 7200, 7203, 7280, 7290, 7350, 7371, 7392, 7425, 7488, 
<a name="l00447"></a>00447         7500, 7546, 7560, 7644, 7680, 7700, 7776, 7800, 7840, 7875, 7920, 7938, 
<a name="l00448"></a>00448         8000, 8019, 8064, 8085, 8100, 8125, 8190, 8192, 8232, 8250, 8316, 8320, 
<a name="l00449"></a>00449         8400, 8424, 8448, 8505, 8575, 8624, 8640, 8736, 8748, 8750, 8775, 8800, 
<a name="l00450"></a>00450         8820, 8910, 8918, 8960, 9000, 9072, 9100, 9216, 9240, 9261, 9360, 9375, 
<a name="l00451"></a>00451         9408, 9450, 9477, 9504, 9555, 9600, 9604, 9625, 9702, 9720, 9750, 9800, 
<a name="l00452"></a>00452         9828, 9856, 9900, 9984, 10000, 10080, 10125, 10192, 10206, 10240, 10290, 
<a name="l00453"></a>00453         10368, 10395, 10400, 10500, 10530, 10560, 10584, 10692, 10752, 10780, 
<a name="l00454"></a>00454         10800, 10920, 10935, 10976, 11000, 11025, 11088, 11200, 11232, 11250, 
<a name="l00455"></a>00455         11264, 11319, 11340, 11375, 11466, 11520, 11550, 11648, 11664, 11700, 
<a name="l00456"></a>00456         11760, 11880, 11907, 12000, 12005, 12096, 12150, 12250, 12285, 12288, 
<a name="l00457"></a>00457         12320, 12348, 12375, 12474, 12480, 12500, 12544, 12600, 12636, 12672, 
<a name="l00458"></a>00458         12740, 12800, 12936, 12960, 13000, 13104, 13122, 13125, 13200, 13230, 
<a name="l00459"></a>00459         13312, 13365, 13377, 13440, 13475, 13500, 13608, 13650, 13720, 13750, 
<a name="l00460"></a>00460         13824, 13860, 14000, 14040, 14080, 14112, 14175, 14256, 14336, 14400, 
<a name="l00461"></a>00461         14406, 14553, 14560, 14580, 14625, 14700, 14742, 14784, 14850, 14976, 
<a name="l00462"></a>00462         15000, 15092, 15120, 15288, 15309, 15360, 15400, 15435, 15552, 15600, 
<a name="l00463"></a>00463         15625, 15680, 15750, 15795, 15840, 15876, 15925, 16000, 16038, 16128, 
<a name="l00464"></a>00464         16170, 16200, 16250, 16380, 16384, 16464, 16500, 16632, 16640, 16800, 
<a name="l00465"></a>00465         16807, 16848, 16875, 16896, 17010, 17150, 17199, 17248, 17280, 17325, 
<a name="l00466"></a>00466         17472, 17496, 17500, 17550, 17600, 17640, 17820, 17836, 17920, 18000, 
<a name="l00467"></a>00467         18144, 18200, 18225, 18375, 18432, 18480, 18522, 18711, 18720, 18750, 
<a name="l00468"></a>00468         18816, 18865, 18900, 18954, 19008, 19110, 19200, 19208, 19250, 19404, 
<a name="l00469"></a>00469         19440, 19500, 19600, 19656, 19683, 19712, 19800, 19845, 19968, 20000, 
<a name="l00470"></a>00470         20160, 20250, 20384, 20412, 20475, 20480, 20580, 20625, 20736, 20790, 
<a name="l00471"></a>00471         20800, 21000, 21060, 21120, 21168, 21384, 21504, 21560, 21600, 21609, 
<a name="l00472"></a>00472         21840, 21870, 21875, 21952, 22000, 22050, 22113, 22176, 22275, 22295, 
<a name="l00473"></a>00473         22400, 22464, 22500, 22528, 22638, 22680, 22750, 22932, 23040, 23100, 
<a name="l00474"></a>00474         23296, 23328, 23400, 23520, 23625, 23760, 23814, 24000, 24010, 24057, 
<a name="l00475"></a>00475         24192, 24255, 24300, 24375, 24500, 24570, 24576, 24640, 24696, 24750, 
<a name="l00476"></a>00476         24948, 24960, 25000, 25088, 25200, 25272, 25344, 25480, 25515, 25600, 
<a name="l00477"></a>00477         25725, 25872, 25920, 26000, 26208, 26244, 26250, 26325, 26400, 26411, 
<a name="l00478"></a>00478         26460, 26624, 26730, 26754, 26880, 26950, 27000, 27216, 27300, 27440, 
<a name="l00479"></a>00479         27500, 27648, 27720, 27783, 28000, 28080, 28125, 28160, 28224, 28350, 
<a name="l00480"></a>00480         28431, 28512, 28665, 28672, 28800, 28812, 28875, 29106, 29120, 29160, 
<a name="l00481"></a>00481         29250, 29400, 29484, 29568, 29700, 29952, 30000, 30184, 30240, 30375, 
<a name="l00482"></a>00482         30576, 30618, 30625, 30720, 30800, 30870, 31104, 31185, 31200, 31213, 
<a name="l00483"></a>00483         31250, 31360, 31500, 31590, 31680, 31752, 31850, 32000, 32076, 32256, 
<a name="l00484"></a>00484         32340, 32400, 32500, 32760, 32768, 32805, 32928, 33000, 33075, 33264, 
<a name="l00485"></a>00485         33280, 33600, 33614, 33696, 33750, 33792, 33957, 34020, 34125, 34300, 
<a name="l00486"></a>00486         34375, 34398, 34496, 34560, 34650, 34944, 34992, 35000, 35100, 35200, 
<a name="l00487"></a>00487         35280, 35640, 35672, 35721, 35840, 36000, 36015, 36288, 36400, 36450, 
<a name="l00488"></a>00488         36750, 36855, 36864, 36960, 37044, 37125, 37422, 37440, 37500, 37632, 
<a name="l00489"></a>00489         37730, 37800, 37908, 38016, 38220, 38400, 38416, 38500, 38808, 38880, 
<a name="l00490"></a>00490         39000, 39200, 39312, 39366, 39375, 39424, 39600, 39690, 39936, 40000, 
<a name="l00491"></a>00491         40095, 40131, 40320, 40425, 40500, 40625, 40768, 40824, 40950, 40960, 
<a name="l00492"></a>00492         41160, 41250, 41472, 41580, 41600, 42000, 42120, 42240, 42336, 42525, 
<a name="l00493"></a>00493         42768, 42875, 43008, 43120, 43200, 43218, 43659, 43680, 43740, 43750, 
<a name="l00494"></a>00494         43875, 43904, 44000, 44100, 44226, 44352, 44550, 44590, 44800, 44928, 
<a name="l00495"></a>00495         45000, 45056, 45276, 45360, 45500, 45864, 45927, 46080, 46200, 46305, 
<a name="l00496"></a>00496         46592, 46656, 46800, 46875, 47040, 47250, 47385, 47520, 47628, 47775, 
<a name="l00497"></a>00497         48000, 48020, 48114, 48125, 48384, 48510, 48600, 48750, 49000, 49140, 
<a name="l00498"></a>00498         49152, 49280, 49392, 49500, 49896, 49920, 50000, 50176, 50400, 50421, 
<a name="l00499"></a>00499         50544, 50625, 50688, 50960, 51030, 51200, 51450, 51597, 51744, 51840, 
<a name="l00500"></a>00500         51975, 52000, 52416, 52488, 52500, 52650, 52800, 52822, 52920, 53248, 
<a name="l00501"></a>00501         53460, 53508, 53760, 53900, 54000, 54432, 54600, 54675, 54880, 55000, 
<a name="l00502"></a>00502         55125, 55296, 55440, 55566, 56000, 56133, 56160, 56250, 56320, 56448, 
<a name="l00503"></a>00503         56595, 56700, 56862, 56875, 57024, 57330, 57344, 57600, 57624, 57750, 
<a name="l00504"></a>00504         58212, 58240, 58320, 58500, 58800, 58968, 59049, 59136, 59400, 59535, 
<a name="l00505"></a>00505         59904, 60000, 60025, 60368, 60480, 60750, 61152, 61236, 61250, 61425, 
<a name="l00506"></a>00506         61440, 61600, 61740, 61875, 62208, 62370, 62400, 62426, 62500, 62720, 
<a name="l00507"></a>00507         63000, 63180, 63360, 63504, 63700, 64000, 64152, 64512, 64680, 64800, 
<a name="l00508"></a>00508         64827, 65000, 65520, 65536, 65610, 65625, 65856, 66000, 66150, 66339, 
<a name="l00509"></a>00509         66528, 66560, 66825, 66885, 67200, 67228, 67375, 67392, 67500, 67584, 
<a name="l00510"></a>00510         67914, 68040, 68250, 68600, 68750, 68796, 68992, 69120, 69300, 69888, 
<a name="l00511"></a>00511         69984, 70000, 70200, 70400, 70560, 70875, 71280, 71344, 71442, 71680, 
<a name="l00512"></a>00512         72000, 72030, 72171, 72576, 72765, 72800, 72900, 73125, 73500, 73710, 
<a name="l00513"></a>00513         73728, 73920, 74088, 74250, 74844, 74880, 75000, 75264, 75460, 75600, 
<a name="l00514"></a>00514         75816, 76032, 76440, 76545, 76800, 76832, 77000, 77175, 77616, 77760, 
<a name="l00515"></a>00515         78000, 78125, 78400, 78624, 78732, 78750, 78848, 78975, 79200, 79233, 
<a name="l00516"></a>00516         79380, 79625, 79872, 80000, 80190, 80262, 80640, 80850, 81000, 81250, 
<a name="l00517"></a>00517         81536, 81648, 81900, 81920, 82320, 82500, 82944, 83160, 83200, 83349, 
<a name="l00518"></a>00518         84000, 84035, 84240, 84375, 84480, 84672, 85050, 85293, 85536, 85750, 
<a name="l00519"></a>00519         85995, 86016, 86240, 86400, 86436, 86625, 87318, 87360, 87480, 87500, 
<a name="l00520"></a>00520         87750, 87808, 88000, 88200, 88452, 88704, 89100, 89180, 89600, 89856, 
<a name="l00521"></a>00521         90000, 90112, 90552, 90720, 91000, 91125, 91728, 91854, 91875, 92160, 
<a name="l00522"></a>00522         92400, 92610, 93184, 93312, 93555, 93600, 93639, 93750, 94080, 94325, 
<a name="l00523"></a>00523         94500, 94770, 95040, 95256, 95550, 96000, 96040, 96228, 96250, 96768, 
<a name="l00524"></a>00524         97020, 97200, 97500, 98000, 98280, 98304, 98415, 98560, 98784, 99000, 
<a name="l00525"></a>00525         99225, 99792, 99840 
<a name="l00526"></a>00526 }; 
<a name="l00527"></a>00527 
<a name="l00528"></a>00528 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> DUMMY&gt;
<a name="l00529"></a>00529 <span class="keywordtype">int</span> FFTWPaddingSize&lt;DUMMY&gt;::goodEvenSizes[evenSize] = { 
<a name="l00530"></a>00530         2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 
<a name="l00531"></a>00531         24, 26, 28, 30, 32, 36, 40, 42, 44, 48, 50, 52, 54, 56, 60, 64, 66, 70, 
<a name="l00532"></a>00532         72, 78, 80, 84, 88, 90, 96, 98, 100, 104, 108, 110, 112, 120, 126, 128, 
<a name="l00533"></a>00533         130, 132, 140, 144, 150, 154, 156, 160, 162, 168, 176, 180, 182, 192, 
<a name="l00534"></a>00534         196, 198, 200, 208, 210, 216, 220, 224, 234, 240, 250, 252, 256, 260, 
<a name="l00535"></a>00535         264, 270, 280, 288, 294, 300, 308, 312, 320, 324, 330, 336, 350, 352, 
<a name="l00536"></a>00536         360, 364, 378, 384, 390, 392, 396, 400, 416, 420, 432, 440, 448, 450, 
<a name="l00537"></a>00537         462, 468, 480, 486, 490, 500, 504, 512, 520, 528, 540, 546, 550, 560, 
<a name="l00538"></a>00538         576, 588, 594, 600, 616, 624, 630, 640, 648, 650, 660, 672, 686, 700, 
<a name="l00539"></a>00539         702, 704, 720, 728, 750, 756, 768, 770, 780, 784, 792, 800, 810, 832, 
<a name="l00540"></a>00540         840, 864, 880, 882, 896, 900, 910, 924, 936, 960, 972, 980, 990, 1000, 
<a name="l00541"></a>00541         1008, 1024, 1040, 1050, 1056, 1078, 1080, 1092, 1100, 1120, 1134, 1152, 
<a name="l00542"></a>00542         1170, 1176, 1188, 1200, 1232, 1248, 1250, 1260, 1274, 1280, 1296, 1300, 
<a name="l00543"></a>00543         1320, 1344, 1350, 1372, 1386, 1400, 1404, 1408, 1440, 1456, 1458, 1470, 
<a name="l00544"></a>00544         1500, 1512, 1536, 1540, 1560, 1568, 1584, 1600, 1620, 1638, 1650, 1664, 
<a name="l00545"></a>00545         1680, 1728, 1750, 1760, 1764, 1782, 1792, 1800, 1820, 1848, 1872, 1890, 
<a name="l00546"></a>00546         1920, 1944, 1950, 1960, 1980, 2000, 2016, 2048, 2058, 2080, 2100, 2106, 
<a name="l00547"></a>00547         2112, 2156, 2160, 2184, 2200, 2240, 2250, 2268, 2304, 2310, 2340, 2352, 
<a name="l00548"></a>00548         2376, 2400, 2430, 2450, 2464, 2496, 2500, 2520, 2548, 2560, 2592, 2600, 
<a name="l00549"></a>00549         2640, 2646, 2688, 2700, 2730, 2744, 2750, 2772, 2800, 2808, 2816, 2880, 
<a name="l00550"></a>00550         2912, 2916, 2940, 2970, 3000, 3024, 3072, 3080, 3120, 3136, 3150, 3168, 
<a name="l00551"></a>00551         3200, 3234, 3240, 3250, 3276, 3300, 3328, 3360, 3402, 3430, 3456, 3500, 
<a name="l00552"></a>00552         3510, 3520, 3528, 3564, 3584, 3600, 3640, 3696, 3744, 3750, 3780, 3822, 
<a name="l00553"></a>00553         3840, 3850, 3888, 3900, 3920, 3960, 4000, 4032, 4050, 4096, 4116, 4158, 
<a name="l00554"></a>00554         4160, 4200, 4212, 4224, 4312, 4320, 4368, 4374, 4400, 4410, 4480, 4500, 
<a name="l00555"></a>00555         4536, 4550, 4608, 4620, 4680, 4704, 4752, 4800, 4802, 4860, 4900, 4914, 
<a name="l00556"></a>00556         4928, 4950, 4992, 5000, 5040, 5096, 5120, 5184, 5200, 5250, 5280, 5292, 
<a name="l00557"></a>00557         5346, 5376, 5390, 5400, 5460, 5488, 5500, 5544, 5600, 5616, 5632, 5670, 
<a name="l00558"></a>00558         5760, 5824, 5832, 5850, 5880, 5940, 6000, 6048, 6144, 6160, 6174, 6240, 
<a name="l00559"></a>00559         6250, 6272, 6300, 6318, 6336, 6370, 6400, 6468, 6480, 6500, 6552, 6600, 
<a name="l00560"></a>00560         6656, 6720, 6750, 6804, 6860, 6912, 6930, 7000, 7020, 7040, 7056, 7128, 
<a name="l00561"></a>00561         7168, 7200, 7280, 7290, 7350, 7392, 7488, 7500, 7546, 7560, 7644, 7680, 
<a name="l00562"></a>00562         7700, 7776, 7800, 7840, 7920, 7938, 8000, 8064, 8100, 8190, 8192, 8232, 
<a name="l00563"></a>00563         8250, 8316, 8320, 8400, 8424, 8448, 8624, 8640, 8736, 8748, 8750, 8800, 
<a name="l00564"></a>00564         8820, 8910, 8918, 8960, 9000, 9072, 9100, 9216, 9240, 9360, 9408, 9450, 
<a name="l00565"></a>00565         9504, 9600, 9604, 9702, 9720, 9750, 9800, 9828, 9856, 9900, 9984, 10000, 
<a name="l00566"></a>00566         10080, 10192, 10206, 10240, 10290, 10368, 10400, 10500, 10530, 10560, 
<a name="l00567"></a>00567         10584, 10692, 10752, 10780, 10800, 10920, 10976, 11000, 11088, 11200, 
<a name="l00568"></a>00568         11232, 11250, 11264, 11340, 11466, 11520, 11550, 11648, 11664, 11700, 
<a name="l00569"></a>00569         11760, 11880, 12000, 12096, 12150, 12250, 12288, 12320, 12348, 12474, 
<a name="l00570"></a>00570         12480, 12500, 12544, 12600, 12636, 12672, 12740, 12800, 12936, 12960, 
<a name="l00571"></a>00571         13000, 13104, 13122, 13200, 13230, 13312, 13440, 13500, 13608, 13650, 
<a name="l00572"></a>00572         13720, 13750, 13824, 13860, 14000, 14040, 14080, 14112, 14256, 14336, 
<a name="l00573"></a>00573         14400, 14406, 14560, 14580, 14700, 14742, 14784, 14850, 14976, 15000, 
<a name="l00574"></a>00574         15092, 15120, 15288, 15360, 15400, 15552, 15600, 15680, 15750, 15840, 
<a name="l00575"></a>00575         15876, 16000, 16038, 16128, 16170, 16200, 16250, 16380, 16384, 16464, 
<a name="l00576"></a>00576         16500, 16632, 16640, 16800, 16848, 16896, 17010, 17150, 17248, 17280, 
<a name="l00577"></a>00577         17472, 17496, 17500, 17550, 17600, 17640, 17820, 17836, 17920, 18000, 
<a name="l00578"></a>00578         18144, 18200, 18432, 18480, 18522, 18720, 18750, 18816, 18900, 18954, 
<a name="l00579"></a>00579         19008, 19110, 19200, 19208, 19250, 19404, 19440, 19500, 19600, 19656, 
<a name="l00580"></a>00580         19712, 19800, 19968, 20000, 20160, 20250, 20384, 20412, 20480, 20580, 
<a name="l00581"></a>00581         20736, 20790, 20800, 21000, 21060, 21120, 21168, 21384, 21504, 21560, 
<a name="l00582"></a>00582         21600, 21840, 21870, 21952, 22000, 22050, 22176, 22400, 22464, 22500, 
<a name="l00583"></a>00583         22528, 22638, 22680, 22750, 22932, 23040, 23100, 23296, 23328, 23400, 
<a name="l00584"></a>00584         23520, 23760, 23814, 24000, 24010, 24192, 24300, 24500, 24570, 24576, 
<a name="l00585"></a>00585         24640, 24696, 24750, 24948, 24960, 25000, 25088, 25200, 25272, 25344, 
<a name="l00586"></a>00586         25480, 25600, 25872, 25920, 26000, 26208, 26244, 26250, 26400, 26460, 
<a name="l00587"></a>00587         26624, 26730, 26754, 26880, 26950, 27000, 27216, 27300, 27440, 27500, 
<a name="l00588"></a>00588         27648, 27720, 28000, 28080, 28160, 28224, 28350, 28512, 28672, 28800, 
<a name="l00589"></a>00589         28812, 29106, 29120, 29160, 29250, 29400, 29484, 29568, 29700, 29952, 
<a name="l00590"></a>00590         30000, 30184, 30240, 30576, 30618, 30720, 30800, 30870, 31104, 31200, 
<a name="l00591"></a>00591         31250, 31360, 31500, 31590, 31680, 31752, 31850, 32000, 32076, 32256, 
<a name="l00592"></a>00592         32340, 32400, 32500, 32760, 32768, 32928, 33000, 33264, 33280, 33600, 
<a name="l00593"></a>00593         33614, 33696, 33750, 33792, 34020, 34300, 34398, 34496, 34560, 34650, 
<a name="l00594"></a>00594         34944, 34992, 35000, 35100, 35200, 35280, 35640, 35672, 35840, 36000, 
<a name="l00595"></a>00595         36288, 36400, 36450, 36750, 36864, 36960, 37044, 37422, 37440, 37500, 
<a name="l00596"></a>00596         37632, 37730, 37800, 37908, 38016, 38220, 38400, 38416, 38500, 38808, 
<a name="l00597"></a>00597         38880, 39000, 39200, 39312, 39366, 39424, 39600, 39690, 39936, 40000, 
<a name="l00598"></a>00598         40320, 40500, 40768, 40824, 40950, 40960, 41160, 41250, 41472, 41580, 
<a name="l00599"></a>00599         41600, 42000, 42120, 42240, 42336, 42768, 43008, 43120, 43200, 43218, 
<a name="l00600"></a>00600         43680, 43740, 43750, 43904, 44000, 44100, 44226, 44352, 44550, 44590, 
<a name="l00601"></a>00601         44800, 44928, 45000, 45056, 45276, 45360, 45500, 45864, 46080, 46200, 
<a name="l00602"></a>00602         46592, 46656, 46800, 47040, 47250, 47520, 47628, 48000, 48020, 48114, 
<a name="l00603"></a>00603         48384, 48510, 48600, 48750, 49000, 49140, 49152, 49280, 49392, 49500, 
<a name="l00604"></a>00604         49896, 49920, 50000, 50176, 50400, 50544, 50688, 50960, 51030, 51200, 
<a name="l00605"></a>00605         51450, 51744, 51840, 52000, 52416, 52488, 52500, 52650, 52800, 52822, 
<a name="l00606"></a>00606         52920, 53248, 53460, 53508, 53760, 53900, 54000, 54432, 54600, 54880, 
<a name="l00607"></a>00607         55000, 55296, 55440, 55566, 56000, 56160, 56250, 56320, 56448, 56700, 
<a name="l00608"></a>00608         56862, 57024, 57330, 57344, 57600, 57624, 57750, 58212, 58240, 58320, 
<a name="l00609"></a>00609         58500, 58800, 58968, 59136, 59400, 59904, 60000, 60368, 60480, 60750, 
<a name="l00610"></a>00610         61152, 61236, 61250, 61440, 61600, 61740, 62208, 62370, 62400, 62426, 
<a name="l00611"></a>00611         62500, 62720, 63000, 63180, 63360, 63504, 63700, 64000, 64152, 64512, 
<a name="l00612"></a>00612         64680, 64800, 65000, 65520, 65536, 65610, 65856, 66000, 66150, 66528, 
<a name="l00613"></a>00613         66560, 67200, 67228, 67392, 67500, 67584, 67914, 68040, 68250, 68600, 
<a name="l00614"></a>00614         68750, 68796, 68992, 69120, 69300, 69888, 69984, 70000, 70200, 70400, 
<a name="l00615"></a>00615         70560, 71280, 71344, 71442, 71680, 72000, 72030, 72576, 72800, 72900, 
<a name="l00616"></a>00616         73500, 73710, 73728, 73920, 74088, 74250, 74844, 74880, 75000, 75264, 
<a name="l00617"></a>00617         75460, 75600, 75816, 76032, 76440, 76800, 76832, 77000, 77616, 77760, 
<a name="l00618"></a>00618         78000, 78400, 78624, 78732, 78750, 78848, 79200, 79380, 79872, 80000, 
<a name="l00619"></a>00619         80190, 80262, 80640, 80850, 81000, 81250, 81536, 81648, 81900, 81920, 
<a name="l00620"></a>00620         82320, 82500, 82944, 83160, 83200, 84000, 84240, 84480, 84672, 85050, 
<a name="l00621"></a>00621         85536, 85750, 86016, 86240, 86400, 86436, 87318, 87360, 87480, 87500, 
<a name="l00622"></a>00622         87750, 87808, 88000, 88200, 88452, 88704, 89100, 89180, 89600, 89856, 
<a name="l00623"></a>00623         90000, 90112, 90552, 90720, 91000, 91728, 91854, 92160, 92400, 92610, 
<a name="l00624"></a>00624         93184, 93312, 93600, 93750, 94080, 94500, 94770, 95040, 95256, 95550, 
<a name="l00625"></a>00625         96000, 96040, 96228, 96250, 96768, 97020, 97200, 97500, 98000, 98280, 
<a name="l00626"></a>00626         98304, 98560, 98784, 99000, 99792, 99840 
<a name="l00627"></a>00627 }; 
<a name="l00628"></a>00628 
<a name="l00629"></a>00629 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> M&gt;
<a name="l00630"></a>00630 <span class="keyword">struct </span>FFTEmbedKernel
<a name="l00631"></a>00631 {
<a name="l00632"></a>00632     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real, <span class="keyword">class</span> C, <span class="keyword">class</span> Shape&gt;
<a name="l00633"></a>00633     <span class="keyword">static</span> <span class="keywordtype">void</span> 
<a name="l00634"></a>00634     exec(MultiArrayView&lt;N, Real, C&gt; &amp; out, Shape <span class="keyword">const</span> &amp; kernelShape, 
<a name="l00635"></a>00635          Shape &amp; srcPoint, Shape &amp; destPoint, <span class="keywordtype">bool</span> copyIt)
<a name="l00636"></a>00636     {
<a name="l00637"></a>00637         <span class="keywordflow">for</span>(srcPoint[M]=0; srcPoint[M]&lt;kernelShape[M]; ++srcPoint[M])
<a name="l00638"></a>00638         {
<a name="l00639"></a>00639             <span class="keywordflow">if</span>(srcPoint[M] &lt; (kernelShape[M] + 1) / 2)
<a name="l00640"></a>00640             {
<a name="l00641"></a>00641                 destPoint[M] = srcPoint[M];
<a name="l00642"></a>00642             }
<a name="l00643"></a>00643             <span class="keywordflow">else</span>
<a name="l00644"></a>00644             {
<a name="l00645"></a>00645                 destPoint[M] = srcPoint[M] + out.shape(M) - kernelShape[M];
<a name="l00646"></a>00646                 copyIt = <span class="keyword">true</span>;
<a name="l00647"></a>00647             }
<a name="l00648"></a>00648             FFTEmbedKernel&lt;M-1&gt;::exec(out, kernelShape, srcPoint, destPoint, copyIt);
<a name="l00649"></a>00649         }
<a name="l00650"></a>00650     }
<a name="l00651"></a>00651 };
<a name="l00652"></a>00652 
<a name="l00653"></a>00653 <span class="keyword">template</span> &lt;&gt;
<a name="l00654"></a>00654 <span class="keyword">struct </span>FFTEmbedKernel&lt;0&gt;
<a name="l00655"></a>00655 {
<a name="l00656"></a>00656     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real, <span class="keyword">class</span> C, <span class="keyword">class</span> Shape&gt;
<a name="l00657"></a>00657     <span class="keyword">static</span> <span class="keywordtype">void</span> 
<a name="l00658"></a>00658     exec(MultiArrayView&lt;N, Real, C&gt; &amp; out, Shape <span class="keyword">const</span> &amp; kernelShape, 
<a name="l00659"></a>00659          Shape &amp; srcPoint, Shape &amp; destPoint, <span class="keywordtype">bool</span> copyIt)
<a name="l00660"></a>00660     {
<a name="l00661"></a>00661         <span class="keywordflow">for</span>(srcPoint[0]=0; srcPoint[0]&lt;kernelShape[0]; ++srcPoint[0])
<a name="l00662"></a>00662         {
<a name="l00663"></a>00663             <span class="keywordflow">if</span>(srcPoint[0] &lt; (kernelShape[0] + 1) / 2)
<a name="l00664"></a>00664             {
<a name="l00665"></a>00665                 destPoint[0] = srcPoint[0];
<a name="l00666"></a>00666             }
<a name="l00667"></a>00667             <span class="keywordflow">else</span>
<a name="l00668"></a>00668             {
<a name="l00669"></a>00669                 destPoint[0] = srcPoint[0] + out.shape(0) - kernelShape[0];
<a name="l00670"></a>00670                 copyIt = <span class="keyword">true</span>;
<a name="l00671"></a>00671             }
<a name="l00672"></a>00672             <span class="keywordflow">if</span>(copyIt)
<a name="l00673"></a>00673             {
<a name="l00674"></a>00674                 out[destPoint] = out[srcPoint];
<a name="l00675"></a>00675                 out[srcPoint] = 0.0;
<a name="l00676"></a>00676             }
<a name="l00677"></a>00677         }
<a name="l00678"></a>00678     }
<a name="l00679"></a>00679 };
<a name="l00680"></a>00680 
<a name="l00681"></a>00681 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2&gt;
<a name="l00682"></a>00682 <span class="keywordtype">void</span> 
<a name="l00683"></a>00683 fftEmbedKernel(MultiArrayView&lt;N, Real, C1&gt; kernel,
<a name="l00684"></a>00684                MultiArrayView&lt;N, Real, C2&gt; out,
<a name="l00685"></a>00685                Real <a class="code" href="group__FFTWComplexOperators.html#ga396baa79e8bd78a178597d32d5152041" title="norm (= magnitude)">norm</a> = 1.0)
<a name="l00686"></a>00686 {
<a name="l00687"></a>00687     <span class="keyword">typedef</span> <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type Shape;
<a name="l00688"></a>00688 
<a name="l00689"></a>00689     MultiArrayView&lt;N, Real, C2&gt; kout = out.subarray(Shape(), kernel.shape());
<a name="l00690"></a>00690     
<a name="l00691"></a>00691     out.init(0.0);
<a name="l00692"></a>00692     kout = kernel;
<a name="l00693"></a>00693     <span class="keywordflow">if</span> (<a class="code" href="group__FFTWComplexOperators.html#ga396baa79e8bd78a178597d32d5152041" title="norm (= magnitude)">norm</a> != 1.0)
<a name="l00694"></a>00694         kout *= <a class="code" href="group__FFTWComplexOperators.html#ga396baa79e8bd78a178597d32d5152041" title="norm (= magnitude)">norm</a>;
<a name="l00695"></a>00695     <a class="code" href="group__FourierTransform.html#gaee27c376079af99e8e2148e7d23ffbbb" title="Rearrange the quadrants of a Fourier image so that the origin is in the image&#39;s upper left...">moveDCToUpperLeft</a>(kout);
<a name="l00696"></a>00696     
<a name="l00697"></a>00697     Shape srcPoint, destPoint;    
<a name="l00698"></a>00698     FFTEmbedKernel&lt;(int)N-1&gt;::exec(out, kernel.shape(), srcPoint, destPoint, <span class="keyword">false</span>);
<a name="l00699"></a>00699 }
<a name="l00700"></a>00700 
<a name="l00701"></a>00701 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2&gt;
<a name="l00702"></a>00702 <span class="keywordtype">void</span> 
<a name="l00703"></a>00703 fftEmbedArray(MultiArrayView&lt;N, Real, C1&gt; in,
<a name="l00704"></a>00704               MultiArrayView&lt;N, Real, C2&gt; out)
<a name="l00705"></a>00705 {
<a name="l00706"></a>00706     <span class="keyword">typedef</span> <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type Shape;
<a name="l00707"></a>00707     
<a name="l00708"></a>00708     Shape diff = out.shape() - in.shape(), 
<a name="l00709"></a>00709           leftDiff = <a class="code" href="group__FixedPoint16Operations.html#gac71b069a80f6decdb6fad1cfd508f5f8" title="division with enforced result type.">div</a>(diff, <a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a>(2)),
<a name="l00710"></a>00710           rightDiff = diff - leftDiff,
<a name="l00711"></a>00711           right = in.shape() + leftDiff; 
<a name="l00712"></a>00712     
<a name="l00713"></a>00713     out.subarray(leftDiff, right) = in;
<a name="l00714"></a>00714     
<a name="l00715"></a>00715     <span class="keyword">typedef</span> <span class="keyword">typename</span> MultiArrayView&lt;N, Real, C2&gt;::traverser Traverser;
<a name="l00716"></a>00716     <span class="keyword">typedef</span> MultiArrayNavigator&lt;Traverser, N&gt; Navigator;
<a name="l00717"></a>00717     <span class="keyword">typedef</span> <span class="keyword">typename</span> Navigator::iterator Iterator;
<a name="l00718"></a>00718     
<a name="l00719"></a>00719     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; N; ++d)
<a name="l00720"></a>00720     {
<a name="l00721"></a>00721         Navigator nav(out.traverser_begin(), out.shape(), d);
<a name="l00722"></a>00722 
<a name="l00723"></a>00723         <span class="keywordflow">for</span>( ; nav.hasMore(); nav++ )
<a name="l00724"></a>00724         {
<a name="l00725"></a>00725             Iterator i = nav.begin();
<a name="l00726"></a>00726             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=1; k&lt;=leftDiff[d]; ++k)
<a name="l00727"></a>00727                 i[leftDiff[d] - k] = i[leftDiff[d] + k];
<a name="l00728"></a>00728             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;rightDiff[d]; ++k)
<a name="l00729"></a>00729                 i[right[d] + k] = i[right[d] - k - 2];
<a name="l00730"></a>00730         }
<a name="l00731"></a>00731     }
<a name="l00732"></a>00732 }
<a name="l00733"></a>00733 
<a name="l00734"></a>00734 } <span class="comment">// namespace detail</span>
<a name="l00735"></a>00735 
<a name="l00736"></a>00736 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">int</span> N&gt;
<a name="l00737"></a>00737 TinyVector&lt;T, N&gt;
<a name="l00738"></a>00738 fftwBestPaddedShape(TinyVector&lt;T, N&gt; shape)
<a name="l00739"></a>00739 {
<a name="l00740"></a>00740     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;N; ++k)
<a name="l00741"></a>00741         shape[k] = detail::FFTWPaddingSize&lt;0&gt;::find(shape[k]);
<a name="l00742"></a>00742     <span class="keywordflow">return</span> shape;
<a name="l00743"></a>00743 }
<a name="l00744"></a>00744 
<a name="l00745"></a>00745 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">int</span> N&gt;
<a name="l00746"></a>00746 TinyVector&lt;T, N&gt;
<a name="l00747"></a>00747 fftwBestPaddedShapeR2C(TinyVector&lt;T, N&gt; shape)
<a name="l00748"></a>00748 {
<a name="l00749"></a>00749     shape[0] = detail::FFTWPaddingSize&lt;0&gt;::findEven(shape[0]);
<a name="l00750"></a>00750     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=1; k&lt;N; ++k)
<a name="l00751"></a>00751         shape[k] = detail::FFTWPaddingSize&lt;0&gt;::find(shape[k]);
<a name="l00752"></a>00752     <span class="keywordflow">return</span> shape;
<a name="l00753"></a>00753 }
<a name="l00754"></a>00754 <span class="comment"></span>
<a name="l00755"></a>00755 <span class="comment">/** \brief Find frequency domain shape for a R2C Fourier transform.</span>
<a name="l00756"></a>00756 <span class="comment"></span>
<a name="l00757"></a>00757 <span class="comment">    When a real valued array is transformed to the frequency domain, about half of the </span>
<a name="l00758"></a>00758 <span class="comment">    Fourier coefficients are redundant. The transform can be optimized as a &lt;a href=&quot;http://www.fftw.org/doc/Multi_002dDimensional-DFTs-of-Real-Data.html&quot;&gt;R2C </span>
<a name="l00759"></a>00759 <span class="comment">    transform&lt;/a&gt; that doesn&#39;t compute and store the redundant coefficients. This function</span>
<a name="l00760"></a>00760 <span class="comment">    computes the appropriate frequency domain shape for a given shape in the spatial domain.</span>
<a name="l00761"></a>00761 <span class="comment">    It simply replaces &lt;tt&gt;shape[0]&lt;/tt&gt; with &lt;tt&gt;shape[0] / 2 + 1&lt;/tt&gt;.</span>
<a name="l00762"></a>00762 <span class="comment">    </span>
<a name="l00763"></a>00763 <span class="comment">    &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/multi_fft.hxx&gt;&lt;br/&gt;</span>
<a name="l00764"></a>00764 <span class="comment">    Namespace: vigra</span>
<a name="l00765"></a>00765 <span class="comment">*/</span>
<a name="l00766"></a>00766 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">int</span> N&gt;
<a name="l00767"></a>00767 TinyVector&lt;T, N&gt;
<a name="l00768"></a><a class="code" href="group__FourierTransform.html#gafbea828444f49163293b1d81fcd05da8">00768</a> <a class="code" href="group__FourierTransform.html#gafbea828444f49163293b1d81fcd05da8" title="Find frequency domain shape for a R2C Fourier transform.">fftwCorrespondingShapeR2C</a>(<a class="code" href="classvigra_1_1TinyVector.html" title="Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE...">TinyVector&lt;T, N&gt;</a> shape)
<a name="l00769"></a>00769 {
<a name="l00770"></a>00770     shape[0] = shape[0] / 2 + 1;
<a name="l00771"></a>00771     <span class="keywordflow">return</span> shape;
<a name="l00772"></a>00772 }
<a name="l00773"></a>00773 
<a name="l00774"></a>00774 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">int</span> N&gt;
<a name="l00775"></a>00775 TinyVector&lt;T, N&gt;
<a name="l00776"></a>00776 fftwCorrespondingShapeC2R(TinyVector&lt;T, N&gt; shape, <span class="keywordtype">bool</span> oddDimension0 = <span class="keyword">false</span>)
<a name="l00777"></a>00777 {
<a name="l00778"></a>00778     shape[0] = oddDimension0
<a name="l00779"></a>00779                   ? (shape[0] - 1) * 2 + 1
<a name="l00780"></a>00780                   : (shape[0] - 1) * 2;
<a name="l00781"></a>00781     <span class="keywordflow">return</span> shape;
<a name="l00782"></a>00782 }
<a name="l00783"></a>00783 
<a name="l00784"></a>00784 <span class="comment">/********************************************************/</span>
<a name="l00785"></a>00785 <span class="comment">/*                                                      */</span>
<a name="l00786"></a>00786 <span class="comment">/*                       FFTWPlan                       */</span>
<a name="l00787"></a>00787 <span class="comment">/*                                                      */</span>
<a name="l00788"></a>00788 <span class="comment">/********************************************************/</span>
<a name="l00789"></a>00789 <span class="comment"></span>
<a name="l00790"></a>00790 <span class="comment">/** C++ wrapper for FFTW plans.</span>
<a name="l00791"></a>00791 <span class="comment"></span>
<a name="l00792"></a>00792 <span class="comment">    The class encapsulates the calls to &lt;tt&gt;fftw_plan_dft_2d&lt;/tt&gt;, &lt;tt&gt;fftw_execute&lt;/tt&gt;, and</span>
<a name="l00793"></a>00793 <span class="comment">    &lt;tt&gt;fftw_destroy_plan&lt;/tt&gt; (and their &lt;tt&gt;float&lt;/tt&gt; and &lt;tt&gt;long double&lt;/tt&gt; counterparts)</span>
<a name="l00794"></a>00794 <span class="comment">    in an easy-to-use interface.</span>
<a name="l00795"></a>00795 <span class="comment"></span>
<a name="l00796"></a>00796 <span class="comment">    Usually, you use this class only indirectly via \ref fourierTransform() </span>
<a name="l00797"></a>00797 <span class="comment">    and \ref fourierTransformInverse(). You only need this class if you want to have more control</span>
<a name="l00798"></a>00798 <span class="comment">    about FFTW&#39;s planning process (by providing non-default planning flags) and/or want to re-use</span>
<a name="l00799"></a>00799 <span class="comment">    plans for several transformations.</span>
<a name="l00800"></a>00800 <span class="comment">    </span>
<a name="l00801"></a>00801 <span class="comment">    &lt;b&gt; Usage:&lt;/b&gt;</span>
<a name="l00802"></a>00802 <span class="comment"></span>
<a name="l00803"></a>00803 <span class="comment">    &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/multi_fft.hxx&gt;&lt;br&gt;</span>
<a name="l00804"></a>00804 <span class="comment">    Namespace: vigra</span>
<a name="l00805"></a>00805 <span class="comment"></span>
<a name="l00806"></a>00806 <span class="comment">    \code</span>
<a name="l00807"></a>00807 <span class="comment">    // compute complex Fourier transform of a real image</span>
<a name="l00808"></a>00808 <span class="comment">    MultiArray&lt;2, double&gt; src(Shape2(w, h));</span>
<a name="l00809"></a>00809 <span class="comment">    MultiArray&lt;2, FFTWComplex&lt;double&gt; &gt; fourier(Shape2(w, h));</span>
<a name="l00810"></a>00810 <span class="comment">    </span>
<a name="l00811"></a>00811 <span class="comment">    // create an optimized plan by measuring the speed of several algorithm variants</span>
<a name="l00812"></a>00812 <span class="comment">    FFTWPlan&lt;2, double&gt; plan(src, fourier, FFTW_MEASURE);</span>
<a name="l00813"></a>00813 <span class="comment">    </span>
<a name="l00814"></a>00814 <span class="comment">    plan.execute(src, fourier); </span>
<a name="l00815"></a>00815 <span class="comment">    \endcode</span>
<a name="l00816"></a>00816 <span class="comment">*/</span>
<a name="l00817"></a>00817 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real = <span class="keywordtype">double</span>&gt;
<a name="l00818"></a><a class="code" href="classvigra_1_1FFTWPlan.html">00818</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1FFTWPlan.html">FFTWPlan</a>
<a name="l00819"></a>00819 {
<a name="l00820"></a>00820     <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1ArrayVector.html">ArrayVector&lt;int&gt;</a> Shape;
<a name="l00821"></a>00821     <span class="keyword">typedef</span> <span class="keyword">typename</span> FFTWReal2Complex&lt;Real&gt;::plan_type PlanType;
<a name="l00822"></a>00822     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvigra_1_1FFTWComplex.html#a03263059650009980dd1a55eba9ac3e7">FFTWComplex&lt;Real&gt;::complex_type</a> Complex;
<a name="l00823"></a>00823     
<a name="l00824"></a>00824     PlanType plan;
<a name="l00825"></a>00825     Shape shape, instrides, outstrides;
<a name="l00826"></a>00826     <span class="keywordtype">int</span> sign;
<a name="l00827"></a>00827     
<a name="l00828"></a>00828   <span class="keyword">public</span>:<span class="comment"></span>
<a name="l00829"></a>00829 <span class="comment">        /** \brief Create an empty plan.</span>
<a name="l00830"></a>00830 <span class="comment">        </span>
<a name="l00831"></a>00831 <span class="comment">            The plan can be initialized later by one of the init() functions.</span>
<a name="l00832"></a>00832 <span class="comment">        */</span>
<a name="l00833"></a><a class="code" href="classvigra_1_1FFTWPlan.html#ae4d9a442304fdf6acf732f345fb09e22">00833</a>     <a class="code" href="classvigra_1_1FFTWPlan.html#ae4d9a442304fdf6acf732f345fb09e22" title="Create an empty plan.">FFTWPlan</a>()
<a name="l00834"></a>00834     : plan(0)
<a name="l00835"></a>00835     {}
<a name="l00836"></a>00836     <span class="comment"></span>
<a name="l00837"></a>00837 <span class="comment">        /** \brief Create a plan for a complex-to-complex transform.</span>
<a name="l00838"></a>00838 <span class="comment">        </span>
<a name="l00839"></a>00839 <span class="comment">            \arg SIGN must be &lt;tt&gt;FFTW_FORWARD&lt;/tt&gt; or &lt;tt&gt;FFTW_BACKWARD&lt;/tt&gt; according to the</span>
<a name="l00840"></a>00840 <span class="comment">            desired transformation direction.</span>
<a name="l00841"></a>00841 <span class="comment">            \arg planner_flags must be a combination of the &lt;a href=&quot;http://www.fftw.org/doc/Planner-Flags.html&quot;&gt;planner </span>
<a name="l00842"></a>00842 <span class="comment">            flags&lt;/a&gt; defined by the FFTW library. The default &lt;tt&gt;FFTW_ESTIMATE&lt;/tt&gt; will guess</span>
<a name="l00843"></a>00843 <span class="comment">            optimal algorithm settings or read them from pre-loaded &lt;a href=&quot;http://www.fftw.org/doc/Wisdom.html&quot;&gt;&quot;wisdom&quot;&lt;/a&gt;.</span>
<a name="l00844"></a>00844 <span class="comment">        */</span>
<a name="l00845"></a>00845     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> C2&gt;
<a name="l00846"></a><a class="code" href="classvigra_1_1FFTWPlan.html#a169cc3462162ceae01c4497026dfce59">00846</a>     <a class="code" href="classvigra_1_1FFTWPlan.html#ae4d9a442304fdf6acf732f345fb09e22" title="Create an empty plan.">FFTWPlan</a>(<a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>&lt;N, <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a>, C1&gt; in, 
<a name="l00847"></a>00847              <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>&lt;N, <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a>, C2&gt; out,
<a name="l00848"></a>00848              <span class="keywordtype">int</span> SIGN, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags = FFTW_ESTIMATE)
<a name="l00849"></a>00849     : plan(0)
<a name="l00850"></a>00850     {
<a name="l00851"></a>00851         <a class="code" href="classvigra_1_1FFTWPlan.html#aa9e4cc0ad553e551d915ef90fc5ed3f6" title="Init a complex-to-complex transform.">init</a>(in, out, SIGN, planner_flags);
<a name="l00852"></a>00852     }
<a name="l00853"></a>00853     <span class="comment"></span>
<a name="l00854"></a>00854 <span class="comment">        /** \brief Create a plan for a real-to-complex transform.</span>
<a name="l00855"></a>00855 <span class="comment">        </span>
<a name="l00856"></a>00856 <span class="comment">            This always refers to a forward transform. The shape of the output determines</span>
<a name="l00857"></a>00857 <span class="comment">            if a standard transform (when &lt;tt&gt;out.shape() == in.shape()&lt;/tt&gt;) or an </span>
<a name="l00858"></a>00858 <span class="comment">            &lt;a href=&quot;http://www.fftw.org/doc/Multi_002dDimensional-DFTs-of-Real-Data.html&quot;&gt;R2C </span>
<a name="l00859"></a>00859 <span class="comment">            transform&lt;/a&gt; (when &lt;tt&gt;out.shape() == fftwCorrespondingShapeR2C(in.shape())&lt;/tt&gt;) will be executed. </span>
<a name="l00860"></a>00860 <span class="comment">            </span>
<a name="l00861"></a>00861 <span class="comment">            \arg planner_flags must be a combination of the &lt;a href=&quot;http://www.fftw.org/doc/Planner-Flags.html&quot;&gt;planner </span>
<a name="l00862"></a>00862 <span class="comment">            flags&lt;/a&gt; defined by the FFTW library. The default &lt;tt&gt;FFTW_ESTIMATE&lt;/tt&gt; will guess</span>
<a name="l00863"></a>00863 <span class="comment">            optimal algorithm settings or read them from pre-loaded &lt;a href=&quot;http://www.fftw.org/doc/Wisdom.html&quot;&gt;&quot;wisdom&quot;&lt;/a&gt;.</span>
<a name="l00864"></a>00864 <span class="comment">        */</span>
<a name="l00865"></a>00865     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> C2&gt;
<a name="l00866"></a><a class="code" href="classvigra_1_1FFTWPlan.html#adcde64f1a0148f4625468ad470c785ac">00866</a>     <a class="code" href="classvigra_1_1FFTWPlan.html#ae4d9a442304fdf6acf732f345fb09e22" title="Create an empty plan.">FFTWPlan</a>(<a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView&lt;N, Real, C1&gt;</a> in, 
<a name="l00867"></a>00867              <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>&lt;N, <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a>, C2&gt; out,
<a name="l00868"></a>00868              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags = FFTW_ESTIMATE)
<a name="l00869"></a>00869     : plan(0)
<a name="l00870"></a>00870     {
<a name="l00871"></a>00871         <a class="code" href="classvigra_1_1FFTWPlan.html#aa9e4cc0ad553e551d915ef90fc5ed3f6" title="Init a complex-to-complex transform.">init</a>(in, out, planner_flags);
<a name="l00872"></a>00872     }
<a name="l00873"></a>00873 <span class="comment"></span>
<a name="l00874"></a>00874 <span class="comment">        /** \brief Create a plan for a complex-to-real transform.</span>
<a name="l00875"></a>00875 <span class="comment">        </span>
<a name="l00876"></a>00876 <span class="comment">            This always refers to a inverse transform. The shape of the input determines</span>
<a name="l00877"></a>00877 <span class="comment">            if a standard transform (when &lt;tt&gt;in.shape() == out.shape()&lt;/tt&gt;) or a </span>
<a name="l00878"></a>00878 <span class="comment">            &lt;a href=&quot;http://www.fftw.org/doc/Multi_002dDimensional-DFTs-of-Real-Data.html&quot;&gt;C2R </span>
<a name="l00879"></a>00879 <span class="comment">            transform&lt;/a&gt; (when &lt;tt&gt;in.shape() == fftwCorrespondingShapeR2C(out.shape())&lt;/tt&gt;) will be executed. </span>
<a name="l00880"></a>00880 <span class="comment">            </span>
<a name="l00881"></a>00881 <span class="comment">            \arg planner_flags must be a combination of the &lt;a href=&quot;http://www.fftw.org/doc/Planner-Flags.html&quot;&gt;planner </span>
<a name="l00882"></a>00882 <span class="comment">            flags&lt;/a&gt; defined by the FFTW library. The default &lt;tt&gt;FFTW_ESTIMATE&lt;/tt&gt; will guess</span>
<a name="l00883"></a>00883 <span class="comment">            optimal algorithm settings or read them from pre-loaded &lt;a href=&quot;http://www.fftw.org/doc/Wisdom.html&quot;&gt;&quot;wisdom&quot;&lt;/a&gt;.</span>
<a name="l00884"></a>00884 <span class="comment">        */</span>
<a name="l00885"></a>00885     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> C2&gt;
<a name="l00886"></a><a class="code" href="classvigra_1_1FFTWPlan.html#a5743bcaa3c6285361d43368f4eba8d68">00886</a>     <a class="code" href="classvigra_1_1FFTWPlan.html#ae4d9a442304fdf6acf732f345fb09e22" title="Create an empty plan.">FFTWPlan</a>(<a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>&lt;N, <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a>, C1&gt; in, 
<a name="l00887"></a>00887              <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView&lt;N, Real, C2&gt;</a> out,
<a name="l00888"></a>00888              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags = FFTW_ESTIMATE)
<a name="l00889"></a>00889     : plan(0)
<a name="l00890"></a>00890     {
<a name="l00891"></a>00891         <a class="code" href="classvigra_1_1FFTWPlan.html#aa9e4cc0ad553e551d915ef90fc5ed3f6" title="Init a complex-to-complex transform.">init</a>(in, out, planner_flags);
<a name="l00892"></a>00892     }
<a name="l00893"></a>00893     <span class="comment"></span>
<a name="l00894"></a>00894 <span class="comment">        /** \brief Copy constructor.</span>
<a name="l00895"></a>00895 <span class="comment">        */</span>
<a name="l00896"></a><a class="code" href="classvigra_1_1FFTWPlan.html#a0a99a0851c9bc7fbd16a17a843835143">00896</a>     <a class="code" href="classvigra_1_1FFTWPlan.html#ae4d9a442304fdf6acf732f345fb09e22" title="Create an empty plan.">FFTWPlan</a>(<a class="code" href="classvigra_1_1FFTWPlan.html">FFTWPlan</a> <span class="keyword">const</span> &amp; other)
<a name="l00897"></a>00897     : plan(other.plan),
<a name="l00898"></a>00898       sign(other.sign)
<a name="l00899"></a>00899     {
<a name="l00900"></a>00900         <a class="code" href="classvigra_1_1FFTWPlan.html">FFTWPlan</a> &amp; o = <span class="keyword">const_cast&lt;</span><a class="code" href="classvigra_1_1FFTWPlan.html">FFTWPlan</a> &amp;<span class="keyword">&gt;</span>(other);
<a name="l00901"></a>00901         shape.swap(o.shape);
<a name="l00902"></a>00902         instrides.swap(o.instrides);
<a name="l00903"></a>00903         outstrides.swap(o.outstrides);
<a name="l00904"></a>00904         o.plan = 0; <span class="comment">// act like std::auto_ptr</span>
<a name="l00905"></a>00905     }
<a name="l00906"></a>00906     <span class="comment"></span>
<a name="l00907"></a>00907 <span class="comment">        /** \brief Copy assigment.</span>
<a name="l00908"></a>00908 <span class="comment">        */</span>
<a name="l00909"></a><a class="code" href="classvigra_1_1FFTWPlan.html#a49a933f109d7a4c027cd9f2d350e3630">00909</a>     <a class="code" href="classvigra_1_1FFTWPlan.html">FFTWPlan</a> &amp; <a class="code" href="classvigra_1_1FFTWPlan.html#a49a933f109d7a4c027cd9f2d350e3630" title="Copy assigment.">operator=</a>(<a class="code" href="classvigra_1_1FFTWPlan.html">FFTWPlan</a> <span class="keyword">const</span> &amp; other)
<a name="l00910"></a>00910     {
<a name="l00911"></a>00911         <span class="keywordflow">if</span>(<span class="keyword">this</span> != &amp;other)
<a name="l00912"></a>00912         {
<a name="l00913"></a>00913             <a class="code" href="classvigra_1_1FFTWPlan.html">FFTWPlan</a> &amp; o = <span class="keyword">const_cast&lt;</span><a class="code" href="classvigra_1_1FFTWPlan.html">FFTWPlan</a> &amp;<span class="keyword">&gt;</span>(other);
<a name="l00914"></a>00914             plan = o.plan;
<a name="l00915"></a>00915             shape.swap(o.shape);
<a name="l00916"></a>00916             instrides.swap(o.instrides);
<a name="l00917"></a>00917             outstrides.swap(o.outstrides);
<a name="l00918"></a>00918             sign = o.sign;
<a name="l00919"></a>00919             o.plan = 0; <span class="comment">// act like std::auto_ptr</span>
<a name="l00920"></a>00920         }
<a name="l00921"></a>00921         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00922"></a>00922     }
<a name="l00923"></a>00923 <span class="comment"></span>
<a name="l00924"></a>00924 <span class="comment">        /** \brief Destructor.</span>
<a name="l00925"></a>00925 <span class="comment">        */</span>
<a name="l00926"></a><a class="code" href="classvigra_1_1FFTWPlan.html#a2027c60e66cf80c4e6051d2a20492865">00926</a>     <a class="code" href="classvigra_1_1FFTWPlan.html#a2027c60e66cf80c4e6051d2a20492865" title="Destructor.">~FFTWPlan</a>()
<a name="l00927"></a>00927     {
<a name="l00928"></a>00928         detail::fftwPlanDestroy(plan);
<a name="l00929"></a>00929     }
<a name="l00930"></a>00930 <span class="comment"></span>
<a name="l00931"></a>00931 <span class="comment">        /** \brief Init a complex-to-complex transform.</span>
<a name="l00932"></a>00932 <span class="comment">        </span>
<a name="l00933"></a>00933 <span class="comment">            See the constructor with the same signature for details.</span>
<a name="l00934"></a>00934 <span class="comment">        */</span>
<a name="l00935"></a>00935     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> C2&gt;
<a name="l00936"></a><a class="code" href="classvigra_1_1FFTWPlan.html#aa9e4cc0ad553e551d915ef90fc5ed3f6">00936</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1FFTWPlan.html#aa9e4cc0ad553e551d915ef90fc5ed3f6" title="Init a complex-to-complex transform.">init</a>(<a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>&lt;N, <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a>, C1&gt; in, 
<a name="l00937"></a>00937               <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>&lt;N, <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a>, C2&gt; out,
<a name="l00938"></a>00938               <span class="keywordtype">int</span> SIGN, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags = FFTW_ESTIMATE)
<a name="l00939"></a>00939     {
<a name="l00940"></a>00940         vigra_precondition(in.strideOrdering() == out.strideOrdering(),
<a name="l00941"></a>00941             <span class="stringliteral">&quot;FFTWPlan.init(): input and output must have the same stride ordering.&quot;</span>);
<a name="l00942"></a>00942             
<a name="l00943"></a>00943         initImpl(in.permuteStridesDescending(), out.permuteStridesDescending(), 
<a name="l00944"></a>00944                  SIGN, planner_flags);
<a name="l00945"></a>00945     }
<a name="l00946"></a>00946         <span class="comment"></span>
<a name="l00947"></a>00947 <span class="comment">        /** \brief Init a real-to-complex transform.</span>
<a name="l00948"></a>00948 <span class="comment">        </span>
<a name="l00949"></a>00949 <span class="comment">            See the constructor with the same signature for details.</span>
<a name="l00950"></a>00950 <span class="comment">        */</span>
<a name="l00951"></a>00951     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> C2&gt;
<a name="l00952"></a><a class="code" href="classvigra_1_1FFTWPlan.html#a92782368c20db1cd1a72b389d9e39a76">00952</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1FFTWPlan.html#aa9e4cc0ad553e551d915ef90fc5ed3f6" title="Init a complex-to-complex transform.">init</a>(<a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView&lt;N, Real, C1&gt;</a> in, 
<a name="l00953"></a>00953               <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>&lt;N, <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a>, C2&gt; out,
<a name="l00954"></a>00954               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags = FFTW_ESTIMATE)
<a name="l00955"></a>00955     {
<a name="l00956"></a>00956         vigra_precondition(in.<a class="code" href="classvigra_1_1MultiArrayView.html#a614a382ab304114f19a2c1168502647d">strideOrdering</a>() == out.strideOrdering(),
<a name="l00957"></a>00957             <span class="stringliteral">&quot;FFTWPlan.init(): input and output must have the same stride ordering.&quot;</span>);
<a name="l00958"></a>00958 
<a name="l00959"></a>00959         initImpl(in.<a class="code" href="classvigra_1_1MultiArrayView.html#a421ac71c17f86f900041784e3c77857a">permuteStridesDescending</a>(), out.permuteStridesDescending(), 
<a name="l00960"></a>00960                  FFTW_FORWARD, planner_flags);
<a name="l00961"></a>00961     }
<a name="l00962"></a>00962         <span class="comment"></span>
<a name="l00963"></a>00963 <span class="comment">        /** \brief Init a complex-to-real transform.</span>
<a name="l00964"></a>00964 <span class="comment">        </span>
<a name="l00965"></a>00965 <span class="comment">            See the constructor with the same signature for details.</span>
<a name="l00966"></a>00966 <span class="comment">        */</span>
<a name="l00967"></a>00967     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> C2&gt;
<a name="l00968"></a><a class="code" href="classvigra_1_1FFTWPlan.html#a2f9ed902747a03caf77a131b7691f523">00968</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1FFTWPlan.html#aa9e4cc0ad553e551d915ef90fc5ed3f6" title="Init a complex-to-complex transform.">init</a>(<a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>&lt;N, <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a>, C1&gt; in, 
<a name="l00969"></a>00969               <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView&lt;N, Real, C2&gt;</a> out,
<a name="l00970"></a>00970               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags = FFTW_ESTIMATE)
<a name="l00971"></a>00971     {
<a name="l00972"></a>00972         vigra_precondition(in.strideOrdering() == out.<a class="code" href="classvigra_1_1MultiArrayView.html#a614a382ab304114f19a2c1168502647d">strideOrdering</a>(),
<a name="l00973"></a>00973             <span class="stringliteral">&quot;FFTWPlan.init(): input and output must have the same stride ordering.&quot;</span>);
<a name="l00974"></a>00974 
<a name="l00975"></a>00975         initImpl(in.permuteStridesDescending(), out.<a class="code" href="classvigra_1_1MultiArrayView.html#a421ac71c17f86f900041784e3c77857a">permuteStridesDescending</a>(), 
<a name="l00976"></a>00976                  FFTW_BACKWARD, planner_flags);
<a name="l00977"></a>00977     }
<a name="l00978"></a>00978     <span class="comment"></span>
<a name="l00979"></a>00979 <span class="comment">        /** \brief Execute a complex-to-complex transform.</span>
<a name="l00980"></a>00980 <span class="comment">        </span>
<a name="l00981"></a>00981 <span class="comment">            The array shapes must be the same as in the corresponding init function</span>
<a name="l00982"></a>00982 <span class="comment">            or constructor. However, execute() can be called several times on</span>
<a name="l00983"></a>00983 <span class="comment">            the same plan, even with different arrays, as long as they have the appropriate </span>
<a name="l00984"></a>00984 <span class="comment">            shapes.</span>
<a name="l00985"></a>00985 <span class="comment">        */</span>
<a name="l00986"></a>00986     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> C2&gt;
<a name="l00987"></a><a class="code" href="classvigra_1_1FFTWPlan.html#ac2451d98863694afea345ea9a5e7c5d4">00987</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1FFTWPlan.html#ac2451d98863694afea345ea9a5e7c5d4" title="Execute a complex-to-complex transform.">execute</a>(<a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>&lt;N, <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a>, C1&gt; in, 
<a name="l00988"></a>00988                  <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>&lt;N, <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a>, C2&gt; out)<span class="keyword"> const</span>
<a name="l00989"></a>00989 <span class="keyword">    </span>{
<a name="l00990"></a>00990         executeImpl(in.permuteStridesDescending(), out.permuteStridesDescending());
<a name="l00991"></a>00991     }
<a name="l00992"></a>00992     <span class="comment"></span>
<a name="l00993"></a>00993 <span class="comment">        /** \brief Execute a real-to-complex transform.</span>
<a name="l00994"></a>00994 <span class="comment">        </span>
<a name="l00995"></a>00995 <span class="comment">            The array shapes must be the same as in the corresponding init function</span>
<a name="l00996"></a>00996 <span class="comment">            or constructor. However, execute() can be called several times on</span>
<a name="l00997"></a>00997 <span class="comment">            the same plan, even with different arrays, as long as they have the appropriate </span>
<a name="l00998"></a>00998 <span class="comment">            shapes.</span>
<a name="l00999"></a>00999 <span class="comment">        */</span>
<a name="l01000"></a>01000     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> C2&gt;
<a name="l01001"></a><a class="code" href="classvigra_1_1FFTWPlan.html#ab40d51a194c564ec0a620cf89a2f5ae7">01001</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1FFTWPlan.html#ac2451d98863694afea345ea9a5e7c5d4" title="Execute a complex-to-complex transform.">execute</a>(<a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView&lt;N, Real, C1&gt;</a> in, 
<a name="l01002"></a>01002                  <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>&lt;N, <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a>, C2&gt; out)<span class="keyword"> const</span>
<a name="l01003"></a>01003 <span class="keyword">    </span>{
<a name="l01004"></a>01004         executeImpl(in.<a class="code" href="classvigra_1_1MultiArrayView.html#a421ac71c17f86f900041784e3c77857a">permuteStridesDescending</a>(), out.permuteStridesDescending());
<a name="l01005"></a>01005     }
<a name="l01006"></a>01006     <span class="comment"></span>
<a name="l01007"></a>01007 <span class="comment">        /** \brief Execute a complex-to-real transform.</span>
<a name="l01008"></a>01008 <span class="comment">        </span>
<a name="l01009"></a>01009 <span class="comment">            The array shapes must be the same as in the corresponding init function</span>
<a name="l01010"></a>01010 <span class="comment">            or constructor. However, execute() can be called several times on</span>
<a name="l01011"></a>01011 <span class="comment">            the same plan, even with different arrays, as long as they have the appropriate </span>
<a name="l01012"></a>01012 <span class="comment">            shapes.</span>
<a name="l01013"></a>01013 <span class="comment">        */</span>
<a name="l01014"></a>01014     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> C2&gt;
<a name="l01015"></a><a class="code" href="classvigra_1_1FFTWPlan.html#ab5bb3a651936156a78010cd157bd9fd8">01015</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1FFTWPlan.html#ac2451d98863694afea345ea9a5e7c5d4" title="Execute a complex-to-complex transform.">execute</a>(<a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>&lt;N, <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a>, C1&gt; in, 
<a name="l01016"></a>01016                  <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView&lt;N, Real, C2&gt;</a> out)<span class="keyword"> const</span>
<a name="l01017"></a>01017 <span class="keyword">    </span>{
<a name="l01018"></a>01018         executeImpl(in.permuteStridesDescending(), out.<a class="code" href="classvigra_1_1MultiArrayView.html#a421ac71c17f86f900041784e3c77857a">permuteStridesDescending</a>());
<a name="l01019"></a>01019     }
<a name="l01020"></a>01020     
<a name="l01021"></a>01021   <span class="keyword">private</span>:
<a name="l01022"></a>01022     
<a name="l01023"></a>01023     <span class="keyword">template</span> &lt;<span class="keyword">class</span> MI, <span class="keyword">class</span> MO&gt;
<a name="l01024"></a>01024     <span class="keywordtype">void</span> initImpl(MI ins, MO outs, <span class="keywordtype">int</span> SIGN, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags);
<a name="l01025"></a>01025     
<a name="l01026"></a>01026     <span class="keyword">template</span> &lt;<span class="keyword">class</span> MI, <span class="keyword">class</span> MO&gt;
<a name="l01027"></a>01027     <span class="keywordtype">void</span> executeImpl(MI ins, MO outs) <span class="keyword">const</span>;
<a name="l01028"></a>01028     
<a name="l01029"></a>01029     <span class="keywordtype">void</span> checkShapes(<a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>&lt;N, <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a>, <a class="code" href="structvigra_1_1StridedArrayTag.html">StridedArrayTag</a>&gt; in, 
<a name="l01030"></a>01030                      <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>&lt;N, <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a>, <a class="code" href="structvigra_1_1StridedArrayTag.html">StridedArrayTag</a>&gt; out)<span class="keyword"> const</span>
<a name="l01031"></a>01031 <span class="keyword">    </span>{
<a name="l01032"></a>01032         vigra_precondition(in.shape() == out.shape(),
<a name="l01033"></a>01033             <span class="stringliteral">&quot;FFTWPlan.init(): input and output must have the same shape.&quot;</span>);
<a name="l01034"></a>01034     }
<a name="l01035"></a>01035     
<a name="l01036"></a>01036     <span class="keywordtype">void</span> checkShapes(MultiArrayView&lt;N, Real, StridedArrayTag&gt; ins, 
<a name="l01037"></a>01037                      MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, StridedArrayTag&gt; outs)<span class="keyword"> const</span>
<a name="l01038"></a>01038 <span class="keyword">    </span>{
<a name="l01039"></a>01039         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;(int)N-1; ++k)
<a name="l01040"></a>01040             vigra_precondition(ins.shape(k) == outs.shape(k),
<a name="l01041"></a>01041                 <span class="stringliteral">&quot;FFTWPlan.init(): input and output must have matching shapes.&quot;</span>);
<a name="l01042"></a>01042         vigra_precondition(ins.shape(N-1) / 2 + 1 == outs.shape(N-1),
<a name="l01043"></a>01043             <span class="stringliteral">&quot;FFTWPlan.init(): input and output must have matching shapes.&quot;</span>);
<a name="l01044"></a>01044     }
<a name="l01045"></a>01045     
<a name="l01046"></a>01046     <span class="keywordtype">void</span> checkShapes(MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, StridedArrayTag&gt; ins, 
<a name="l01047"></a>01047                      MultiArrayView&lt;N, Real, StridedArrayTag&gt; outs)<span class="keyword"> const</span>
<a name="l01048"></a>01048 <span class="keyword">    </span>{
<a name="l01049"></a>01049         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;(int)N-1; ++k)
<a name="l01050"></a>01050             vigra_precondition(ins.shape(k) == outs.shape(k),
<a name="l01051"></a>01051                 <span class="stringliteral">&quot;FFTWPlan.init(): input and output must have matching shapes.&quot;</span>);
<a name="l01052"></a>01052         vigra_precondition(outs.shape(N-1) / 2 + 1 == ins.shape(N-1),
<a name="l01053"></a>01053             <span class="stringliteral">&quot;FFTWPlan.init(): input and output must have matching shapes.&quot;</span>);
<a name="l01054"></a>01054     }
<a name="l01055"></a>01055 };
<a name="l01056"></a>01056 
<a name="l01057"></a>01057 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real&gt;
<a name="l01058"></a>01058 <span class="keyword">template</span> &lt;<span class="keyword">class</span> MI, <span class="keyword">class</span> MO&gt;
<a name="l01059"></a>01059 <span class="keywordtype">void</span>
<a name="l01060"></a>01060 FFTWPlan&lt;N, Real&gt;::initImpl(MI ins, MO outs, <span class="keywordtype">int</span> SIGN, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags)
<a name="l01061"></a>01061 {
<a name="l01062"></a>01062     checkShapes(ins, outs);
<a name="l01063"></a>01063     
<a name="l01064"></a>01064     <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type logicalShape(SIGN == FFTW_FORWARD
<a name="l01065"></a>01065                                                 ? ins.shape()
<a name="l01066"></a>01066                                                 : outs.shape());
<a name="l01067"></a>01067                                            
<a name="l01068"></a>01068     Shape newShape(logicalShape.begin(), logicalShape.end()),
<a name="l01069"></a>01069           newIStrides(ins.stride().begin(), ins.stride().end()),
<a name="l01070"></a>01070           newOStrides(outs.stride().begin(), outs.stride().end()),
<a name="l01071"></a>01071           itotal(ins.shape().begin(), ins.shape().end()), 
<a name="l01072"></a>01072           ototal(outs.shape().begin(), outs.shape().end());
<a name="l01073"></a>01073 
<a name="l01074"></a>01074     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=1; j&lt;N; ++j)
<a name="l01075"></a>01075     {
<a name="l01076"></a>01076         itotal[j] = ins.stride(j-1) / ins.stride(j);
<a name="l01077"></a>01077         ototal[j] = outs.stride(j-1) / outs.stride(j);
<a name="l01078"></a>01078     }
<a name="l01079"></a>01079     
<a name="l01080"></a>01080     PlanType newPlan = detail::fftwPlanCreate(N, newShape.begin(), 
<a name="l01081"></a>01081                                   ins.data(), itotal.begin(), ins.stride(N-1),
<a name="l01082"></a>01082                                   outs.data(), ototal.begin(), outs.stride(N-1),
<a name="l01083"></a>01083                                   SIGN, planner_flags);
<a name="l01084"></a>01084     detail::fftwPlanDestroy(plan);
<a name="l01085"></a>01085     plan = newPlan;
<a name="l01086"></a>01086     shape.swap(newShape);
<a name="l01087"></a>01087     instrides.swap(newIStrides);
<a name="l01088"></a>01088     outstrides.swap(newOStrides);
<a name="l01089"></a>01089     sign = SIGN;
<a name="l01090"></a>01090 }
<a name="l01091"></a>01091 
<a name="l01092"></a>01092 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real&gt;
<a name="l01093"></a>01093 <span class="keyword">template</span> &lt;<span class="keyword">class</span> MI, <span class="keyword">class</span> MO&gt;
<a name="l01094"></a>01094 <span class="keywordtype">void</span> FFTWPlan&lt;N, Real&gt;::executeImpl(MI ins, MO outs)<span class="keyword"> const</span>
<a name="l01095"></a>01095 <span class="keyword"></span>{
<a name="l01096"></a>01096     vigra_precondition(plan != 0, <span class="stringliteral">&quot;FFTWPlan::execute(): plan is NULL.&quot;</span>);
<a name="l01097"></a>01097 
<a name="l01098"></a>01098     <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type lshape(sign == FFTW_FORWARD
<a name="l01099"></a>01099                                                 ? ins.shape()
<a name="l01100"></a>01100                                                 : outs.shape());
<a name="l01101"></a>01101                                            
<a name="l01102"></a>01102     vigra_precondition((lshape == TinyVectorView&lt;int, N&gt;(shape.data())),
<a name="l01103"></a>01103         <span class="stringliteral">&quot;FFTWPlan::execute(): shape mismatch between plan and data.&quot;</span>);
<a name="l01104"></a>01104     vigra_precondition((ins.stride() == TinyVectorView&lt;int, N&gt;(instrides.data())),
<a name="l01105"></a>01105         <span class="stringliteral">&quot;FFTWPlan::execute(): strides mismatch between plan and input data.&quot;</span>);
<a name="l01106"></a>01106     vigra_precondition((outs.stride() == TinyVectorView&lt;int, N&gt;(outstrides.data())),
<a name="l01107"></a>01107         <span class="stringliteral">&quot;FFTWPlan::execute(): strides mismatch between plan and output data.&quot;</span>);
<a name="l01108"></a>01108 
<a name="l01109"></a>01109     detail::fftwPlanExecute(plan, ins.data(), outs.data());
<a name="l01110"></a>01110     
<a name="l01111"></a>01111     <span class="keyword">typedef</span> <span class="keyword">typename</span> MO::value_type V;
<a name="l01112"></a>01112     <span class="keywordflow">if</span>(sign == FFTW_BACKWARD)
<a name="l01113"></a>01113         outs *= V(1.0) / Real(outs.size());
<a name="l01114"></a>01114 }
<a name="l01115"></a>01115 
<a name="l01116"></a>01116 <span class="comment">/********************************************************/</span>
<a name="l01117"></a>01117 <span class="comment">/*                                                      */</span>
<a name="l01118"></a>01118 <span class="comment">/*                  FFTWConvolvePlan                    */</span>
<a name="l01119"></a>01119 <span class="comment">/*                                                      */</span>
<a name="l01120"></a>01120 <span class="comment">/********************************************************/</span>
<a name="l01121"></a>01121 <span class="comment"></span>
<a name="l01122"></a>01122 <span class="comment">/** C++ wrapper for a pair of FFTW plans used to perform FFT-based convolution.</span>
<a name="l01123"></a>01123 <span class="comment"></span>
<a name="l01124"></a>01124 <span class="comment">    The class encapsulates the calls to &lt;tt&gt;fftw_plan_dft_2d&lt;/tt&gt;, &lt;tt&gt;fftw_execute&lt;/tt&gt;, and</span>
<a name="l01125"></a>01125 <span class="comment">    &lt;tt&gt;fftw_destroy_plan&lt;/tt&gt; (and their &lt;tt&gt;float&lt;/tt&gt; and &lt;tt&gt;long double&lt;/tt&gt; counterparts)</span>
<a name="l01126"></a>01126 <span class="comment">    in an easy-to-use interface. It always creates a pair of plans, one for the forward and one</span>
<a name="l01127"></a>01127 <span class="comment">    for the inverse transform required for convolution.</span>
<a name="l01128"></a>01128 <span class="comment"></span>
<a name="l01129"></a>01129 <span class="comment">    Usually, you use this class only indirectly via \ref convolveFFT() and its variants. </span>
<a name="l01130"></a>01130 <span class="comment">    You only need this class if you want to have more control about FFTW&#39;s planning process </span>
<a name="l01131"></a>01131 <span class="comment">    (by providing non-default planning flags) and/or want to re-use plans for several convolutions.</span>
<a name="l01132"></a>01132 <span class="comment">    </span>
<a name="l01133"></a>01133 <span class="comment">    &lt;b&gt; Usage:&lt;/b&gt;</span>
<a name="l01134"></a>01134 <span class="comment"></span>
<a name="l01135"></a>01135 <span class="comment">    &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/multi_fft.hxx&gt;&lt;br&gt;</span>
<a name="l01136"></a>01136 <span class="comment">    Namespace: vigra</span>
<a name="l01137"></a>01137 <span class="comment"></span>
<a name="l01138"></a>01138 <span class="comment">    \code</span>
<a name="l01139"></a>01139 <span class="comment">    // convolve a real array with a real kernel</span>
<a name="l01140"></a>01140 <span class="comment">    MultiArray&lt;2, double&gt; src(Shape2(w, h)), dest(Shape2(w, h));</span>
<a name="l01141"></a>01141 <span class="comment">    </span>
<a name="l01142"></a>01142 <span class="comment">    MultiArray&lt;2, double&gt; spatial_kernel(Shape2(9, 9));</span>
<a name="l01143"></a>01143 <span class="comment">    Gaussian&lt;double&gt; gauss(1.0);</span>
<a name="l01144"></a>01144 <span class="comment">    </span>
<a name="l01145"></a>01145 <span class="comment">    for(int y=0; y&lt;9; ++y)</span>
<a name="l01146"></a>01146 <span class="comment">        for(int x=0; x&lt;9; ++x)</span>
<a name="l01147"></a>01147 <span class="comment">            spatial_kernel(x, y) = gauss(x-4.0)*gauss(y-4.0);</span>
<a name="l01148"></a>01148 <span class="comment">            </span>
<a name="l01149"></a>01149 <span class="comment">    // create an optimized plan by measuring the speed of several algorithm variants</span>
<a name="l01150"></a>01150 <span class="comment">    FFTWConvolvePlan&lt;2, double&gt; plan(src, spatial_kernel, dest, FFTW_MEASURE);</span>
<a name="l01151"></a>01151 <span class="comment">    </span>
<a name="l01152"></a>01152 <span class="comment">    plan.execute(src, spatial_kernel, dest); </span>
<a name="l01153"></a>01153 <span class="comment">    \endcode</span>
<a name="l01154"></a>01154 <span class="comment">*/</span>
<a name="l01155"></a>01155 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real&gt;
<a name="l01156"></a><a class="code" href="classvigra_1_1FFTWConvolvePlan.html">01156</a> <span class="keyword">class </span><a class="code" href="classvigra_1_1FFTWConvolvePlan.html">FFTWConvolvePlan</a>
<a name="l01157"></a>01157 {
<a name="l01158"></a>01158     <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a> <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">Complex</a>;
<a name="l01159"></a>01159     <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1MultiArrayView.html">MultiArrayView&lt;N, Real, UnstridedArrayTag &gt;</a>     <a class="code" href="classvigra_1_1MultiArrayView.html">RArray</a>;
<a name="l01160"></a>01160     <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">MultiArray&lt;N, Complex, FFTWAllocator&lt;Complex&gt;</a> &gt; <a class="code" href="classvigra_1_1MultiArray.html">CArray</a>;
<a name="l01161"></a>01161     
<a name="l01162"></a>01162     <a class="code" href="classvigra_1_1FFTWPlan.html">FFTWPlan&lt;N, Real&gt;</a> forward_plan, backward_plan;
<a name="l01163"></a>01163     <a class="code" href="classvigra_1_1MultiArrayView.html">RArray</a> realArray, realKernel;
<a name="l01164"></a>01164     <a class="code" href="classvigra_1_1MultiArray.html">CArray</a> fourierArray, fourierKernel;
<a name="l01165"></a>01165     <span class="keywordtype">bool</span> useFourierKernel;
<a name="l01166"></a>01166 
<a name="l01167"></a>01167   <span class="keyword">public</span>:
<a name="l01168"></a>01168   
<a name="l01169"></a>01169     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvigra_1_1TinyVector.html" title="Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE...">MultiArrayShape&lt;N&gt;::type</a> Shape;
<a name="l01170"></a>01170 <span class="comment"></span>
<a name="l01171"></a>01171 <span class="comment">        /** \brief Create an empty plan.</span>
<a name="l01172"></a>01172 <span class="comment">        </span>
<a name="l01173"></a>01173 <span class="comment">            The plan can be initialized later by one of the init() functions.</span>
<a name="l01174"></a>01174 <span class="comment">        */</span>
<a name="l01175"></a><a class="code" href="classvigra_1_1FFTWConvolvePlan.html#ad2aede80344b005ce5b40fefaa8610eb">01175</a>     <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#ad2aede80344b005ce5b40fefaa8610eb" title="Create an empty plan.">FFTWConvolvePlan</a>()
<a name="l01176"></a>01176     : useFourierKernel(false)
<a name="l01177"></a>01177     {}
<a name="l01178"></a>01178     <span class="comment"></span>
<a name="l01179"></a>01179 <span class="comment">        /** \brief Create a plan to convolve a real array with a real kernel.</span>
<a name="l01180"></a>01180 <span class="comment">        </span>
<a name="l01181"></a>01181 <span class="comment">            The kernel must be defined in the spatial domain.</span>
<a name="l01182"></a>01182 <span class="comment">            See \ref convolveFFT() for detailed information on required shapes and internal padding.</span>
<a name="l01183"></a>01183 <span class="comment">        </span>
<a name="l01184"></a>01184 <span class="comment">            \arg planner_flags must be a combination of the </span>
<a name="l01185"></a>01185 <span class="comment">            &lt;a href=&quot;http://www.fftw.org/doc/Planner-Flags.html&quot;&gt;planner </span>
<a name="l01186"></a>01186 <span class="comment">            flags&lt;/a&gt; defined by the FFTW library. The default &lt;tt&gt;FFTW_ESTIMATE&lt;/tt&gt; will guess</span>
<a name="l01187"></a>01187 <span class="comment">            optimal algorithm settings or read them from pre-loaded </span>
<a name="l01188"></a>01188 <span class="comment">            &lt;a href=&quot;http://www.fftw.org/doc/Wisdom.html&quot;&gt;&quot;wisdom&quot;&lt;/a&gt;.</span>
<a name="l01189"></a>01189 <span class="comment">        */</span>
<a name="l01190"></a>01190     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;
<a name="l01191"></a><a class="code" href="classvigra_1_1FFTWConvolvePlan.html#a7995087149900c780a60ebd66ce4ee74">01191</a>     <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#ad2aede80344b005ce5b40fefaa8610eb" title="Create an empty plan.">FFTWConvolvePlan</a>(<a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView&lt;N, Real, C1&gt;</a> in, 
<a name="l01192"></a>01192                      <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView&lt;N, Real, C2&gt;</a> kernel,
<a name="l01193"></a>01193                      <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView&lt;N, Real, C3&gt;</a> out,
<a name="l01194"></a>01194                      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags = FFTW_ESTIMATE)
<a name="l01195"></a>01195     : useFourierKernel(false)
<a name="l01196"></a>01196     {
<a name="l01197"></a>01197         <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#ad9cee0fbde7dd62b6f5d3101269d1e50" title="Init a plan to convolve a real array with a real kernel.">init</a>(in, kernel, out, planner_flags);
<a name="l01198"></a>01198     }
<a name="l01199"></a>01199     <span class="comment"></span>
<a name="l01200"></a>01200 <span class="comment">        /** \brief Create a plan to convolve a real array with a complex kernel.</span>
<a name="l01201"></a>01201 <span class="comment">        </span>
<a name="l01202"></a>01202 <span class="comment">            The kernel must be defined in the Fourier domain, using the half-space format. </span>
<a name="l01203"></a>01203 <span class="comment">            See \ref convolveFFT() for detailed information on required shapes and internal padding.</span>
<a name="l01204"></a>01204 <span class="comment">        </span>
<a name="l01205"></a>01205 <span class="comment">            \arg planner_flags must be a combination of the </span>
<a name="l01206"></a>01206 <span class="comment">            &lt;a href=&quot;http://www.fftw.org/doc/Planner-Flags.html&quot;&gt;planner </span>
<a name="l01207"></a>01207 <span class="comment">            flags&lt;/a&gt; defined by the FFTW library. The default &lt;tt&gt;FFTW_ESTIMATE&lt;/tt&gt; will guess</span>
<a name="l01208"></a>01208 <span class="comment">            optimal algorithm settings or read them from pre-loaded </span>
<a name="l01209"></a>01209 <span class="comment">            &lt;a href=&quot;http://www.fftw.org/doc/Wisdom.html&quot;&gt;&quot;wisdom&quot;&lt;/a&gt;.</span>
<a name="l01210"></a>01210 <span class="comment">        */</span>
<a name="l01211"></a>01211     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;
<a name="l01212"></a><a class="code" href="classvigra_1_1FFTWConvolvePlan.html#acce83f9504e3581a7bd9d2353536aff1">01212</a>     <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#ad2aede80344b005ce5b40fefaa8610eb" title="Create an empty plan.">FFTWConvolvePlan</a>(<a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView&lt;N, Real, C1&gt;</a> in, 
<a name="l01213"></a>01213                      <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>&lt;N, <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a>, C2&gt; kernel,
<a name="l01214"></a>01214                      <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView&lt;N, Real, C3&gt;</a> out,
<a name="l01215"></a>01215                      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags = FFTW_ESTIMATE)
<a name="l01216"></a>01216     : useFourierKernel(true)
<a name="l01217"></a>01217     {
<a name="l01218"></a>01218         <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#ad9cee0fbde7dd62b6f5d3101269d1e50" title="Init a plan to convolve a real array with a real kernel.">init</a>(in, kernel, out, planner_flags);
<a name="l01219"></a>01219     }
<a name="l01220"></a>01220    <span class="comment"></span>
<a name="l01221"></a>01221 <span class="comment">        /** \brief Create a plan to convolve a complex array with a complex kernel.</span>
<a name="l01222"></a>01222 <span class="comment">        </span>
<a name="l01223"></a>01223 <span class="comment">            See \ref convolveFFT() for detailed information on required shapes and internal padding.</span>
<a name="l01224"></a>01224 <span class="comment">        </span>
<a name="l01225"></a>01225 <span class="comment">            \arg fourierDomainKernel determines if the kernel is defined in the spatial or</span>
<a name="l01226"></a>01226 <span class="comment">                  Fourier domain.</span>
<a name="l01227"></a>01227 <span class="comment">            \arg planner_flags must be a combination of the </span>
<a name="l01228"></a>01228 <span class="comment">            &lt;a href=&quot;http://www.fftw.org/doc/Planner-Flags.html&quot;&gt;planner </span>
<a name="l01229"></a>01229 <span class="comment">            flags&lt;/a&gt; defined by the FFTW library. The default &lt;tt&gt;FFTW_ESTIMATE&lt;/tt&gt; will guess</span>
<a name="l01230"></a>01230 <span class="comment">            optimal algorithm settings or read them from pre-loaded </span>
<a name="l01231"></a>01231 <span class="comment">            &lt;a href=&quot;http://www.fftw.org/doc/Wisdom.html&quot;&gt;&quot;wisdom&quot;&lt;/a&gt;.</span>
<a name="l01232"></a>01232 <span class="comment">        */</span>
<a name="l01233"></a>01233     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;
<a name="l01234"></a><a class="code" href="classvigra_1_1FFTWConvolvePlan.html#a4f5b2a8bae780fb9f32fb7753380f3e0">01234</a>     <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#ad2aede80344b005ce5b40fefaa8610eb" title="Create an empty plan.">FFTWConvolvePlan</a>(<a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>&lt;N, <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a>, C1&gt; in,
<a name="l01235"></a>01235                      <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>&lt;N, <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a>, C2&gt; kernel,
<a name="l01236"></a>01236                      <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>&lt;N, <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a>, C3&gt; out, 
<a name="l01237"></a>01237                      <span class="keywordtype">bool</span> fourierDomainKernel,
<a name="l01238"></a>01238                      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags = FFTW_ESTIMATE)
<a name="l01239"></a>01239     {
<a name="l01240"></a>01240         <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#ad9cee0fbde7dd62b6f5d3101269d1e50" title="Init a plan to convolve a real array with a real kernel.">init</a>(in, kernel, out, fourierDomainKernel, planner_flags);
<a name="l01241"></a>01241     }
<a name="l01242"></a>01242 
<a name="l01243"></a>01243  <span class="comment"></span>
<a name="l01244"></a>01244 <span class="comment">        /** \brief Create a plan from just the shape information.</span>
<a name="l01245"></a>01245 <span class="comment">        </span>
<a name="l01246"></a>01246 <span class="comment">            See \ref convolveFFT() for detailed information on required shapes and internal padding.</span>
<a name="l01247"></a>01247 <span class="comment">        </span>
<a name="l01248"></a>01248 <span class="comment">            \arg fourierDomainKernel determines if the kernel is defined in the spatial or</span>
<a name="l01249"></a>01249 <span class="comment">                  Fourier domain.</span>
<a name="l01250"></a>01250 <span class="comment">            \arg planner_flags must be a combination of the </span>
<a name="l01251"></a>01251 <span class="comment">            &lt;a href=&quot;http://www.fftw.org/doc/Planner-Flags.html&quot;&gt;planner </span>
<a name="l01252"></a>01252 <span class="comment">            flags&lt;/a&gt; defined by the FFTW library. The default &lt;tt&gt;FFTW_ESTIMATE&lt;/tt&gt; will guess</span>
<a name="l01253"></a>01253 <span class="comment">            optimal algorithm settings or read them from pre-loaded </span>
<a name="l01254"></a>01254 <span class="comment">            &lt;a href=&quot;http://www.fftw.org/doc/Wisdom.html&quot;&gt;&quot;wisdom&quot;&lt;/a&gt;.</span>
<a name="l01255"></a>01255 <span class="comment">        */</span>
<a name="l01256"></a>01256     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;
<a name="l01257"></a><a class="code" href="classvigra_1_1FFTWConvolvePlan.html#a1f2c8c91209f144f5d5826674306c8a0">01257</a>     <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#ad2aede80344b005ce5b40fefaa8610eb" title="Create an empty plan.">FFTWConvolvePlan</a>(Shape inOut, Shape kernel, 
<a name="l01258"></a>01258                      <span class="keywordtype">bool</span> useFourierKernel = <span class="keyword">false</span>,
<a name="l01259"></a>01259                      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags = FFTW_ESTIMATE)
<a name="l01260"></a>01260     {
<a name="l01261"></a>01261         <span class="keywordflow">if</span>(useFourierKernel)
<a name="l01262"></a>01262             <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#ad9cee0fbde7dd62b6f5d3101269d1e50" title="Init a plan to convolve a real array with a real kernel.">init</a>(inOut, kernel, planner_flags);
<a name="l01263"></a>01263         <span class="keywordflow">else</span>
<a name="l01264"></a>01264             initFourierKernel(inOut, kernel, planner_flags);
<a name="l01265"></a>01265     }
<a name="l01266"></a>01266     <span class="comment"></span>
<a name="l01267"></a>01267 <span class="comment">        /** \brief Init a plan to convolve a real array with a real kernel.</span>
<a name="l01268"></a>01268 <span class="comment">         </span>
<a name="l01269"></a>01269 <span class="comment">            See the constructor with the same signature for details.</span>
<a name="l01270"></a>01270 <span class="comment">        */</span>
<a name="l01271"></a>01271     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;
<a name="l01272"></a><a class="code" href="classvigra_1_1FFTWConvolvePlan.html#ad9cee0fbde7dd62b6f5d3101269d1e50">01272</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#ad9cee0fbde7dd62b6f5d3101269d1e50" title="Init a plan to convolve a real array with a real kernel.">init</a>(<a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView&lt;N, Real, C1&gt;</a> in, 
<a name="l01273"></a>01273               <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView&lt;N, Real, C2&gt;</a> kernel,
<a name="l01274"></a>01274               <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView&lt;N, Real, C3&gt;</a> out,
<a name="l01275"></a>01275               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags = FFTW_ESTIMATE)
<a name="l01276"></a>01276     {
<a name="l01277"></a>01277         vigra_precondition(in.<a class="code" href="classvigra_1_1MultiArrayView.html#a53c8f0d5c70f10f31fbc246cbe524e32">shape</a>() == out.<a class="code" href="classvigra_1_1MultiArrayView.html#a53c8f0d5c70f10f31fbc246cbe524e32">shape</a>(),
<a name="l01278"></a>01278             <span class="stringliteral">&quot;FFTWConvolvePlan::init(): input and output must have the same shape.&quot;</span>);
<a name="l01279"></a>01279         <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#ad9cee0fbde7dd62b6f5d3101269d1e50" title="Init a plan to convolve a real array with a real kernel.">init</a>(in.<a class="code" href="classvigra_1_1MultiArrayView.html#a53c8f0d5c70f10f31fbc246cbe524e32">shape</a>(), kernel.<a class="code" href="classvigra_1_1MultiArrayView.html#a53c8f0d5c70f10f31fbc246cbe524e32">shape</a>(), planner_flags);
<a name="l01280"></a>01280     }
<a name="l01281"></a>01281     <span class="comment"></span>
<a name="l01282"></a>01282 <span class="comment">        /** \brief Init a plan to convolve a real array with a complex kernel.</span>
<a name="l01283"></a>01283 <span class="comment">         </span>
<a name="l01284"></a>01284 <span class="comment">            See the constructor with the same signature for details.</span>
<a name="l01285"></a>01285 <span class="comment">        */</span>
<a name="l01286"></a>01286     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;
<a name="l01287"></a><a class="code" href="classvigra_1_1FFTWConvolvePlan.html#a5abef66c257f6addd22c3c59f2443d0c">01287</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#ad9cee0fbde7dd62b6f5d3101269d1e50" title="Init a plan to convolve a real array with a real kernel.">init</a>(<a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView&lt;N, Real, C1&gt;</a> in, 
<a name="l01288"></a>01288               <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>&lt;N, <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a>, C2&gt; kernel,
<a name="l01289"></a>01289               <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView&lt;N, Real, C3&gt;</a> out,
<a name="l01290"></a>01290               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags = FFTW_ESTIMATE)
<a name="l01291"></a>01291     {
<a name="l01292"></a>01292         vigra_precondition(in.<a class="code" href="classvigra_1_1MultiArrayView.html#a53c8f0d5c70f10f31fbc246cbe524e32">shape</a>() == out.<a class="code" href="classvigra_1_1MultiArrayView.html#a53c8f0d5c70f10f31fbc246cbe524e32">shape</a>(),
<a name="l01293"></a>01293             <span class="stringliteral">&quot;FFTWConvolvePlan::init(): input and output must have the same shape.&quot;</span>);
<a name="l01294"></a>01294         initFourierKernel(in.<a class="code" href="classvigra_1_1MultiArrayView.html#a53c8f0d5c70f10f31fbc246cbe524e32">shape</a>(), kernel.shape(), planner_flags);
<a name="l01295"></a>01295     }
<a name="l01296"></a>01296     <span class="comment"></span>
<a name="l01297"></a>01297 <span class="comment">        /** \brief Init a plan to convolve a complex array with a complex kernel.</span>
<a name="l01298"></a>01298 <span class="comment">         </span>
<a name="l01299"></a>01299 <span class="comment">            See the constructor with the same signature for details.</span>
<a name="l01300"></a>01300 <span class="comment">        */</span>
<a name="l01301"></a>01301     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;
<a name="l01302"></a><a class="code" href="classvigra_1_1FFTWConvolvePlan.html#a59801be1ed33732b2dfe35a0179bb877">01302</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#ad9cee0fbde7dd62b6f5d3101269d1e50" title="Init a plan to convolve a real array with a real kernel.">init</a>(<a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>&lt;N, <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a>, C1&gt; in, 
<a name="l01303"></a>01303               <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>&lt;N, <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a>, C2&gt; kernel,
<a name="l01304"></a>01304               <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>&lt;N, <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a>, C3&gt; out, 
<a name="l01305"></a>01305               <span class="keywordtype">bool</span> fourierDomainKernel,
<a name="l01306"></a>01306               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags = FFTW_ESTIMATE)
<a name="l01307"></a>01307     {
<a name="l01308"></a>01308         vigra_precondition(in.shape() == out.shape(),
<a name="l01309"></a>01309             <span class="stringliteral">&quot;FFTWConvolvePlan::init(): input and output must have the same shape.&quot;</span>);
<a name="l01310"></a>01310         useFourierKernel = fourierDomainKernel;
<a name="l01311"></a>01311         initComplex(in.shape(), kernel.shape(), planner_flags);
<a name="l01312"></a>01312     }
<a name="l01313"></a>01313     <span class="comment"></span>
<a name="l01314"></a>01314 <span class="comment">        /** \brief Init a plan to convolve a real array with a sequence of kernels.</span>
<a name="l01315"></a>01315 <span class="comment">         </span>
<a name="l01316"></a>01316 <span class="comment">            The kernels can be either real or complex. The sequences \a kernels and \a outs</span>
<a name="l01317"></a>01317 <span class="comment">            must have the same length. See the corresponding constructors </span>
<a name="l01318"></a>01318 <span class="comment">            for single kernels for details.</span>
<a name="l01319"></a>01319 <span class="comment">        */</span>
<a name="l01320"></a>01320     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> KernelIterator, <span class="keyword">class</span> OutIterator&gt;
<a name="l01321"></a><a class="code" href="classvigra_1_1FFTWConvolvePlan.html#acfbe09c8e5215dfe7026a89a6cac3fe4">01321</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#acfbe09c8e5215dfe7026a89a6cac3fe4" title="Init a plan to convolve a real array with a sequence of kernels.">initMany</a>(<a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView&lt;N, Real, C1&gt;</a> in, 
<a name="l01322"></a>01322                   KernelIterator kernels, KernelIterator kernelsEnd,
<a name="l01323"></a>01323                   OutIterator outs, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags = FFTW_ESTIMATE)
<a name="l01324"></a>01324     {
<a name="l01325"></a>01325         <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;KernelIterator&gt;::value_type KernelArray;
<a name="l01326"></a>01326         <span class="keyword">typedef</span> <span class="keyword">typename</span> KernelArray::value_type KernelValue;
<a name="l01327"></a>01327         <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;OutIterator&gt;::value_type OutArray;
<a name="l01328"></a>01328         <span class="keyword">typedef</span> <span class="keyword">typename</span> OutArray::value_type OutValue;
<a name="l01329"></a>01329 
<a name="l01330"></a>01330         <span class="keywordtype">bool</span> realKernel = IsSameType&lt;KernelValue, Real&gt;::value;
<a name="l01331"></a>01331         <span class="keywordtype">bool</span> fourierKernel = IsSameType&lt;KernelValue, Complex&gt;::value;
<a name="l01332"></a>01332 
<a name="l01333"></a>01333         vigra_precondition(realKernel || fourierKernel,
<a name="l01334"></a>01334              <span class="stringliteral">&quot;FFTWConvolvePlan::initMany(): kernels have unsuitable value_type.&quot;</span>);
<a name="l01335"></a>01335         vigra_precondition((IsSameType&lt;OutValue, Real&gt;::value),
<a name="l01336"></a>01336              <span class="stringliteral">&quot;FFTWConvolvePlan::initMany(): outputs have unsuitable value_type.&quot;</span>);
<a name="l01337"></a>01337 
<a name="l01338"></a>01338         <span class="keywordflow">if</span>(realKernel)
<a name="l01339"></a>01339         {
<a name="l01340"></a>01340             <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#acfbe09c8e5215dfe7026a89a6cac3fe4" title="Init a plan to convolve a real array with a sequence of kernels.">initMany</a>(in.<a class="code" href="classvigra_1_1MultiArrayView.html#a53c8f0d5c70f10f31fbc246cbe524e32">shape</a>(), checkShapes(in.<a class="code" href="classvigra_1_1MultiArrayView.html#a53c8f0d5c70f10f31fbc246cbe524e32">shape</a>(), kernels, kernelsEnd, outs),
<a name="l01341"></a>01341                      planner_flags);
<a name="l01342"></a>01342         }
<a name="l01343"></a>01343         <span class="keywordflow">else</span>
<a name="l01344"></a>01344         {
<a name="l01345"></a>01345             initFourierKernelMany(in.<a class="code" href="classvigra_1_1MultiArrayView.html#a53c8f0d5c70f10f31fbc246cbe524e32">shape</a>(), 
<a name="l01346"></a>01346                                   checkShapesFourier(in.<a class="code" href="classvigra_1_1MultiArrayView.html#a53c8f0d5c70f10f31fbc246cbe524e32">shape</a>(), kernels, kernelsEnd, outs),
<a name="l01347"></a>01347                                   planner_flags);
<a name="l01348"></a>01348         }
<a name="l01349"></a>01349     }
<a name="l01350"></a>01350      <span class="comment"></span>
<a name="l01351"></a>01351 <span class="comment">        /** \brief Init a plan to convolve a complex array with a sequence of kernels.</span>
<a name="l01352"></a>01352 <span class="comment">         </span>
<a name="l01353"></a>01353 <span class="comment">            The kernels must be complex as well. The sequences \a kernels and \a outs</span>
<a name="l01354"></a>01354 <span class="comment">            must have the same length. See the corresponding constructors </span>
<a name="l01355"></a>01355 <span class="comment">            for single kernels for details.</span>
<a name="l01356"></a>01356 <span class="comment">        */</span>
<a name="l01357"></a>01357     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> KernelIterator, <span class="keyword">class</span> OutIterator&gt;
<a name="l01358"></a><a class="code" href="classvigra_1_1FFTWConvolvePlan.html#a8267c39162b1469cb4137fb2dc36ae27">01358</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#acfbe09c8e5215dfe7026a89a6cac3fe4" title="Init a plan to convolve a real array with a sequence of kernels.">initMany</a>(<a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView</a>&lt;N, <a class="code" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW complex types &#39;fftw_complex&#39;.">FFTWComplex&lt;Real&gt;</a>, C1&gt; in, 
<a name="l01359"></a>01359                   KernelIterator kernels, KernelIterator kernelsEnd,
<a name="l01360"></a>01360                   OutIterator outs,
<a name="l01361"></a>01361                   <span class="keywordtype">bool</span> fourierDomainKernels,
<a name="l01362"></a>01362                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags = FFTW_ESTIMATE)
<a name="l01363"></a>01363     {
<a name="l01364"></a>01364         <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;KernelIterator&gt;::value_type KernelArray;
<a name="l01365"></a>01365         <span class="keyword">typedef</span> <span class="keyword">typename</span> KernelArray::value_type KernelValue;
<a name="l01366"></a>01366         <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;OutIterator&gt;::value_type OutArray;
<a name="l01367"></a>01367         <span class="keyword">typedef</span> <span class="keyword">typename</span> OutArray::value_type OutValue;
<a name="l01368"></a>01368 
<a name="l01369"></a>01369         vigra_precondition((IsSameType&lt;KernelValue, Complex&gt;::value),
<a name="l01370"></a>01370              <span class="stringliteral">&quot;FFTWConvolvePlan::initMany(): kernels have unsuitable value_type.&quot;</span>);
<a name="l01371"></a>01371         vigra_precondition((IsSameType&lt;OutValue, Complex&gt;::value),
<a name="l01372"></a>01372              <span class="stringliteral">&quot;FFTWConvolvePlan::initMany(): outputs have unsuitable value_type.&quot;</span>);
<a name="l01373"></a>01373 
<a name="l01374"></a>01374         useFourierKernel = fourierDomainKernels;
<a name="l01375"></a>01375         
<a name="l01376"></a>01376         Shape paddedShape = checkShapesComplex(in.shape(), kernels, kernelsEnd, outs);
<a name="l01377"></a>01377     
<a name="l01378"></a>01378         <a class="code" href="classvigra_1_1MultiArray.html">CArray</a> newFourierArray(paddedShape), newFourierKernel(paddedShape);
<a name="l01379"></a>01379     
<a name="l01380"></a>01380         <a class="code" href="classvigra_1_1FFTWPlan.html">FFTWPlan&lt;N, Real&gt;</a> fplan(newFourierArray, newFourierArray, FFTW_FORWARD, planner_flags);
<a name="l01381"></a>01381         <a class="code" href="classvigra_1_1FFTWPlan.html">FFTWPlan&lt;N, Real&gt;</a> bplan(newFourierArray, newFourierArray, FFTW_BACKWARD, planner_flags);
<a name="l01382"></a>01382     
<a name="l01383"></a>01383         forward_plan = fplan;
<a name="l01384"></a>01384         backward_plan = bplan;
<a name="l01385"></a>01385         fourierArray.<a class="code" href="classvigra_1_1MultiArray.html#a2e15da47fd16916e4165a55e99a0ed3b">swap</a>(newFourierArray);
<a name="l01386"></a>01386         fourierKernel.<a class="code" href="classvigra_1_1MultiArray.html#a2e15da47fd16916e4165a55e99a0ed3b">swap</a>(newFourierKernel);
<a name="l01387"></a>01387     }
<a name="l01388"></a>01388     
<a name="l01389"></a>01389     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#ad9cee0fbde7dd62b6f5d3101269d1e50" title="Init a plan to convolve a real array with a real kernel.">init</a>(Shape inOut, Shape kernel,
<a name="l01390"></a>01390               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags = FFTW_ESTIMATE);
<a name="l01391"></a>01391     
<a name="l01392"></a>01392     <span class="keywordtype">void</span> initFourierKernel(Shape inOut, Shape kernel,
<a name="l01393"></a>01393                            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags = FFTW_ESTIMATE);
<a name="l01394"></a>01394     
<a name="l01395"></a>01395     <span class="keywordtype">void</span> initComplex(Shape inOut, Shape kernel,
<a name="l01396"></a>01396                      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags = FFTW_ESTIMATE);
<a name="l01397"></a>01397     
<a name="l01398"></a>01398     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#acfbe09c8e5215dfe7026a89a6cac3fe4" title="Init a plan to convolve a real array with a sequence of kernels.">initMany</a>(Shape inOut, Shape maxKernel,
<a name="l01399"></a>01399                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags = FFTW_ESTIMATE)
<a name="l01400"></a>01400     {
<a name="l01401"></a>01401         <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#ad9cee0fbde7dd62b6f5d3101269d1e50" title="Init a plan to convolve a real array with a real kernel.">init</a>(inOut, maxKernel, planner_flags);
<a name="l01402"></a>01402     }
<a name="l01403"></a>01403     
<a name="l01404"></a>01404     <span class="keywordtype">void</span> initFourierKernelMany(Shape inOut, Shape kernels,
<a name="l01405"></a>01405                                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags = FFTW_ESTIMATE)
<a name="l01406"></a>01406     {
<a name="l01407"></a>01407         initFourierKernel(inOut, kernels, planner_flags);
<a name="l01408"></a>01408     }
<a name="l01409"></a>01409         <span class="comment"></span>
<a name="l01410"></a>01410 <span class="comment">        /** \brief Execute a plan to convolve a real array with a real kernel.</span>
<a name="l01411"></a>01411 <span class="comment">         </span>
<a name="l01412"></a>01412 <span class="comment">            The array shapes must be the same as in the corresponding init function</span>
<a name="l01413"></a>01413 <span class="comment">            or constructor. However, execute() can be called several times on</span>
<a name="l01414"></a>01414 <span class="comment">            the same plan, even with different arrays, as long as they have the appropriate </span>
<a name="l01415"></a>01415 <span class="comment">            shapes.</span>
<a name="l01416"></a>01416 <span class="comment">        */</span>
<a name="l01417"></a>01417     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;
<a name="l01418"></a>01418     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#a2ae5bbb04636ee6be7c356968e232a4d" title="Execute a plan to convolve a real array with a real kernel.">execute</a>(MultiArrayView&lt;N, Real, C1&gt; in, 
<a name="l01419"></a>01419                  MultiArrayView&lt;N, Real, C2&gt; kernel,
<a name="l01420"></a>01420                  MultiArrayView&lt;N, Real, C3&gt; out);
<a name="l01421"></a>01421     <span class="comment"></span>
<a name="l01422"></a>01422 <span class="comment">        /** \brief Execute a plan to convolve a real array with a complex kernel.</span>
<a name="l01423"></a>01423 <span class="comment">         </span>
<a name="l01424"></a>01424 <span class="comment">            The array shapes must be the same as in the corresponding init function</span>
<a name="l01425"></a>01425 <span class="comment">            or constructor. However, execute() can be called several times on</span>
<a name="l01426"></a>01426 <span class="comment">            the same plan, even with different arrays, as long as they have the appropriate </span>
<a name="l01427"></a>01427 <span class="comment">            shapes.</span>
<a name="l01428"></a>01428 <span class="comment">        */</span>
<a name="l01429"></a>01429     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;
<a name="l01430"></a>01430     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#a2ae5bbb04636ee6be7c356968e232a4d" title="Execute a plan to convolve a real array with a real kernel.">execute</a>(MultiArrayView&lt;N, Real, C1&gt; in, 
<a name="l01431"></a>01431                  MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C2&gt; kernel,
<a name="l01432"></a>01432                  MultiArrayView&lt;N, Real, C3&gt; out);
<a name="l01433"></a>01433 <span class="comment"></span>
<a name="l01434"></a>01434 <span class="comment">        /** \brief Execute a plan to convolve a complex array with a complex kernel.</span>
<a name="l01435"></a>01435 <span class="comment">         </span>
<a name="l01436"></a>01436 <span class="comment">            The array shapes must be the same as in the corresponding init function</span>
<a name="l01437"></a>01437 <span class="comment">            or constructor. However, execute() can be called several times on</span>
<a name="l01438"></a>01438 <span class="comment">            the same plan, even with different arrays, as long as they have the appropriate </span>
<a name="l01439"></a>01439 <span class="comment">            shapes.</span>
<a name="l01440"></a>01440 <span class="comment">        */</span>
<a name="l01441"></a>01441     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;
<a name="l01442"></a>01442     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#a2ae5bbb04636ee6be7c356968e232a4d" title="Execute a plan to convolve a real array with a real kernel.">execute</a>(MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C1&gt; in,
<a name="l01443"></a>01443                  MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C2&gt; kernel,
<a name="l01444"></a>01444                  MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C3&gt; out);
<a name="l01445"></a>01445 
<a name="l01446"></a>01446 <span class="comment"></span>
<a name="l01447"></a>01447 <span class="comment">        /** \brief Execute a plan to convolve a complex array with a sequence of kernels.</span>
<a name="l01448"></a>01448 <span class="comment">         </span>
<a name="l01449"></a>01449 <span class="comment">            The array shapes must be the same as in the corresponding init function</span>
<a name="l01450"></a>01450 <span class="comment">            or constructor. However, executeMany() can be called several times on</span>
<a name="l01451"></a>01451 <span class="comment">            the same plan, even with different arrays, as long as they have the appropriate </span>
<a name="l01452"></a>01452 <span class="comment">            shapes.</span>
<a name="l01453"></a>01453 <span class="comment">        */</span>
<a name="l01454"></a>01454     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> KernelIterator, <span class="keyword">class</span> OutIterator&gt;
<a name="l01455"></a>01455     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#a8a6e128726ee1662ba1b75f562e63148" title="Execute a plan to convolve a complex array with a sequence of kernels.">executeMany</a>(MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C1&gt; in, 
<a name="l01456"></a>01456                      KernelIterator kernels, KernelIterator kernelsEnd,
<a name="l01457"></a>01457                      OutIterator outs);
<a name="l01458"></a>01458                      <span class="comment"></span>
<a name="l01459"></a>01459 <span class="comment">        /** \brief Execute a plan to convolve a real array with a sequence of kernels.</span>
<a name="l01460"></a>01460 <span class="comment">         </span>
<a name="l01461"></a>01461 <span class="comment">            The array shapes must be the same as in the corresponding init function</span>
<a name="l01462"></a>01462 <span class="comment">            or constructor. However, executeMany() can be called several times on</span>
<a name="l01463"></a>01463 <span class="comment">            the same plan, even with different arrays, as long as they have the appropriate </span>
<a name="l01464"></a>01464 <span class="comment">            shapes.</span>
<a name="l01465"></a>01465 <span class="comment">        */</span>
<a name="l01466"></a>01466     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> KernelIterator, <span class="keyword">class</span> OutIterator&gt;
<a name="l01467"></a><a class="code" href="classvigra_1_1FFTWConvolvePlan.html#a55d55e5da33a1f6babd2702a055a6b01">01467</a>     <span class="keywordtype">void</span> <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#a8a6e128726ee1662ba1b75f562e63148" title="Execute a plan to convolve a complex array with a sequence of kernels.">executeMany</a>(<a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView&lt;N, Real, C1&gt;</a> in, 
<a name="l01468"></a>01468                      KernelIterator kernels, KernelIterator kernelsEnd,
<a name="l01469"></a>01469                      OutIterator outs)
<a name="l01470"></a>01470     {
<a name="l01471"></a>01471         <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;KernelIterator&gt;::value_type KernelArray;
<a name="l01472"></a>01472         <span class="keyword">typedef</span> <span class="keyword">typename</span> KernelArray::value_type KernelValue;
<a name="l01473"></a>01473         <span class="keyword">typedef</span> <span class="keyword">typename</span> IsSameType&lt;KernelValue, Complex&gt;::type UseFourierKernel;
<a name="l01474"></a>01474         <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;OutIterator&gt;::value_type OutArray;
<a name="l01475"></a>01475         <span class="keyword">typedef</span> <span class="keyword">typename</span> OutArray::value_type OutValue;
<a name="l01476"></a>01476 
<a name="l01477"></a>01477         <span class="keywordtype">bool</span> realKernel = IsSameType&lt;KernelValue, Real&gt;::value;
<a name="l01478"></a>01478         <span class="keywordtype">bool</span> fourierKernel = IsSameType&lt;KernelValue, Complex&gt;::value;
<a name="l01479"></a>01479 
<a name="l01480"></a>01480         vigra_precondition(realKernel || fourierKernel,
<a name="l01481"></a>01481              <span class="stringliteral">&quot;FFTWConvolvePlan::executeMany(): kernels have unsuitable value_type.&quot;</span>);
<a name="l01482"></a>01482         vigra_precondition((IsSameType&lt;OutValue, Real&gt;::value),
<a name="l01483"></a>01483              <span class="stringliteral">&quot;FFTWConvolvePlan::executeMany(): outputs have unsuitable value_type.&quot;</span>);
<a name="l01484"></a>01484 
<a name="l01485"></a>01485         executeManyImpl(in, kernels, kernelsEnd, outs, UseFourierKernel());
<a name="l01486"></a>01486     }
<a name="l01487"></a>01487 
<a name="l01488"></a>01488   <span class="keyword">private</span>:
<a name="l01489"></a>01489   
<a name="l01490"></a>01490     <span class="keyword">template</span> &lt;<span class="keyword">class</span> KernelIterator, <span class="keyword">class</span> OutIterator&gt;
<a name="l01491"></a>01491     Shape checkShapes(Shape in, 
<a name="l01492"></a>01492                       KernelIterator kernels, KernelIterator kernelsEnd,
<a name="l01493"></a>01493                       OutIterator outs);
<a name="l01494"></a>01494      
<a name="l01495"></a>01495     <span class="keyword">template</span> &lt;<span class="keyword">class</span> KernelIterator, <span class="keyword">class</span> OutIterator&gt;
<a name="l01496"></a>01496     Shape checkShapesFourier(Shape in, 
<a name="l01497"></a>01497                              KernelIterator kernels, KernelIterator kernelsEnd,
<a name="l01498"></a>01498                              OutIterator outs);
<a name="l01499"></a>01499      
<a name="l01500"></a>01500     <span class="keyword">template</span> &lt;<span class="keyword">class</span> KernelIterator, <span class="keyword">class</span> OutIterator&gt;
<a name="l01501"></a>01501     Shape checkShapesComplex(Shape in, 
<a name="l01502"></a>01502                              KernelIterator kernels, KernelIterator kernelsEnd,
<a name="l01503"></a>01503                              OutIterator outs);
<a name="l01504"></a>01504     
<a name="l01505"></a>01505     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> KernelIterator, <span class="keyword">class</span> OutIterator&gt;
<a name="l01506"></a>01506     <span class="keywordtype">void</span> 
<a name="l01507"></a>01507     executeManyImpl(<a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView&lt;N, Real, C1&gt;</a> in, 
<a name="l01508"></a>01508                     KernelIterator kernels, KernelIterator kernelsEnd,
<a name="l01509"></a>01509                     OutIterator outs, VigraFalseType <span class="comment">/* useFourierKernel*/</span>);
<a name="l01510"></a>01510     
<a name="l01511"></a>01511     <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> KernelIterator, <span class="keyword">class</span> OutIterator&gt;
<a name="l01512"></a>01512     <span class="keywordtype">void</span> 
<a name="l01513"></a>01513     executeManyImpl(<a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView&lt;N, Real, C1&gt;</a> in, 
<a name="l01514"></a>01514                     KernelIterator kernels, KernelIterator kernelsEnd,
<a name="l01515"></a>01515                     OutIterator outs, VigraTrueType <span class="comment">/* useFourierKernel*/</span>);
<a name="l01516"></a>01516     
<a name="l01517"></a>01517 };    
<a name="l01518"></a>01518     
<a name="l01519"></a>01519 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real&gt;
<a name="l01520"></a>01520 <span class="keywordtype">void</span> 
<a name="l01521"></a>01521 <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#ad9cee0fbde7dd62b6f5d3101269d1e50" title="Init a plan to convolve a real array with a real kernel.">FFTWConvolvePlan&lt;N, Real&gt;::init</a>(Shape in, Shape kernel,
<a name="l01522"></a>01522                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags)
<a name="l01523"></a>01523 {
<a name="l01524"></a>01524     Shape paddedShape = fftwBestPaddedShapeR2C(in + kernel - Shape(1)),
<a name="l01525"></a>01525           complexShape = <a class="code" href="group__FourierTransform.html#gafbea828444f49163293b1d81fcd05da8" title="Find frequency domain shape for a R2C Fourier transform.">fftwCorrespondingShapeR2C</a>(paddedShape);
<a name="l01526"></a>01526      
<a name="l01527"></a>01527     CArray newFourierArray(complexShape), newFourierKernel(complexShape);
<a name="l01528"></a>01528     
<a name="l01529"></a>01529     Shape realStrides = 2*newFourierArray.stride();
<a name="l01530"></a>01530     realStrides[0] = 1;
<a name="l01531"></a>01531     RArray newRealArray(paddedShape, realStrides, (Real*)newFourierArray.data());
<a name="l01532"></a>01532     RArray newRealKernel(paddedShape, realStrides, (Real*)newFourierKernel.data());
<a name="l01533"></a>01533     
<a name="l01534"></a>01534     FFTWPlan&lt;N, Real&gt; fplan(newRealArray, newFourierArray, planner_flags);
<a name="l01535"></a>01535     FFTWPlan&lt;N, Real&gt; bplan(newFourierArray, newRealArray, planner_flags);
<a name="l01536"></a>01536     
<a name="l01537"></a>01537     forward_plan = fplan;
<a name="l01538"></a>01538     backward_plan = bplan;
<a name="l01539"></a>01539     realArray = newRealArray;
<a name="l01540"></a>01540     realKernel = newRealKernel;
<a name="l01541"></a>01541     fourierArray.swap(newFourierArray);
<a name="l01542"></a>01542     fourierKernel.swap(newFourierKernel);
<a name="l01543"></a>01543     useFourierKernel = <span class="keyword">false</span>;
<a name="l01544"></a>01544 }
<a name="l01545"></a>01545 
<a name="l01546"></a>01546 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real&gt;
<a name="l01547"></a>01547 <span class="keywordtype">void</span> 
<a name="l01548"></a>01548 FFTWConvolvePlan&lt;N, Real&gt;::initFourierKernel(Shape in, Shape kernel,
<a name="l01549"></a>01549                                              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags)
<a name="l01550"></a>01550 {
<a name="l01551"></a>01551     Shape complexShape = kernel,
<a name="l01552"></a>01552           paddedShape  = fftwCorrespondingShapeC2R(complexShape);
<a name="l01553"></a>01553     
<a name="l01554"></a>01554     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;N; ++k)
<a name="l01555"></a>01555         vigra_precondition(in[k] &lt;= paddedShape[k],
<a name="l01556"></a>01556              <span class="stringliteral">&quot;FFTWConvolvePlan::init(): kernel too small for given input.&quot;</span>);
<a name="l01557"></a>01557 
<a name="l01558"></a>01558     CArray newFourierArray(complexShape), newFourierKernel(complexShape);
<a name="l01559"></a>01559     
<a name="l01560"></a>01560     Shape realStrides = 2*newFourierArray.stride();
<a name="l01561"></a>01561     realStrides[0] = 1;
<a name="l01562"></a>01562     RArray newRealArray(paddedShape, realStrides, (Real*)newFourierArray.data());
<a name="l01563"></a>01563     RArray newRealKernel(paddedShape, realStrides, (Real*)newFourierKernel.data());
<a name="l01564"></a>01564     
<a name="l01565"></a>01565     FFTWPlan&lt;N, Real&gt; fplan(newRealArray, newFourierArray, planner_flags);
<a name="l01566"></a>01566     FFTWPlan&lt;N, Real&gt; bplan(newFourierArray, newRealArray, planner_flags);
<a name="l01567"></a>01567     
<a name="l01568"></a>01568     forward_plan = fplan;
<a name="l01569"></a>01569     backward_plan = bplan;
<a name="l01570"></a>01570     realArray = newRealArray;
<a name="l01571"></a>01571     realKernel = newRealKernel;
<a name="l01572"></a>01572     fourierArray.swap(newFourierArray);
<a name="l01573"></a>01573     fourierKernel.swap(newFourierKernel);
<a name="l01574"></a>01574     useFourierKernel = <span class="keyword">true</span>;
<a name="l01575"></a>01575 }
<a name="l01576"></a>01576 
<a name="l01577"></a>01577 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real&gt;
<a name="l01578"></a>01578 <span class="keywordtype">void</span> 
<a name="l01579"></a>01579 FFTWConvolvePlan&lt;N, Real&gt;::initComplex(Shape in, Shape kernel,
<a name="l01580"></a>01580                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> planner_flags)
<a name="l01581"></a>01581 {
<a name="l01582"></a>01582     Shape paddedShape;
<a name="l01583"></a>01583     
<a name="l01584"></a>01584     <span class="keywordflow">if</span>(useFourierKernel)
<a name="l01585"></a>01585     {
<a name="l01586"></a>01586         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;N; ++k)
<a name="l01587"></a>01587             vigra_precondition(in[k] &lt;= kernel[k],
<a name="l01588"></a>01588                  <span class="stringliteral">&quot;FFTWConvolvePlan::init(): kernel too small for given input.&quot;</span>);
<a name="l01589"></a>01589 
<a name="l01590"></a>01590         paddedShape = kernel;
<a name="l01591"></a>01591     }
<a name="l01592"></a>01592     <span class="keywordflow">else</span>
<a name="l01593"></a>01593     {
<a name="l01594"></a>01594         paddedShape  = fftwBestPaddedShape(in + kernel - Shape(1));
<a name="l01595"></a>01595     }
<a name="l01596"></a>01596     
<a name="l01597"></a>01597     CArray newFourierArray(paddedShape), newFourierKernel(paddedShape);
<a name="l01598"></a>01598     
<a name="l01599"></a>01599     FFTWPlan&lt;N, Real&gt; fplan(newFourierArray, newFourierArray, FFTW_FORWARD, planner_flags);
<a name="l01600"></a>01600     FFTWPlan&lt;N, Real&gt; bplan(newFourierArray, newFourierArray, FFTW_BACKWARD, planner_flags);
<a name="l01601"></a>01601     
<a name="l01602"></a>01602     forward_plan = fplan;
<a name="l01603"></a>01603     backward_plan = bplan;
<a name="l01604"></a>01604     fourierArray.swap(newFourierArray);
<a name="l01605"></a>01605     fourierKernel.swap(newFourierKernel);
<a name="l01606"></a>01606 }
<a name="l01607"></a>01607 
<a name="l01608"></a>01608 <span class="preprocessor">#ifndef DOXYGEN // doxygen documents these functions as free functions</span>
<a name="l01609"></a>01609 <span class="preprocessor"></span>
<a name="l01610"></a>01610 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real&gt;
<a name="l01611"></a>01611 <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;
<a name="l01612"></a>01612 <span class="keywordtype">void</span> 
<a name="l01613"></a>01613 <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#a2ae5bbb04636ee6be7c356968e232a4d" title="Execute a plan to convolve a real array with a real kernel.">FFTWConvolvePlan&lt;N, Real&gt;::execute</a>(MultiArrayView&lt;N, Real, C1&gt; in, 
<a name="l01614"></a>01614                                     MultiArrayView&lt;N, Real, C2&gt; kernel,
<a name="l01615"></a>01615                                     MultiArrayView&lt;N, Real, C3&gt; out)
<a name="l01616"></a>01616 {
<a name="l01617"></a>01617     vigra_precondition(!useFourierKernel,
<a name="l01618"></a>01618        <span class="stringliteral">&quot;FFTWConvolvePlan::execute(): plan was generated for Fourier kernel, got spatial kernel.&quot;</span>);
<a name="l01619"></a>01619 
<a name="l01620"></a>01620     vigra_precondition(in.shape() == out.shape(),
<a name="l01621"></a>01621         <span class="stringliteral">&quot;FFTWConvolvePlan::execute(): input and output must have the same shape.&quot;</span>);
<a name="l01622"></a>01622     
<a name="l01623"></a>01623     Shape paddedShape = fftwBestPaddedShapeR2C(in.shape() + kernel.shape() - Shape(1)),
<a name="l01624"></a>01624           diff = paddedShape - in.shape(), 
<a name="l01625"></a>01625           left = <a class="code" href="group__FixedPoint16Operations.html#gac71b069a80f6decdb6fad1cfd508f5f8" title="division with enforced result type.">div</a>(diff, <a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a>(2)),
<a name="l01626"></a>01626           right = in.shape() + left;
<a name="l01627"></a>01627           
<a name="l01628"></a>01628     vigra_precondition(paddedShape == realArray.shape(),
<a name="l01629"></a>01629        <span class="stringliteral">&quot;FFTWConvolvePlan::execute(): shape mismatch between input and plan.&quot;</span>);
<a name="l01630"></a>01630 
<a name="l01631"></a>01631     detail::fftEmbedArray(in, realArray);
<a name="l01632"></a>01632     forward_plan.execute(realArray, fourierArray);
<a name="l01633"></a>01633 
<a name="l01634"></a>01634     detail::fftEmbedKernel(kernel, realKernel);
<a name="l01635"></a>01635     forward_plan.execute(realKernel, fourierKernel);
<a name="l01636"></a>01636     
<a name="l01637"></a>01637     fourierArray *= fourierKernel;
<a name="l01638"></a>01638     
<a name="l01639"></a>01639     backward_plan.execute(fourierArray, realArray);
<a name="l01640"></a>01640     
<a name="l01641"></a>01641     out = realArray.subarray(left, right);
<a name="l01642"></a>01642 }
<a name="l01643"></a>01643 
<a name="l01644"></a>01644 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real&gt;
<a name="l01645"></a>01645 <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;
<a name="l01646"></a>01646 <span class="keywordtype">void</span> 
<a name="l01647"></a>01647 <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#a2ae5bbb04636ee6be7c356968e232a4d" title="Execute a plan to convolve a real array with a real kernel.">FFTWConvolvePlan&lt;N, Real&gt;::execute</a>(MultiArrayView&lt;N, Real, C1&gt; in, 
<a name="l01648"></a>01648                                     MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C2&gt; kernel,
<a name="l01649"></a>01649                                     MultiArrayView&lt;N, Real, C3&gt; out)
<a name="l01650"></a>01650 {
<a name="l01651"></a>01651     vigra_precondition(useFourierKernel,
<a name="l01652"></a>01652        <span class="stringliteral">&quot;FFTWConvolvePlan::execute(): plan was generated for spatial kernel, got Fourier kernel.&quot;</span>);
<a name="l01653"></a>01653 
<a name="l01654"></a>01654     vigra_precondition(in.shape() == out.shape(),
<a name="l01655"></a>01655         <span class="stringliteral">&quot;FFTWConvolvePlan::execute(): input and output must have the same shape.&quot;</span>);
<a name="l01656"></a>01656     
<a name="l01657"></a>01657     vigra_precondition(kernel.shape() == fourierArray.shape(),
<a name="l01658"></a>01658        <span class="stringliteral">&quot;FFTWConvolvePlan::execute(): shape mismatch between kernel and plan.&quot;</span>);
<a name="l01659"></a>01659 
<a name="l01660"></a>01660     Shape paddedShape = fftwCorrespondingShapeC2R(kernel.shape(), <a class="code" href="group__MathFunctions.html#ga48f661149941ebaa90ddd99ee5eee145" title="Check if an integer is odd.">odd</a>(in.shape(0))),
<a name="l01661"></a>01661           diff = paddedShape - in.shape(), 
<a name="l01662"></a>01662           left = <a class="code" href="group__FixedPoint16Operations.html#gac71b069a80f6decdb6fad1cfd508f5f8" title="division with enforced result type.">div</a>(diff, <a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a>(2)),
<a name="l01663"></a>01663           right = in.shape() + left;
<a name="l01664"></a>01664           
<a name="l01665"></a>01665     vigra_precondition(paddedShape == realArray.shape(),
<a name="l01666"></a>01666        <span class="stringliteral">&quot;FFTWConvolvePlan::execute(): shape mismatch between input and plan.&quot;</span>);
<a name="l01667"></a>01667 
<a name="l01668"></a>01668     detail::fftEmbedArray(in, realArray);
<a name="l01669"></a>01669     forward_plan.execute(realArray, fourierArray);
<a name="l01670"></a>01670 
<a name="l01671"></a>01671     fourierKernel = kernel;
<a name="l01672"></a>01672     moveDCToHalfspaceUpperLeft(fourierKernel);
<a name="l01673"></a>01673 
<a name="l01674"></a>01674     fourierArray *= fourierKernel;
<a name="l01675"></a>01675     
<a name="l01676"></a>01676     backward_plan.execute(fourierArray, realArray);
<a name="l01677"></a>01677     
<a name="l01678"></a>01678     out = realArray.subarray(left, right);
<a name="l01679"></a>01679 }
<a name="l01680"></a>01680 
<a name="l01681"></a>01681 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real&gt;
<a name="l01682"></a>01682 <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;
<a name="l01683"></a>01683 <span class="keywordtype">void</span> 
<a name="l01684"></a>01684 <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#a2ae5bbb04636ee6be7c356968e232a4d" title="Execute a plan to convolve a real array with a real kernel.">FFTWConvolvePlan&lt;N, Real&gt;::execute</a>(MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C1&gt; in, 
<a name="l01685"></a>01685                                     MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C2&gt; kernel,
<a name="l01686"></a>01686                                     MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C3&gt; out)
<a name="l01687"></a>01687 {
<a name="l01688"></a>01688     vigra_precondition(in.shape() == out.shape(),
<a name="l01689"></a>01689         <span class="stringliteral">&quot;FFTWConvolvePlan::execute(): input and output must have the same shape.&quot;</span>);
<a name="l01690"></a>01690     
<a name="l01691"></a>01691     Shape paddedShape = fourierArray.shape(),
<a name="l01692"></a>01692           diff = paddedShape - in.shape(), 
<a name="l01693"></a>01693           left = <a class="code" href="group__FixedPoint16Operations.html#gac71b069a80f6decdb6fad1cfd508f5f8" title="division with enforced result type.">div</a>(diff, <a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a>(2)),
<a name="l01694"></a>01694           right = in.shape() + left;
<a name="l01695"></a>01695           
<a name="l01696"></a>01696     <span class="keywordflow">if</span>(useFourierKernel)
<a name="l01697"></a>01697     {
<a name="l01698"></a>01698         vigra_precondition(kernel.shape() == fourierArray.shape(),
<a name="l01699"></a>01699            <span class="stringliteral">&quot;FFTWConvolvePlan::execute(): shape mismatch between kernel and plan.&quot;</span>);
<a name="l01700"></a>01700            
<a name="l01701"></a>01701         fourierKernel = kernel;
<a name="l01702"></a>01702         <a class="code" href="group__FourierTransform.html#gaee27c376079af99e8e2148e7d23ffbbb" title="Rearrange the quadrants of a Fourier image so that the origin is in the image&#39;s upper left...">moveDCToUpperLeft</a>(fourierKernel);
<a name="l01703"></a>01703     }
<a name="l01704"></a>01704     <span class="keywordflow">else</span>
<a name="l01705"></a>01705     {
<a name="l01706"></a>01706         detail::fftEmbedKernel(kernel, fourierKernel);
<a name="l01707"></a>01707         forward_plan.execute(fourierKernel, fourierKernel);
<a name="l01708"></a>01708     }
<a name="l01709"></a>01709 
<a name="l01710"></a>01710     detail::fftEmbedArray(in, fourierArray);
<a name="l01711"></a>01711     forward_plan.execute(fourierArray, fourierArray);
<a name="l01712"></a>01712 
<a name="l01713"></a>01713     fourierArray *= fourierKernel;
<a name="l01714"></a>01714     
<a name="l01715"></a>01715     backward_plan.execute(fourierArray, fourierArray);
<a name="l01716"></a>01716     
<a name="l01717"></a>01717     out = fourierArray.subarray(left, right);
<a name="l01718"></a>01718 }
<a name="l01719"></a>01719 
<a name="l01720"></a>01720 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real&gt;
<a name="l01721"></a>01721 <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> KernelIterator, <span class="keyword">class</span> OutIterator&gt;
<a name="l01722"></a>01722 <span class="keywordtype">void</span> 
<a name="l01723"></a>01723 FFTWConvolvePlan&lt;N, Real&gt;::executeManyImpl(MultiArrayView&lt;N, Real, C1&gt; in, 
<a name="l01724"></a>01724                                            KernelIterator kernels, KernelIterator kernelsEnd,
<a name="l01725"></a>01725                                            OutIterator outs, VigraFalseType <span class="comment">/*useFourierKernel*/</span>)
<a name="l01726"></a>01726 {
<a name="l01727"></a>01727     vigra_precondition(!useFourierKernel,
<a name="l01728"></a>01728        <span class="stringliteral">&quot;FFTWConvolvePlan::execute(): plan was generated for Fourier kernel, got spatial kernel.&quot;</span>);
<a name="l01729"></a>01729 
<a name="l01730"></a>01730     Shape kernelMax = checkShapes(in.shape(), kernels, kernelsEnd, outs),
<a name="l01731"></a>01731           paddedShape = fftwBestPaddedShapeR2C(in.shape() + kernelMax - Shape(1)),
<a name="l01732"></a>01732           diff = paddedShape - in.shape(), 
<a name="l01733"></a>01733           left = <a class="code" href="group__FixedPoint16Operations.html#gac71b069a80f6decdb6fad1cfd508f5f8" title="division with enforced result type.">div</a>(diff, <a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a>(2)),
<a name="l01734"></a>01734           right = in.shape() + left;
<a name="l01735"></a>01735           
<a name="l01736"></a>01736     vigra_precondition(paddedShape == realArray.shape(),
<a name="l01737"></a>01737        <span class="stringliteral">&quot;FFTWConvolvePlan::executeMany(): shape mismatch between input and plan.&quot;</span>);
<a name="l01738"></a>01738 
<a name="l01739"></a>01739     detail::fftEmbedArray(in, realArray);
<a name="l01740"></a>01740     forward_plan.execute(realArray, fourierArray);
<a name="l01741"></a>01741 
<a name="l01742"></a>01742     <span class="keywordflow">for</span>(; kernels != kernelsEnd; ++kernels, ++outs)
<a name="l01743"></a>01743     {
<a name="l01744"></a>01744         detail::fftEmbedKernel(*kernels, realKernel);
<a name="l01745"></a>01745         forward_plan.execute(realKernel, fourierKernel);
<a name="l01746"></a>01746         
<a name="l01747"></a>01747         fourierKernel *= fourierArray;
<a name="l01748"></a>01748         
<a name="l01749"></a>01749         backward_plan.execute(fourierKernel, realKernel);
<a name="l01750"></a>01750         
<a name="l01751"></a>01751         *outs = realKernel.subarray(left, right);
<a name="l01752"></a>01752     }
<a name="l01753"></a>01753 }
<a name="l01754"></a>01754 
<a name="l01755"></a>01755 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real&gt;
<a name="l01756"></a>01756 <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> KernelIterator, <span class="keyword">class</span> OutIterator&gt;
<a name="l01757"></a>01757 <span class="keywordtype">void</span> 
<a name="l01758"></a>01758 FFTWConvolvePlan&lt;N, Real&gt;::executeManyImpl(MultiArrayView&lt;N, Real, C1&gt; in, 
<a name="l01759"></a>01759                                            KernelIterator kernels, KernelIterator kernelsEnd,
<a name="l01760"></a>01760                                            OutIterator outs, VigraTrueType <span class="comment">/*useFourierKernel*/</span>)
<a name="l01761"></a>01761 {
<a name="l01762"></a>01762     vigra_precondition(useFourierKernel,
<a name="l01763"></a>01763        <span class="stringliteral">&quot;FFTWConvolvePlan::execute(): plan was generated for spatial kernel, got Fourier kernel.&quot;</span>);
<a name="l01764"></a>01764 
<a name="l01765"></a>01765     Shape complexShape = checkShapesFourier(in.shape(), kernels, kernelsEnd, outs),
<a name="l01766"></a>01766           paddedShape = fftwCorrespondingShapeC2R(complexShape, <a class="code" href="group__MathFunctions.html#ga48f661149941ebaa90ddd99ee5eee145" title="Check if an integer is odd.">odd</a>(in.shape(0))),
<a name="l01767"></a>01767           diff = paddedShape - in.shape(), 
<a name="l01768"></a>01768           left = <a class="code" href="group__FixedPoint16Operations.html#gac71b069a80f6decdb6fad1cfd508f5f8" title="division with enforced result type.">div</a>(diff, <a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a>(2)),
<a name="l01769"></a>01769           right = in.shape() + left;
<a name="l01770"></a>01770           
<a name="l01771"></a>01771     vigra_precondition(complexShape == fourierArray.shape(),
<a name="l01772"></a>01772        <span class="stringliteral">&quot;FFTWConvolvePlan::executeFourierKernelMany(): shape mismatch between kernels and plan.&quot;</span>);
<a name="l01773"></a>01773 
<a name="l01774"></a>01774     vigra_precondition(paddedShape == realArray.shape(),
<a name="l01775"></a>01775        <span class="stringliteral">&quot;FFTWConvolvePlan::executeFourierKernelMany(): shape mismatch between input and plan.&quot;</span>);
<a name="l01776"></a>01776 
<a name="l01777"></a>01777     detail::fftEmbedArray(in, realArray);
<a name="l01778"></a>01778     forward_plan.execute(realArray, fourierArray);
<a name="l01779"></a>01779 
<a name="l01780"></a>01780     <span class="keywordflow">for</span>(; kernels != kernelsEnd; ++kernels, ++outs)
<a name="l01781"></a>01781     {
<a name="l01782"></a>01782         fourierKernel = *kernels;
<a name="l01783"></a>01783         moveDCToHalfspaceUpperLeft(fourierKernel);
<a name="l01784"></a>01784         fourierKernel *= fourierArray;
<a name="l01785"></a>01785         
<a name="l01786"></a>01786         backward_plan.execute(fourierKernel, realKernel);
<a name="l01787"></a>01787         
<a name="l01788"></a>01788         *outs = realKernel.subarray(left, right);
<a name="l01789"></a>01789     }
<a name="l01790"></a>01790 }
<a name="l01791"></a>01791 
<a name="l01792"></a>01792 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real&gt;
<a name="l01793"></a>01793 <span class="keyword">template</span> &lt;<span class="keyword">class</span> C1, <span class="keyword">class</span> KernelIterator, <span class="keyword">class</span> OutIterator&gt;
<a name="l01794"></a>01794 <span class="keywordtype">void</span> 
<a name="l01795"></a>01795 <a class="code" href="classvigra_1_1FFTWConvolvePlan.html#a8a6e128726ee1662ba1b75f562e63148" title="Execute a plan to convolve a complex array with a sequence of kernels.">FFTWConvolvePlan&lt;N, Real&gt;::executeMany</a>(MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C1&gt; in, 
<a name="l01796"></a>01796                                        KernelIterator kernels, KernelIterator kernelsEnd,
<a name="l01797"></a>01797                                        OutIterator outs)
<a name="l01798"></a>01798 {
<a name="l01799"></a>01799     <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;KernelIterator&gt;::value_type KernelArray;
<a name="l01800"></a>01800     <span class="keyword">typedef</span> <span class="keyword">typename</span> KernelArray::value_type KernelValue;
<a name="l01801"></a>01801     <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;OutIterator&gt;::value_type OutArray;
<a name="l01802"></a>01802     <span class="keyword">typedef</span> <span class="keyword">typename</span> OutArray::value_type OutValue;
<a name="l01803"></a>01803 
<a name="l01804"></a>01804     vigra_precondition((IsSameType&lt;KernelValue, Complex&gt;::value),
<a name="l01805"></a>01805          <span class="stringliteral">&quot;FFTWConvolvePlan::executeMany(): kernels have unsuitable value_type.&quot;</span>);
<a name="l01806"></a>01806     vigra_precondition((IsSameType&lt;OutValue, Complex&gt;::value),
<a name="l01807"></a>01807          <span class="stringliteral">&quot;FFTWConvolvePlan::executeMany(): outputs have unsuitable value_type.&quot;</span>);
<a name="l01808"></a>01808 
<a name="l01809"></a>01809     Shape paddedShape = checkShapesComplex(in.shape(), kernels, kernelsEnd, outs),
<a name="l01810"></a>01810           diff = paddedShape - in.shape(), 
<a name="l01811"></a>01811           left = <a class="code" href="group__FixedPoint16Operations.html#gac71b069a80f6decdb6fad1cfd508f5f8" title="division with enforced result type.">div</a>(diff, <a class="code" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a>(2)),
<a name="l01812"></a>01812           right = in.shape() + left;
<a name="l01813"></a>01813           
<a name="l01814"></a>01814     detail::fftEmbedArray(in, fourierArray);
<a name="l01815"></a>01815     forward_plan.execute(fourierArray, fourierArray);
<a name="l01816"></a>01816 
<a name="l01817"></a>01817     <span class="keywordflow">for</span>(; kernels != kernelsEnd; ++kernels, ++outs)
<a name="l01818"></a>01818     {
<a name="l01819"></a>01819         <span class="keywordflow">if</span>(useFourierKernel)
<a name="l01820"></a>01820         {
<a name="l01821"></a>01821             fourierKernel = *kernels;
<a name="l01822"></a>01822             <a class="code" href="group__FourierTransform.html#gaee27c376079af99e8e2148e7d23ffbbb" title="Rearrange the quadrants of a Fourier image so that the origin is in the image&#39;s upper left...">moveDCToUpperLeft</a>(fourierKernel);
<a name="l01823"></a>01823         }
<a name="l01824"></a>01824         <span class="keywordflow">else</span>
<a name="l01825"></a>01825         {
<a name="l01826"></a>01826             detail::fftEmbedKernel(*kernels, fourierKernel);
<a name="l01827"></a>01827             forward_plan.execute(fourierKernel, fourierKernel);
<a name="l01828"></a>01828         }
<a name="l01829"></a>01829 
<a name="l01830"></a>01830         fourierKernel *= fourierArray;
<a name="l01831"></a>01831         
<a name="l01832"></a>01832         backward_plan.execute(fourierKernel, fourierKernel);
<a name="l01833"></a>01833         
<a name="l01834"></a>01834         *outs = fourierKernel.subarray(left, right);
<a name="l01835"></a>01835     }
<a name="l01836"></a>01836 }
<a name="l01837"></a>01837 
<a name="l01838"></a>01838 <span class="preprocessor">#endif // DOXYGEN</span>
<a name="l01839"></a>01839 <span class="preprocessor"></span>
<a name="l01840"></a>01840 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real&gt;
<a name="l01841"></a>01841 <span class="keyword">template</span> &lt;<span class="keyword">class</span> KernelIterator, <span class="keyword">class</span> OutIterator&gt;
<a name="l01842"></a>01842 <span class="keyword">typename</span> FFTWConvolvePlan&lt;N, Real&gt;::Shape 
<a name="l01843"></a>01843 FFTWConvolvePlan&lt;N, Real&gt;::checkShapes(Shape in, 
<a name="l01844"></a>01844                                        KernelIterator kernels, KernelIterator kernelsEnd,
<a name="l01845"></a>01845                                        OutIterator outs)
<a name="l01846"></a>01846 {
<a name="l01847"></a>01847     vigra_precondition(kernels != kernelsEnd,
<a name="l01848"></a>01848         <span class="stringliteral">&quot;FFTWConvolvePlan::checkShapes(): empty kernel sequence.&quot;</span>);
<a name="l01849"></a>01849 
<a name="l01850"></a>01850     Shape kernelMax;            
<a name="l01851"></a>01851     <span class="keywordflow">for</span>(; kernels != kernelsEnd; ++kernels, ++outs)
<a name="l01852"></a>01852     {
<a name="l01853"></a>01853         vigra_precondition(in == outs-&gt;shape(),
<a name="l01854"></a>01854             <span class="stringliteral">&quot;FFTWConvolvePlan::checkShapes(): shape mismatch between input and (one) output.&quot;</span>);
<a name="l01855"></a>01855         kernelMax = max(kernelMax, kernels-&gt;shape());
<a name="l01856"></a>01856     }
<a name="l01857"></a>01857     vigra_precondition(<a class="code" href="group__TinyVectorOperators.html#gaa49e08e69b54385f9434ffe32a32f299" title="product of the vector&#39;s elements">prod</a>(kernelMax) &gt; 0,
<a name="l01858"></a>01858         <span class="stringliteral">&quot;FFTWConvolvePlan::checkShapes(): all kernels have size 0.&quot;</span>);
<a name="l01859"></a>01859     <span class="keywordflow">return</span> kernelMax;
<a name="l01860"></a>01860 }
<a name="l01861"></a>01861  
<a name="l01862"></a>01862 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real&gt;
<a name="l01863"></a>01863 <span class="keyword">template</span> &lt;<span class="keyword">class</span> KernelIterator, <span class="keyword">class</span> OutIterator&gt;
<a name="l01864"></a>01864 <span class="keyword">typename</span> FFTWConvolvePlan&lt;N, Real&gt;::Shape 
<a name="l01865"></a>01865 FFTWConvolvePlan&lt;N, Real&gt;::checkShapesFourier(Shape in, 
<a name="l01866"></a>01866                                                KernelIterator kernels, KernelIterator kernelsEnd,
<a name="l01867"></a>01867                                                OutIterator outs)
<a name="l01868"></a>01868 {
<a name="l01869"></a>01869     vigra_precondition(kernels != kernelsEnd,
<a name="l01870"></a>01870         <span class="stringliteral">&quot;FFTWConvolvePlan::checkShapesFourier(): empty kernel sequence.&quot;</span>);
<a name="l01871"></a>01871 
<a name="l01872"></a>01872     Shape complexShape = kernels-&gt;shape(),
<a name="l01873"></a>01873           paddedShape  = fftwCorrespondingShapeC2R(complexShape);
<a name="l01874"></a>01874 
<a name="l01875"></a>01875     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;N; ++k)
<a name="l01876"></a>01876         vigra_precondition(in[k] &lt;= paddedShape[k],
<a name="l01877"></a>01877              <span class="stringliteral">&quot;FFTWConvolvePlan::checkShapesFourier(): kernels too small for given input.&quot;</span>);
<a name="l01878"></a>01878 
<a name="l01879"></a>01879     <span class="keywordflow">for</span>(; kernels != kernelsEnd; ++kernels, ++outs)
<a name="l01880"></a>01880     {
<a name="l01881"></a>01881         vigra_precondition(in == outs-&gt;shape(),
<a name="l01882"></a>01882             <span class="stringliteral">&quot;FFTWConvolvePlan::checkShapesFourier(): shape mismatch between input and (one) output.&quot;</span>);
<a name="l01883"></a>01883         vigra_precondition(complexShape == kernels-&gt;shape(),
<a name="l01884"></a>01884             <span class="stringliteral">&quot;FFTWConvolvePlan::checkShapesFourier(): all kernels must have the same size.&quot;</span>);
<a name="l01885"></a>01885     }
<a name="l01886"></a>01886     <span class="keywordflow">return</span> complexShape;
<a name="l01887"></a>01887 }
<a name="l01888"></a>01888 
<a name="l01889"></a>01889 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real&gt;
<a name="l01890"></a>01890 <span class="keyword">template</span> &lt;<span class="keyword">class</span> KernelIterator, <span class="keyword">class</span> OutIterator&gt;
<a name="l01891"></a>01891 <span class="keyword">typename</span> FFTWConvolvePlan&lt;N, Real&gt;::Shape 
<a name="l01892"></a>01892 FFTWConvolvePlan&lt;N, Real&gt;::checkShapesComplex(Shape in, 
<a name="l01893"></a>01893                                                KernelIterator kernels, KernelIterator kernelsEnd,
<a name="l01894"></a>01894                                                OutIterator outs)
<a name="l01895"></a>01895 {
<a name="l01896"></a>01896     vigra_precondition(kernels != kernelsEnd,
<a name="l01897"></a>01897         <span class="stringliteral">&quot;FFTWConvolvePlan::checkShapesComplex(): empty kernel sequence.&quot;</span>);
<a name="l01898"></a>01898 
<a name="l01899"></a>01899     Shape kernelShape = kernels-&gt;shape();            
<a name="l01900"></a>01900     <span class="keywordflow">for</span>(; kernels != kernelsEnd; ++kernels, ++outs)
<a name="l01901"></a>01901     {
<a name="l01902"></a>01902         vigra_precondition(in == outs-&gt;shape(),
<a name="l01903"></a>01903             <span class="stringliteral">&quot;FFTWConvolvePlan::checkShapesComplex(): shape mismatch between input and (one) output.&quot;</span>);
<a name="l01904"></a>01904         <span class="keywordflow">if</span>(useFourierKernel)
<a name="l01905"></a>01905         {
<a name="l01906"></a>01906             vigra_precondition(kernelShape == kernels-&gt;shape(),
<a name="l01907"></a>01907                 <span class="stringliteral">&quot;FFTWConvolvePlan::checkShapesComplex(): Fourier domain kernels must have identical size.&quot;</span>);
<a name="l01908"></a>01908         }
<a name="l01909"></a>01909         <span class="keywordflow">else</span>
<a name="l01910"></a>01910         {
<a name="l01911"></a>01911             kernelShape = max(kernelShape, kernels-&gt;shape());
<a name="l01912"></a>01912         }
<a name="l01913"></a>01913     }
<a name="l01914"></a>01914     vigra_precondition(<a class="code" href="group__TinyVectorOperators.html#gaa49e08e69b54385f9434ffe32a32f299" title="product of the vector&#39;s elements">prod</a>(kernelShape) &gt; 0,
<a name="l01915"></a>01915         <span class="stringliteral">&quot;FFTWConvolvePlan::checkShapesComplex(): all kernels have size 0.&quot;</span>);
<a name="l01916"></a>01916         
<a name="l01917"></a>01917     <span class="keywordflow">if</span>(useFourierKernel)
<a name="l01918"></a>01918     {
<a name="l01919"></a>01919         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;N; ++k)
<a name="l01920"></a>01920             vigra_precondition(in[k] &lt;= kernelShape[k],
<a name="l01921"></a>01921                  <span class="stringliteral">&quot;FFTWConvolvePlan::checkShapesComplex(): kernels too small for given input.&quot;</span>);
<a name="l01922"></a>01922         <span class="keywordflow">return</span> kernelShape;
<a name="l01923"></a>01923     }
<a name="l01924"></a>01924     <span class="keywordflow">else</span>
<a name="l01925"></a>01925     {
<a name="l01926"></a>01926         <span class="keywordflow">return</span> fftwBestPaddedShape(in + kernelShape - Shape(1));
<a name="l01927"></a>01927     }
<a name="l01928"></a>01928 }
<a name="l01929"></a>01929  
<a name="l01930"></a>01930 
<a name="l01931"></a>01931 <span class="comment">/********************************************************/</span>
<a name="l01932"></a>01932 <span class="comment">/*                                                      */</span>
<a name="l01933"></a>01933 <span class="comment">/*                   fourierTransform                   */</span>
<a name="l01934"></a>01934 <span class="comment">/*                                                      */</span>
<a name="l01935"></a>01935 <span class="comment">/********************************************************/</span>
<a name="l01936"></a>01936 
<a name="l01937"></a>01937 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2&gt;
<a name="l01938"></a>01938 <span class="keyword">inline</span> <span class="keywordtype">void</span> 
<a name="l01939"></a>01939 <a class="code" href="group__FourierTransform.html#gadd9dce5cef45cda228466002d00a0666" title="Compute forward and inverse Fourier transforms.">fourierTransform</a>(MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C1&gt; in, 
<a name="l01940"></a>01940                  MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C2&gt; out)
<a name="l01941"></a>01941 {
<a name="l01942"></a>01942     FFTWPlan&lt;N, Real&gt;(in, out, FFTW_FORWARD).execute(in, out);
<a name="l01943"></a>01943 }
<a name="l01944"></a>01944 
<a name="l01945"></a>01945 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2&gt;
<a name="l01946"></a>01946 <span class="keyword">inline</span> <span class="keywordtype">void</span> 
<a name="l01947"></a>01947 <a class="code" href="group__FourierTransform.html#ga478712099cf479694c81ccc5918aca73" title="Compute inverse Fourier transforms.">fourierTransformInverse</a>(MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C1&gt; in, 
<a name="l01948"></a>01948                         MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C2&gt; out)
<a name="l01949"></a>01949 {
<a name="l01950"></a>01950     FFTWPlan&lt;N, Real&gt;(in, out, FFTW_BACKWARD).execute(in, out);
<a name="l01951"></a>01951 }
<a name="l01952"></a>01952 
<a name="l01953"></a>01953 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2&gt;
<a name="l01954"></a>01954 <span class="keywordtype">void</span> 
<a name="l01955"></a>01955 <a class="code" href="group__FourierTransform.html#gadd9dce5cef45cda228466002d00a0666" title="Compute forward and inverse Fourier transforms.">fourierTransform</a>(MultiArrayView&lt;N, Real, C1&gt; in, 
<a name="l01956"></a>01956                  MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C2&gt; out)
<a name="l01957"></a>01957 {
<a name="l01958"></a>01958     <span class="keywordflow">if</span>(in.shape() == out.shape())
<a name="l01959"></a>01959     {
<a name="l01960"></a>01960         <span class="comment">// copy the input array into the output and then perform an in-place FFT</span>
<a name="l01961"></a>01961         out = in;
<a name="l01962"></a>01962         FFTWPlan&lt;N, Real&gt;(out, out, FFTW_FORWARD).execute(out, out);
<a name="l01963"></a>01963     }
<a name="l01964"></a>01964     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(out.shape() == <a class="code" href="group__FourierTransform.html#gafbea828444f49163293b1d81fcd05da8" title="Find frequency domain shape for a R2C Fourier transform.">fftwCorrespondingShapeR2C</a>(in.shape()))
<a name="l01965"></a>01965     {
<a name="l01966"></a>01966         FFTWPlan&lt;N, Real&gt;(in, out).execute(in, out);
<a name="l01967"></a>01967     }
<a name="l01968"></a>01968     <span class="keywordflow">else</span>
<a name="l01969"></a>01969         vigra_precondition(<span class="keyword">false</span>,
<a name="l01970"></a>01970             <span class="stringliteral">&quot;fourierTransform(): shape mismatch between input and output.&quot;</span>);
<a name="l01971"></a>01971 }
<a name="l01972"></a>01972 
<a name="l01973"></a>01973 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2&gt;
<a name="l01974"></a>01974 <span class="keywordtype">void</span> 
<a name="l01975"></a>01975 <a class="code" href="group__FourierTransform.html#ga478712099cf479694c81ccc5918aca73" title="Compute inverse Fourier transforms.">fourierTransformInverse</a>(MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C1&gt; in, 
<a name="l01976"></a>01976                         MultiArrayView&lt;N, Real, C2&gt; out)
<a name="l01977"></a>01977 {
<a name="l01978"></a>01978     vigra_precondition(in.shape() == <a class="code" href="group__FourierTransform.html#gafbea828444f49163293b1d81fcd05da8" title="Find frequency domain shape for a R2C Fourier transform.">fftwCorrespondingShapeR2C</a>(out.shape()),
<a name="l01979"></a>01979         <span class="stringliteral">&quot;fourierTransformInverse(): shape mismatch between input and output.&quot;</span>);
<a name="l01980"></a>01980     FFTWPlan&lt;N, Real&gt;(in, out).execute(in, out);
<a name="l01981"></a>01981 }
<a name="l01982"></a>01982 <span class="comment"></span>
<a name="l01983"></a>01983 <span class="comment">//@}</span>
<a name="l01984"></a>01984 <span class="comment"></span><span class="comment"></span>
<a name="l01985"></a>01985 <span class="comment">/** \addtogroup MultiArrayConvolutionFilters</span>
<a name="l01986"></a>01986 <span class="comment">*/</span><span class="comment"></span>
<a name="l01987"></a>01987 <span class="comment">//@{</span>
<a name="l01988"></a>01988 <span class="comment"></span>
<a name="l01989"></a>01989 <span class="comment">/********************************************************/</span>
<a name="l01990"></a>01990 <span class="comment">/*                                                      */</span>
<a name="l01991"></a>01991 <span class="comment">/*                     convolveFFT                      */</span>
<a name="l01992"></a>01992 <span class="comment">/*                                                      */</span>
<a name="l01993"></a>01993 <span class="comment">/********************************************************/</span>
<a name="l01994"></a>01994 <span class="comment"></span>
<a name="l01995"></a>01995 <span class="comment">/** \brief Convolve an array with a kernel by means of the Fourier transform.</span>
<a name="l01996"></a>01996 <span class="comment"></span>
<a name="l01997"></a>01997 <span class="comment">    Thanks to the convolution theorem of Fourier theory, a convolution in the spatial domain</span>
<a name="l01998"></a>01998 <span class="comment">    is equivalent to a multiplication in the frequency domain. Thus, for certain kernels</span>
<a name="l01999"></a>01999 <span class="comment">    (especially large, non-separable ones), it is advantageous to perform the convolution by first</span>
<a name="l02000"></a>02000 <span class="comment">    transforming both array and kernel to the frequency domain, multiplying the frequency </span>
<a name="l02001"></a>02001 <span class="comment">    representations, and transforming the result back into the spatial domain. </span>
<a name="l02002"></a>02002 <span class="comment">    Some kernels have a much simpler definition in the frequency domain, so that they are readily </span>
<a name="l02003"></a>02003 <span class="comment">    computed there directly, avoiding Fourier transformation of those kernels. </span>
<a name="l02004"></a>02004 <span class="comment">    </span>
<a name="l02005"></a>02005 <span class="comment">    The following functions implement various variants of FFT-based convolution:</span>
<a name="l02006"></a>02006 <span class="comment">    </span>
<a name="l02007"></a>02007 <span class="comment">        &lt;DL&gt;</span>
<a name="l02008"></a>02008 <span class="comment">        &lt;DT&gt;&lt;b&gt;convolveFFT&lt;/b&gt;&lt;DD&gt; Convolve a real-valued input array with a kernel such that the </span>
<a name="l02009"></a>02009 <span class="comment">                            result is also real-valued. That is, the kernel is either provided</span>
<a name="l02010"></a>02010 <span class="comment">                            as a real-valued array in the spatial domain, or as a </span>
<a name="l02011"></a>02011 <span class="comment">                            complex-valued array in the Fourier domain, using the half-space format </span>
<a name="l02012"></a>02012 <span class="comment">                            of the R2C Fourier transform (see below).</span>
<a name="l02013"></a>02013 <span class="comment">        &lt;DT&gt;&lt;b&gt;convolveFFTMany&lt;/b&gt;&lt;DD&gt; Like &lt;tt&gt;convolveFFT&lt;/tt&gt;, but you may provide many kernels at once </span>
<a name="l02014"></a>02014 <span class="comment">                            (using an iterator pair specifying the kernel sequence). </span>
<a name="l02015"></a>02015 <span class="comment">                            This has the advantage that the forward transform of the input array needs </span>
<a name="l02016"></a>02016 <span class="comment">                            to be executed only once.</span>
<a name="l02017"></a>02017 <span class="comment">        &lt;DT&gt;&lt;b&gt;convolveFFTComplex&lt;/b&gt;&lt;DD&gt; Convolve a complex-valued input array with a complex-valued kernel, </span>
<a name="l02018"></a>02018 <span class="comment">                            resulting in a complex-valued output array. An additional flag is used to </span>
<a name="l02019"></a>02019 <span class="comment">                            specify whether the kernel is defined in the spatial or frequency domain.</span>
<a name="l02020"></a>02020 <span class="comment">        &lt;DT&gt;&lt;b&gt;convolveFFTComplexMany&lt;/b&gt;&lt;DD&gt; Like &lt;tt&gt;convolveFFTComplex&lt;/tt&gt;, but you may provide many kernels at once </span>
<a name="l02021"></a>02021 <span class="comment">                            (using an iterator pair specifying the kernel sequence). </span>
<a name="l02022"></a>02022 <span class="comment">                            This has the advantage that the forward transform of the input array needs </span>
<a name="l02023"></a>02023 <span class="comment">                            to be executed only once.</span>
<a name="l02024"></a>02024 <span class="comment">        &lt;/DL&gt;</span>
<a name="l02025"></a>02025 <span class="comment">    </span>
<a name="l02026"></a>02026 <span class="comment">    The output arrays must have the same shape as the input arrays. In the &quot;Many&quot; variants of the</span>
<a name="l02027"></a>02027 <span class="comment">    convolution functions, the kernels must all have the same shape.</span>
<a name="l02028"></a>02028 <span class="comment">    </span>
<a name="l02029"></a>02029 <span class="comment">    The origin of the kernel is always assumed to be in the center of the kernel array (precisely,</span>
<a name="l02030"></a>02030 <span class="comment">    at the point &lt;tt&gt;floor(kernel.shape() / 2.0)&lt;/tt&gt;, except when the half-space format is used, see below). </span>
<a name="l02031"></a>02031 <span class="comment">    The function \ref moveDCToUpperLeft() will be called internally to align the kernel with the transformed </span>
<a name="l02032"></a>02032 <span class="comment">    input as appropriate.</span>
<a name="l02033"></a>02033 <span class="comment">    </span>
<a name="l02034"></a>02034 <span class="comment">    If a real input is combined with a real kernel, the kernel is automatically assumed to be defined</span>
<a name="l02035"></a>02035 <span class="comment">    in the spatial domain. If a real input is combined with a complex kernel, the kernel is assumed </span>
<a name="l02036"></a>02036 <span class="comment">    to be defined in the Fourier domain in half-space format. If the input array is complex, a flag </span>
<a name="l02037"></a>02037 <span class="comment">    &lt;tt&gt;fourierDomainKernel&lt;/tt&gt; determines where the kernel is defined.</span>
<a name="l02038"></a>02038 <span class="comment">    </span>
<a name="l02039"></a>02039 <span class="comment">    When the kernel is defined in the spatial domain, the convolution functions will automatically pad</span>
<a name="l02040"></a>02040 <span class="comment">    (enlarge) the input array by at least the kernel radius in each direction. The newly added space is</span>
<a name="l02041"></a>02041 <span class="comment">    filled according to reflective boundary conditions in order to minimize border artifacts during </span>
<a name="l02042"></a>02042 <span class="comment">    convolution. It is thus ensured that convolution in the Fourier domain yields the same results as </span>
<a name="l02043"></a>02043 <span class="comment">    convolution in the spatial domain (e.g. when \ref separableConvolveMultiArray() is called with the </span>
<a name="l02044"></a>02044 <span class="comment">    same kernel). A little further padding may be added to make sure that the padded array shape</span>
<a name="l02045"></a>02045 <span class="comment">    uses integers which have only small prime factors, because FFTW is then able to use the fastest</span>
<a name="l02046"></a>02046 <span class="comment">    possible algorithms. Any padding is automatically removed from the result arrays before the function</span>
<a name="l02047"></a>02047 <span class="comment">    returns.</span>
<a name="l02048"></a>02048 <span class="comment">    </span>
<a name="l02049"></a>02049 <span class="comment">    When the kernel is defined in the frequency domain, it must be complex-valued, and its shape determines</span>
<a name="l02050"></a>02050 <span class="comment">    the shape of the Fourier representation (i.e. the input is padded according to the shape of the kernel).</span>
<a name="l02051"></a>02051 <span class="comment">    If we are going to perform a complex-valued convolution, the kernel must be defined for the entire </span>
<a name="l02052"></a>02052 <span class="comment">    frequency domain, and its shape directly determines the size of the FFT. </span>
<a name="l02053"></a>02053 <span class="comment">    </span>
<a name="l02054"></a>02054 <span class="comment">    In contrast, a frequency domain kernel for a real-valued convolution must have symmetry properties</span>
<a name="l02055"></a>02055 <span class="comment">    that allow to drop half of the kernel coefficients, as in the </span>
<a name="l02056"></a>02056 <span class="comment">    &lt;a href=&quot;http://www.fftw.org/doc/Multi_002dDimensional-DFTs-of-Real-Data.html&quot;&gt;R2C transform&lt;/a&gt;. </span>
<a name="l02057"></a>02057 <span class="comment">    That is, the kernel must have the &lt;i&gt;half-space format&lt;/i&gt;, that is the shape returned by &lt;tt&gt;fftwCorrespondingShapeR2C(fourier_shape)&lt;/tt&gt;, where &lt;tt&gt;fourier_shape&lt;/tt&gt; is the desired </span>
<a name="l02058"></a>02058 <span class="comment">    logical shape of the frequency representation (and thus the size of the padded input). The origin </span>
<a name="l02059"></a>02059 <span class="comment">    of the kernel must be at the point </span>
<a name="l02060"></a>02060 <span class="comment">    &lt;tt&gt;(0, floor(fourier_shape[0] / 2.0), ..., floor(fourier_shape[N-1] / 2.0))&lt;/tt&gt; </span>
<a name="l02061"></a>02061 <span class="comment">    (i.e. as in a regular kernel except for the first dimension).</span>
<a name="l02062"></a>02062 <span class="comment">    </span>
<a name="l02063"></a>02063 <span class="comment">    The &lt;tt&gt;Real&lt;/tt&gt; type in the declarations can be &lt;tt&gt;double&lt;/tt&gt;, &lt;tt&gt;float&lt;/tt&gt;, and </span>
<a name="l02064"></a>02064 <span class="comment">    &lt;tt&gt;long double&lt;/tt&gt;. Your program must always link against &lt;tt&gt;libfftw3&lt;/tt&gt;. If you use</span>
<a name="l02065"></a>02065 <span class="comment">    &lt;tt&gt;float&lt;/tt&gt; or &lt;tt&gt;long double&lt;/tt&gt; arrays, you must &lt;i&gt;additionally&lt;/i&gt; link against </span>
<a name="l02066"></a>02066 <span class="comment">    &lt;tt&gt;libfftw3f&lt;/tt&gt; and &lt;tt&gt;libfftw3l&lt;/tt&gt; respectively.</span>
<a name="l02067"></a>02067 <span class="comment">    </span>
<a name="l02068"></a>02068 <span class="comment">    The Fourier transform functions internally create &lt;a href=&quot;http://www.fftw.org/doc/Using-Plans.html&quot;&gt;FFTW plans&lt;/a&gt;</span>
<a name="l02069"></a>02069 <span class="comment">    which control the algorithm details. The plans are creates with the flag &lt;tt&gt;FFTW_ESTIMATE&lt;/tt&gt;, i.e.</span>
<a name="l02070"></a>02070 <span class="comment">    optimal settings are guessed or read from saved &quot;wisdom&quot; files. If you need more control over planning,</span>
<a name="l02071"></a>02071 <span class="comment">    you can use the class \ref FFTWConvolvePlan.</span>
<a name="l02072"></a>02072 <span class="comment">    </span>
<a name="l02073"></a>02073 <span class="comment">    See also \ref applyFourierFilter() for corresponding functionality on the basis of the</span>
<a name="l02074"></a>02074 <span class="comment">    old image iterator interface.</span>
<a name="l02075"></a>02075 <span class="comment">    </span>
<a name="l02076"></a>02076 <span class="comment">    &lt;b&gt; Declarations:&lt;/b&gt;</span>
<a name="l02077"></a>02077 <span class="comment"></span>
<a name="l02078"></a>02078 <span class="comment">    Real-valued convolution with kernel in the spatial domain:</span>
<a name="l02079"></a>02079 <span class="comment">    \code</span>
<a name="l02080"></a>02080 <span class="comment">    namespace vigra {</span>
<a name="l02081"></a>02081 <span class="comment">        template &lt;unsigned int N, class Real, class C1, class C2, class C3&gt;</span>
<a name="l02082"></a>02082 <span class="comment">        void </span>
<a name="l02083"></a>02083 <span class="comment">        convolveFFT(MultiArrayView&lt;N, Real, C1&gt; in, </span>
<a name="l02084"></a>02084 <span class="comment">                    MultiArrayView&lt;N, Real, C2&gt; kernel,</span>
<a name="l02085"></a>02085 <span class="comment">                    MultiArrayView&lt;N, Real, C3&gt; out);</span>
<a name="l02086"></a>02086 <span class="comment">    }</span>
<a name="l02087"></a>02087 <span class="comment">    \endcode</span>
<a name="l02088"></a>02088 <span class="comment"></span>
<a name="l02089"></a>02089 <span class="comment">    Real-valued convolution with kernel in the Fourier domain (half-space format):</span>
<a name="l02090"></a>02090 <span class="comment">    \code</span>
<a name="l02091"></a>02091 <span class="comment">    namespace vigra {</span>
<a name="l02092"></a>02092 <span class="comment">        template &lt;unsigned int N, class Real, class C1, class C2, class C3&gt;</span>
<a name="l02093"></a>02093 <span class="comment">        void </span>
<a name="l02094"></a>02094 <span class="comment">        convolveFFT(MultiArrayView&lt;N, Real, C1&gt; in, </span>
<a name="l02095"></a>02095 <span class="comment">                    MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C2&gt; kernel,</span>
<a name="l02096"></a>02096 <span class="comment">                    MultiArrayView&lt;N, Real, C3&gt; out);</span>
<a name="l02097"></a>02097 <span class="comment">    }</span>
<a name="l02098"></a>02098 <span class="comment">    \endcode</span>
<a name="l02099"></a>02099 <span class="comment"></span>
<a name="l02100"></a>02100 <span class="comment">    Series of real-valued convolutions with kernels in the spatial or Fourier domain </span>
<a name="l02101"></a>02101 <span class="comment">    (the kernel and out sequences must have the same length):</span>
<a name="l02102"></a>02102 <span class="comment">    \code</span>
<a name="l02103"></a>02103 <span class="comment">    namespace vigra {</span>
<a name="l02104"></a>02104 <span class="comment">        template &lt;unsigned int N, class Real, class C1, </span>
<a name="l02105"></a>02105 <span class="comment">                  class KernelIterator, class OutIterator&gt;</span>
<a name="l02106"></a>02106 <span class="comment">        void </span>
<a name="l02107"></a>02107 <span class="comment">        convolveFFTMany(MultiArrayView&lt;N, Real, C1&gt; in, </span>
<a name="l02108"></a>02108 <span class="comment">                        KernelIterator kernels, KernelIterator kernelsEnd,</span>
<a name="l02109"></a>02109 <span class="comment">                        OutIterator outs);</span>
<a name="l02110"></a>02110 <span class="comment">    }</span>
<a name="l02111"></a>02111 <span class="comment">    \endcode</span>
<a name="l02112"></a>02112 <span class="comment"></span>
<a name="l02113"></a>02113 <span class="comment">    Complex-valued convolution (parameter &lt;tt&gt;fourierDomainKernel&lt;/tt&gt; determines if</span>
<a name="l02114"></a>02114 <span class="comment">    the kernel is defined in the spatial or Fourier domain):</span>
<a name="l02115"></a>02115 <span class="comment">    \code</span>
<a name="l02116"></a>02116 <span class="comment">    namespace vigra {</span>
<a name="l02117"></a>02117 <span class="comment">        template &lt;unsigned int N, class Real, class C1, class C2, class C3&gt;</span>
<a name="l02118"></a>02118 <span class="comment">        void</span>
<a name="l02119"></a>02119 <span class="comment">        convolveFFTComplex(MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C1&gt; in,</span>
<a name="l02120"></a>02120 <span class="comment">                           MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C2&gt; kernel,</span>
<a name="l02121"></a>02121 <span class="comment">                           MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C3&gt; out,</span>
<a name="l02122"></a>02122 <span class="comment">                           bool fourierDomainKernel);</span>
<a name="l02123"></a>02123 <span class="comment">    }</span>
<a name="l02124"></a>02124 <span class="comment">    \endcode</span>
<a name="l02125"></a>02125 <span class="comment"></span>
<a name="l02126"></a>02126 <span class="comment">    Series of complex-valued convolutions (parameter &lt;tt&gt;fourierDomainKernel&lt;/tt&gt; </span>
<a name="l02127"></a>02127 <span class="comment">    determines if the kernels are defined in the spatial or Fourier domain, </span>
<a name="l02128"></a>02128 <span class="comment">    the kernel and out sequences must have the same length):</span>
<a name="l02129"></a>02129 <span class="comment">    \code</span>
<a name="l02130"></a>02130 <span class="comment">    namespace vigra {</span>
<a name="l02131"></a>02131 <span class="comment">        template &lt;unsigned int N, class Real, class C1, </span>
<a name="l02132"></a>02132 <span class="comment">                  class KernelIterator, class OutIterator&gt;</span>
<a name="l02133"></a>02133 <span class="comment">        void </span>
<a name="l02134"></a>02134 <span class="comment">        convolveFFTComplexMany(MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C1&gt; in, </span>
<a name="l02135"></a>02135 <span class="comment">                               KernelIterator kernels, KernelIterator kernelsEnd,</span>
<a name="l02136"></a>02136 <span class="comment">                               OutIterator outs,</span>
<a name="l02137"></a>02137 <span class="comment">                               bool fourierDomainKernel);</span>
<a name="l02138"></a>02138 <span class="comment">    }</span>
<a name="l02139"></a>02139 <span class="comment">    \endcode</span>
<a name="l02140"></a>02140 <span class="comment"></span>
<a name="l02141"></a>02141 <span class="comment">    &lt;b&gt; Usage:&lt;/b&gt;</span>
<a name="l02142"></a>02142 <span class="comment"></span>
<a name="l02143"></a>02143 <span class="comment">    &lt;b&gt;\#include&lt;/b&gt; &lt;vigra/multi_fft.hxx&gt;&lt;br&gt;</span>
<a name="l02144"></a>02144 <span class="comment">    Namespace: vigra</span>
<a name="l02145"></a>02145 <span class="comment"></span>
<a name="l02146"></a>02146 <span class="comment">    \code</span>
<a name="l02147"></a>02147 <span class="comment">    // convolve real array with a Gaussian (sigma=1) defined in the spatial domain</span>
<a name="l02148"></a>02148 <span class="comment">    // (implicitly uses padding by at least 4 pixels)</span>
<a name="l02149"></a>02149 <span class="comment">    MultiArray&lt;2, double&gt; src(Shape2(w, h)), dest(Shape2(w,h));</span>
<a name="l02150"></a>02150 <span class="comment">    </span>
<a name="l02151"></a>02151 <span class="comment">    MultiArray&lt;2, double&gt; spatial_kernel(Shape2(9, 9));</span>
<a name="l02152"></a>02152 <span class="comment">    Gaussian&lt;double&gt; gauss(1.0);</span>
<a name="l02153"></a>02153 <span class="comment">    </span>
<a name="l02154"></a>02154 <span class="comment">    for(int y=0; y&lt;9; ++y)</span>
<a name="l02155"></a>02155 <span class="comment">        for(int x=0; x&lt;9; ++x)</span>
<a name="l02156"></a>02156 <span class="comment">            spatial_kernel(x, y) = gauss(x-4.0)*gauss(y-4.0);</span>
<a name="l02157"></a>02157 <span class="comment"></span>
<a name="l02158"></a>02158 <span class="comment">    convolveFFT(src, spatial_kernel, dest);</span>
<a name="l02159"></a>02159 <span class="comment">    </span>
<a name="l02160"></a>02160 <span class="comment">    // convolve real array with a Gaussian (sigma=1) defined in the Fourier domain</span>
<a name="l02161"></a>02161 <span class="comment">    // (uses no padding, because the kernel size corresponds to the input size)</span>
<a name="l02162"></a>02162 <span class="comment">    MultiArray&lt;2, FFTWComplex&lt;double&gt; &gt; fourier_kernel(fftwCorrespondingShapeR2C(src.shape()));</span>
<a name="l02163"></a>02163 <span class="comment">    int y0 = h / 2;</span>
<a name="l02164"></a>02164 <span class="comment">        </span>
<a name="l02165"></a>02165 <span class="comment">    for(int y=0; y&lt;fourier_kernel.shape(1); ++y)</span>
<a name="l02166"></a>02166 <span class="comment">        for(int x=0; x&lt;fourier_kernel.shape(0); ++x)</span>
<a name="l02167"></a>02167 <span class="comment">            fourier_kernel(x, y) = exp(-0.5*sq(x / double(w))) * exp(-0.5*sq((y-y0)/double(h)));</span>
<a name="l02168"></a>02168 <span class="comment"></span>
<a name="l02169"></a>02169 <span class="comment">    convolveFFT(src, fourier_kernel, dest);</span>
<a name="l02170"></a>02170 <span class="comment">    \endcode</span>
<a name="l02171"></a>02171 <span class="comment">*/</span>
<a name="l02172"></a>02172 doxygen_overloaded_function(template &lt;...&gt; <span class="keywordtype">void</span> <a class="code" href="group__MultiArrayConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae" title="Convolve an array with a kernel by means of the Fourier transform.">convolveFFT</a>)
<a name="l02173"></a>02173 
<a name="l02174"></a>02174 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;
<a name="l02175"></a>02175 <span class="keywordtype">void</span> 
<a name="l02176"></a>02176 <a class="code" href="group__MultiArrayConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae" title="Convolve an array with a kernel by means of the Fourier transform.">convolveFFT</a>(MultiArrayView&lt;N, Real, C1&gt; in, 
<a name="l02177"></a>02177             MultiArrayView&lt;N, Real, C2&gt; kernel,
<a name="l02178"></a>02178             MultiArrayView&lt;N, Real, C3&gt; out)
<a name="l02179"></a>02179 {
<a name="l02180"></a>02180     FFTWConvolvePlan&lt;N, Real&gt;(in, kernel, out).execute(in, kernel, out);
<a name="l02181"></a>02181 }
<a name="l02182"></a>02182 
<a name="l02183"></a>02183 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;
<a name="l02184"></a>02184 <span class="keywordtype">void</span> 
<a name="l02185"></a>02185 <a class="code" href="group__MultiArrayConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae" title="Convolve an array with a kernel by means of the Fourier transform.">convolveFFT</a>(MultiArrayView&lt;N, Real, C1&gt; in, 
<a name="l02186"></a>02186             MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C2&gt; kernel,
<a name="l02187"></a>02187             MultiArrayView&lt;N, Real, C3&gt; out)
<a name="l02188"></a>02188 {
<a name="l02189"></a>02189     FFTWConvolvePlan&lt;N, Real&gt;(in, kernel, out).execute(in, kernel, out);
<a name="l02190"></a>02190 }
<a name="l02191"></a>02191 <span class="comment"></span>
<a name="l02192"></a>02192 <span class="comment">/** \brief Convolve a complex-valued array by means of the Fourier transform.</span>
<a name="l02193"></a>02193 <span class="comment"></span>
<a name="l02194"></a>02194 <span class="comment">    See \ref convolveFFT() for details.</span>
<a name="l02195"></a>02195 <span class="comment">*/</span>
<a name="l02196"></a>02196 doxygen_overloaded_function(template &lt;...&gt; <span class="keywordtype">void</span> <a class="code" href="group__MultiArrayConvolutionFilters.html#ga014b4e7d6d5154d5ad83170c6cb547f6" title="Convolve a complex-valued array by means of the Fourier transform.">convolveFFTComplex</a>)
<a name="l02197"></a>02197 
<a name="l02198"></a>02198 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;
<a name="l02199"></a>02199 <span class="keywordtype">void</span>
<a name="l02200"></a>02200 <a class="code" href="group__MultiArrayConvolutionFilters.html#ga014b4e7d6d5154d5ad83170c6cb547f6" title="Convolve a complex-valued array by means of the Fourier transform.">convolveFFTComplex</a>(MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C1&gt; in,
<a name="l02201"></a>02201             MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C2&gt; kernel,
<a name="l02202"></a>02202             MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C3&gt; out,
<a name="l02203"></a>02203             <span class="keywordtype">bool</span> fourierDomainKernel)
<a name="l02204"></a>02204 {
<a name="l02205"></a>02205     FFTWConvolvePlan&lt;N, Real&gt;(in, kernel, out, fourierDomainKernel).execute(in, kernel, out);
<a name="l02206"></a>02206 }
<a name="l02207"></a>02207 <span class="comment"></span>
<a name="l02208"></a>02208 <span class="comment">/** \brief Convolve a real-valued array with a sequence of kernels by means of the Fourier transform.</span>
<a name="l02209"></a>02209 <span class="comment"></span>
<a name="l02210"></a>02210 <span class="comment">    See \ref convolveFFT() for details.</span>
<a name="l02211"></a>02211 <span class="comment">*/</span>
<a name="l02212"></a>02212 doxygen_overloaded_function(template &lt;...&gt; <span class="keywordtype">void</span> <a class="code" href="group__MultiArrayConvolutionFilters.html#gae2598869b328eae9ff709387e0b758a0" title="Convolve a real-valued array with a sequence of kernels by means of the Fourier transform.">convolveFFTMany</a>)
<a name="l02213"></a>02213 
<a name="l02214"></a>02214 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>Real, <span class="keyword">class </span>C1, 
<a name="l02215"></a>02215           <span class="keyword">class </span>KernelIterator, <span class="keyword">class </span>OutIterator&gt;
<a name="l02216"></a>02216 <span class="keywordtype">void</span> 
<a name="l02217"></a>02217 <a class="code" href="group__MultiArrayConvolutionFilters.html#gae2598869b328eae9ff709387e0b758a0" title="Convolve a real-valued array with a sequence of kernels by means of the Fourier transform.">convolveFFTMany</a>(MultiArrayView&lt;N, Real, C1&gt; in, 
<a name="l02218"></a>02218                 KernelIterator kernels, KernelIterator kernelsEnd,
<a name="l02219"></a>02219                 OutIterator outs)
<a name="l02220"></a>02220 {
<a name="l02221"></a>02221     FFTWConvolvePlan&lt;N, Real&gt; plan;
<a name="l02222"></a>02222     plan.initMany(in, kernels, kernelsEnd, outs);
<a name="l02223"></a>02223     plan.executeMany(in, kernels, kernelsEnd, outs);
<a name="l02224"></a>02224 }
<a name="l02225"></a>02225 <span class="comment"></span>
<a name="l02226"></a>02226 <span class="comment">/** \brief Convolve a complex-valued array with a sequence of kernels by means of the Fourier transform.</span>
<a name="l02227"></a>02227 <span class="comment"></span>
<a name="l02228"></a>02228 <span class="comment">    See \ref convolveFFT() for details.</span>
<a name="l02229"></a>02229 <span class="comment">*/</span>
<a name="l02230"></a>02230 doxygen_overloaded_function(template &lt;...&gt; <span class="keywordtype">void</span> <a class="code" href="group__MultiArrayConvolutionFilters.html#gaf555ec81ad059261e2bb8b5d03a0aa83" title="Convolve a complex-valued array with a sequence of kernels by means of the Fourier transform...">convolveFFTComplexMany</a>)
<a name="l02231"></a>02231 
<a name="l02232"></a>02232 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>Real, <span class="keyword">class </span>C1, 
<a name="l02233"></a>02233           <span class="keyword">class </span>KernelIterator, <span class="keyword">class </span>OutIterator&gt;
<a name="l02234"></a>02234 <span class="keywordtype">void</span> 
<a name="l02235"></a>02235 <a class="code" href="group__MultiArrayConvolutionFilters.html#gaf555ec81ad059261e2bb8b5d03a0aa83" title="Convolve a complex-valued array with a sequence of kernels by means of the Fourier transform...">convolveFFTComplexMany</a>(MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C1&gt; in, 
<a name="l02236"></a>02236                 KernelIterator kernels, KernelIterator kernelsEnd,
<a name="l02237"></a>02237                 OutIterator outs,
<a name="l02238"></a>02238                 <span class="keywordtype">bool</span> fourierDomainKernel)
<a name="l02239"></a>02239 {
<a name="l02240"></a>02240     FFTWConvolvePlan&lt;N, Real&gt; plan;
<a name="l02241"></a>02241     plan.initMany(in, kernels, kernelsEnd, outs, fourierDomainKernel);
<a name="l02242"></a>02242     plan.executeMany(in, kernels, kernelsEnd, outs);
<a name="l02243"></a>02243 }
<a name="l02244"></a>02244 <span class="comment"></span>
<a name="l02245"></a>02245 <span class="comment">//@}</span>
<a name="l02246"></a>02246 <span class="comment"></span>
<a name="l02247"></a>02247 } <span class="comment">// namespace vigra</span>
<a name="l02248"></a>02248 
<a name="l02249"></a>02249 <span class="preprocessor">#endif // VIGRA_MULTI_FFT_HXX</span>
</pre></div></div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.9.1 (Thu Sep 5 2013)
</i>
</tr>
</table>


</BODY>
</HTML>
