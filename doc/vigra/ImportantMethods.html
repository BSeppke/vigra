<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Important Methods</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://hci.iwr.uni-heidelberg.de/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="contents">
<table class="main_heading">
<tr>
<td width="100%">Important Methods 
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<div class="textblock"><p>In this part of the tutorial we'll introduce you to some important methods.</p>
<h2>subarray(p,q) </h2>
<p>This method is part of the MultiArrayView-Class and creates a rectangular subarray of your array between the points p and q, where p is included, q is not. Compared to the <code>bind </code>-method, subarray doesn't change the dimension. To give an example, let's say that you want to copy the upper-left subsquare of a 4x4-matrix (initialized with 1).</p>
<div class="fragment"><pre class="fragment">        <span class="comment">// copy the upper-left subsquare of a 4x4-matrix</span>
        <a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;2, int&gt;</a> _44Matrix(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(4,4));
        _44Matrix.init(1);
        <a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;2, int&gt;</a> subsquare = _44Matrix.<a class="code" href="classvigra_1_1MultiArrayView.html#a2271545a765e00427cb6c59f6c4d78e0">subarray</a>(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(0,0), <a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(2,2));
</pre></div><p>To determine the positions p and q, we use <code>Shape</code>. In this example we copy the element with the x,y-coordinates from 0 to 1. Subarray can be used to set elements as well. We now set the lower half of the 4x4-matrix to 0.</p>
<div class="fragment"><pre class="fragment">       <span class="comment">// change the elements of a subarray</span>
       _44Matrix.subarray(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(0,2),<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(4,4)) = 0;
</pre></div><p>In Image Processing you can use <code>subarray</code> to create a subimage of a given image. In the next example we create a half-sized subimage with the middle part of the original image: <a href="subimage_tutorial_8cxx-example.html">subimage_tutorial.cxx</a> <br/>
 The relevant part of this code is shown here:</p>
 <div class="fragment"><pre class="fragment">            <span class="comment">// write image data to MultiArray</span>
            MultiArray&lt;2, unsigned char&gt; imageArray(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(info.shape()));
            importImage(info, destImage(imageArray));

            <span class="comment">// calculate upper-left (x0,y0) and lower-right (x1,y1) position of subimage</span>
            <span class="keywordtype">int</span> x0 = info.width()/4;
            <span class="keywordtype">int</span> y0 = info.height()/4;
            <span class="keywordtype">int</span> x1 = info.width()-x0;
            <span class="keywordtype">int</span> y1 = info.height()-y0;

            <span class="comment">// create subimage around center for output</span>
            MultiArrayView&lt;2, unsigned char&gt; subimage = imageArray.subarray(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(x0,y0), <a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(x1, y1));
            
            <span class="comment">// write the subimage to the file given as second argument</span>
            <span class="comment">// the file type will be determined from the file name&#39;s extension</span>
            exportImage(srcImageRange(subimage), ImageExportInfo(argv[2]));
</pre></div></p>
<p>After reading the (here: gray scale) image data to an array we need to calculate the coordinates of our subimage. In this case we want to cut out the middle part of the image. Afterwards we write the subimage into a new array. Look at the results.</p>
<table  cellspacing="10">
<tr valign="bottom">
<td><div class="image">
<img src="lenna_small.gif" alt="lenna_small.gif"/>
<div class="caption">
input file</div></div>
  </td><td><div class="image">
<img src="lenna_sub.gif" alt="lenna_sub.gif"/>
<div class="caption">
subimage output file</div></div>
   </td></tr>
</table>
<hr/>
<h2>bind&lt;M&gt;(i) </h2>
<p>This method is part of the MultiArrayView-Class and binds the dimension M to the index i. As you probably remember, we tried to set the elements of a certain column or row of a matrix in the Indexing part. We used a for-loop, but it's getting more easily with the bind-method. Look at the following example. We initialize a 2x3-matrix with the value 0, set the second row to 5 and print the array eventually:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #include &lt;vigra/multi_array.hxx&gt;</span>
<span class="preprocessor">    #include &lt;iostream&gt;</span>

    <span class="keyword">using namespace </span>vigra;

    <span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv) {
        <span class="comment">// initialize 2x3-matrix and declare iterator</span>
        <a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;2, int&gt;</a> intArray(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(3,2));
        intArray.init(0);
        <a class="code" href="classvigra_1_1MultiArray.html#a35c955cacac6aacaa1e82874b1628865">vigra::MultiArray&lt;2, int&gt;::iterator</a> iter;

        <span class="comment">// set 1st row (equivalent to dimension 1 and index 0) to 5</span>
        intArray.bind&lt;1&gt;(0) = 5;

        <span class="comment">// print the array on console</span>
        <span class="keywordflow">for</span> (iter = intArray.<a class="code" href="classvigra_1_1MultiArray.html#ad69bd11391be1a1dba5c8202259664f8">begin</a>(); iter != intArray.<a class="code" href="classvigra_1_1MultiArray.html#acad38d52497a975bfb6f2f6acd76631f">end</a>(); iter++) {
            std::cout &lt;&lt; *iter &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>;
        }
        std::cout &lt;&lt; std::endl;

        <span class="keywordflow">return</span> 0;
    }
</pre></div><p>The output is:</p>
<div class="fragment"><pre class="fragment">
    5  5  5  0  0  0
    </pre></div><p>Binding a dimension reduces a N-dimensional array to dimension N-1. Furthermore you can initialize a lower-dimensional array with the bind-method.</p>
<div class="fragment"><pre class="fragment">        <span class="comment">// initialize new array with 3rd column of intArray</span>
        <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;1, int&gt;</a> lowArray = intArray.<a class="code" href="classvigra_1_1MultiArrayView.html#a5620a71abd33556ab702350b31b123da">bind</a>&lt;0&gt;(2);
</pre></div><p>The array <code> lowArray </code> contains the elements the 3rd column of intArray. At this point we have to distinguish between the classes <code> MultiArray </code> and <code> MultiArrayView </code>. MultiArray inherits from MultiArrayView and contains the memory management of the array. With MultiArrayView we can view the data stored in a MultiArray. The code above produces a copy of the 3rd column of intArray. If we change the elements of <code>lowArray</code> nothing happens to <code> intArray </code>.</p>
<div class="fragment"><pre class="fragment">        <span class="comment">// initialize new array with 3rd column of intArray</span>
        <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;1, int&gt;</a> lowArray = intArray.<a class="code" href="classvigra_1_1MultiArrayView.html#a5620a71abd33556ab702350b31b123da">bind</a>&lt;0&gt;(2);
        <span class="comment">// set elements of lowArray to ten</span>
        lowArray = 10;
        <span class="comment">// print lowArray</span>
        std::cout &lt;&lt; <span class="stringliteral">&quot;lowArray:\n&quot;</span>;
        <span class="keywordflow">for</span> (iter = lowArray.<a class="code" href="classvigra_1_1MultiArray.html#ad69bd11391be1a1dba5c8202259664f8">begin</a>(); iter != lowArray.<a class="code" href="classvigra_1_1MultiArray.html#acad38d52497a975bfb6f2f6acd76631f">end</a>(); iter++) {
            std::cout &lt;&lt; *iter &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>;
        }
        std::cout &lt;&lt; std::endl;
        <span class="comment">// print intArray</span>
        std::cout &lt;&lt; <span class="stringliteral">&quot;intArray after changing lowArray:\n&quot;</span>;
        <span class="keywordflow">for</span> (iter = intArray.<a class="code" href="classvigra_1_1MultiArray.html#ad69bd11391be1a1dba5c8202259664f8">begin</a>(); iter != intArray.<a class="code" href="classvigra_1_1MultiArray.html#acad38d52497a975bfb6f2f6acd76631f">end</a>(); iter++) {
            std::cout &lt;&lt; *iter &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>;
        }
        std::cout &lt;&lt; std::endl;
</pre></div><p>Output: </p>
<div class="fragment"><pre class="fragment">
    lowArray:
    10  10  
    intArray after changing lowArray:
    0  0  0  5  5  5  
    </pre></div><p>But if we use bind in combination with MultiArrayView instead, we don't get a copy of intArray's 3rd column, rather a view of it:</p>
<div class="fragment"><pre class="fragment">        <span class="comment">// initialize array view of 3rd column of intArray</span>
        <a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">vigra::MultiArrayView&lt;1, int, StridedArrayTag&gt;</a> lowArrayView = intArray.<a class="code" href="classvigra_1_1MultiArrayView.html#a5620a71abd33556ab702350b31b123da">bind</a>&lt;0&gt;(2);
        <span class="comment">// initialize ArrayView-Iterator</span>
        <a class="code" href="classvigra_1_1StridedScanOrderIterator.html" title="Sequential iterator for MultiArrayView.">vigra::MultiArrayView&lt;1,int&gt;::iterator</a> viewIter;
        <span class="comment">// set elements of lowArrayView to ten</span>
        lowArrayView = 10;
        <span class="comment">// print lowArrayView</span>
        std::cout &lt;&lt; <span class="stringliteral">&quot;lowArrayView:\n&quot;</span>;
        <span class="keywordflow">for</span> (viewIter = lowArrayView.<a class="code" href="classvigra_1_1MultiArrayView.html#ad69bd11391be1a1dba5c8202259664f8">begin</a>(); viewIter != lowArrayView.<a class="code" href="classvigra_1_1MultiArrayView.html#acad38d52497a975bfb6f2f6acd76631f">end</a>(); viewIter++) {
            std::cout &lt;&lt; *viewIter &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>;
        }
        std::cout &lt;&lt; std::endl;
        <span class="comment">// print intArray</span>
        std::cout &lt;&lt; <span class="stringliteral">&quot;intArray after changing lowArrayView:\n&quot;</span>;
        <span class="keywordflow">for</span> (iter = intArray.<a class="code" href="classvigra_1_1MultiArray.html#ad69bd11391be1a1dba5c8202259664f8">begin</a>(); iter != intArray.<a class="code" href="classvigra_1_1MultiArray.html#acad38d52497a975bfb6f2f6acd76631f">end</a>(); iter++) {
            std::cout &lt;&lt; *iter &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>;
        }
        std::cout &lt;&lt; std::endl;
</pre></div><p>Output: </p>
<div class="fragment"><pre class="fragment">
    lowArrayView:
    10  10  
    intArray after changing lowArrayView:
    0  0  10  5  5  10 
    </pre></div><p>In this case, changing lowArrayView causes changes in intArray because we changed a view of intArray and not a copy. An equivalent and easier way to change the 3rd column is analogous to the first example:</p>
<div class="fragment"><pre class="fragment">        <span class="comment">// set 3rd column to ten</span>
        intArray.bind&lt;0&gt;(2) = 10;
</pre></div><p>NumPy-Users know the bind mechanism as "slicing". In the example above they had written: </p>
<div class="fragment"><pre class="fragment">
    intArray[:,2] = 10      // NumPy-equivalent of bind
    </pre></div><p>Moving on to Image Processing we'll give an example how you can flip an image by using bind. We save a gray scale image in a 2-dimensional array called <code> imageArray </code>. Then we initalize a new array <code> newImageArray </code> of the same dimension and size and set the first row of <code> newImageArray </code> to the values of the last row of <code> imageArray </code>, the second row to the values of the second last row and so on. Hence, we flip the image top to bottom.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;vigra/multi_array.hxx&gt;</span>
<span class="preprocessor">#include &lt;vigra/stdimage.hxx&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="impex_8hxx.html" title="image import and export functions">vigra/impex.hxx</a>&gt;</span>

<span class="keyword">using namespace </span>vigra; 


<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv) {
    <span class="keywordflow">if</span>(argc != 3) {
        std::cout &lt;&lt; <span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; infile outfile&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;(supported formats: &quot;</span> &lt;&lt; <a class="code" href="group__VigraImpex.html#ga1f42a533f86021968b8ca4d9d9644279" title="List the image formats VIGRA can read and write.">vigra::impexListFormats</a>() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;
        
        <span class="keywordflow">return</span> 1;
    }

    <span class="keywordflow">try</span> {
        <a class="code" href="classvigra_1_1ImageImportInfo.html" title="Argument object for the function importImage().">vigra::ImageImportInfo</a> info(argv[1]);
        
        <span class="keywordflow">if</span>(info.isGrayscale()) {
            <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;2, unsigned char&gt;</a> imageArray(info.shape());
            <a class="code" href="group__VigraImpex.html#ga01aca6d5278dab14e11aef62e746e63e" title="Read the image specified by the given vigra::ImageImportInfo object.">importImage</a>(info, destImage(imageArray));
            <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;2, unsigned char&gt;</a> newImageArray(info.shape());

            <span class="comment">// mirror the image horizontally </span>
            <span class="comment">// info.height()-1 is equal to the index of the last row</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;info.height(); i++) {           
                    newImageArray.<a class="code" href="classvigra_1_1MultiArrayView.html#a5620a71abd33556ab702350b31b123da">bind</a>&lt;1&gt;(i) = imageArray.bind&lt;1&gt;(info.height()-(i+1));
            }
            
            <a class="code" href="group__VigraImpex.html#gabd7976d498abce467cd17989176133e3" title="Write an image given a vigra::ImageExportInfo object.">exportImage</a>(srcImageRange(newImageArray), <a class="code" href="classvigra_1_1ImageExportInfo.html" title="Argument object for the function exportImage().">vigra::ImageExportInfo</a>(argv[2]));
        }
        <span class="keywordflow">else</span> {
            std::cout &lt;&lt; <span class="stringliteral">&quot;no gray scale image&quot;</span> &lt;&lt; std::endl;
        }
    }
    <span class="keywordflow">catch</span> (vigra::StdException &amp; e) {
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
        <span class="keywordflow">return</span> 1;
    }
    
    <span class="keywordflow">return</span> 0;
}

</pre></div><p>This code needs an infile and an outfile as arguments. For this example, just the commented for-loop is important. The rest contains the code for ImageInputOutput and is explained in that part of the Tutorial. We bind dimension 1 to fix the y-coordinate. To flip left to right you have to fix the x-coordinate, so bind dimension 0. <br/>
 Here you can see what happens to an input file:</p>
<table  cellspacing="10">
<tr valign="bottom">
<td><div class="image">
<img src="lenna_small.gif" alt="lenna_small.gif"/>
<div class="caption">
input file</div></div>
  </td><td><div class="image">
<img src="lenna_mirror.gif" alt="lenna_mirror.gif"/>
<div class="caption">
mirrored output file</div></div>
 </td><td></td></tr>
</table>
<p>A detailed example is given here: <a href="mirror_8cxx-example.html">mirror.cxx</a> There you can flip RGB-images as well and decide whether to flip top to bottom (horizontal) or left to right (vertical).</p>
<p>You don't need to implement a method like this because VIGRA already provides the <code> vigra::reflectimage() </code> - method.</p>
<p>Furthermore there are some special bind-methods:</p>
<dl>
<dt>bindAt(M,i)  </dt>
<dd>equivalent to bind&lt;M&gt;(i)  </dd>
<dt>bindInner(i)  </dt>
<dd>if i is an <code> integer </code>, the innermost dimension is fixed to i, if i is a <code>TinyVector </code> of size M, then the M innermost dimensions are fixed to the values of the vector  </dd>
<dt>bindOuter(i)  </dt>
<dd>if i is an <code> integer </code>, the outmost dimension is fixed to i, if i is a <code>TinyVector </code> of size M, then the M outmost dimensions are fixed to the values of the vector  </dd>
</dl>
<p>See <a class="el" href="classvigra_1_1MultiArrayView.html">vigra::MultiArrayView</a> for a detailed description and examples.</p>
<hr/>
<h2><a class="el" href="group__LinearAlgebraFunctions.html#ga38a88300083908488d85348c0cf4d3ff">transpose()</a> </h2>
<p><code> <a class="el" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">vigra::MultiArrayView</a> </code> class provides a method to transpose a N-dimensional array. Regarding matrices (2-dimensional arrays) this operation is well known. As explained with the <code> bind&lt;M&gt;(i) </code> method, it is possible to make a transposed copy of a matrix or just to create a transposed view. For usage of <a class="el" href="group__LinearAlgebraFunctions.html#ga38a88300083908488d85348c0cf4d3ff">transpose()</a> and the difference between copy and view, see the following example. In the first part of the example we implement some print-method to make the code more readable.</p>
 <div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;vigra/multi_array.hxx&gt;</span>
<span class="preprocessor">#include &lt;vigra/linear_algebra.hxx&gt;</span>

<span class="keyword">using namespace </span>vigra;

<span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> T, <span class="keyword">class</span> Str<span class="keywordtype">id</span>e&gt;
<span class="keywordtype">void</span> print(<a class="code" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray.">MultiArrayView&lt;N, T, Stride&gt;</a> array) 
{
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvigra_1_1StridedScanOrderIterator.html" title="Sequential iterator for MultiArrayView.">MultiArrayView&lt;N, T, Stride&gt;::iterator</a> iterator;
    
    <span class="keywordflow">for</span> (iterator i = array.<a class="code" href="classvigra_1_1MultiArrayView.html#ad69bd11391be1a1dba5c8202259664f8">begin</a>(); i != array.<a class="code" href="classvigra_1_1MultiArrayView.html#acad38d52497a975bfb6f2f6acd76631f">end</a>(); ++i) {
        std::cout &lt;&lt; *i &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
    }
    std::cout &lt;&lt; std::endl;
}

<span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv) {

    <span class="comment">// initialize array</span>
    <a class="code" href="classvigra_1_1MultiArray.html">MultiArray&lt;2, int&gt;</a> intarray(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b" title="shape type for MultiArray&lt;2, T&gt;">Shape2</a>(4,4));
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; intarray.size(); i++) {
        intarray[i] = i % intarray.shape(0);
    }

    std::cout &lt;&lt; <span class="stringliteral">&quot;intarray:\n&quot;</span>;
    print(intarray);

    <span class="comment">// create a transposed array and a transposed view</span>
    <a class="code" href="classvigra_1_1MultiArray.html">MultiArray&lt;2, int&gt;</a> transarray = intarray.<a class="code" href="classvigra_1_1MultiArrayView.html#af54479ad2ee57be8181f50013864cc33">transpose</a>();
    <a class="code" href="classvigra_1_1MultiArrayView.html">MultiArrayView&lt;2, int&gt;</a> transarrayView = intarray.<a class="code" href="classvigra_1_1MultiArrayView.html#af54479ad2ee57be8181f50013864cc33">transpose</a>();

    std::cout &lt;&lt; <span class="stringliteral">&quot;transarray:\n&quot;</span>;
    print(transarray);
    std::cout &lt;&lt; <span class="stringliteral">&quot;transArrayView:\n&quot;</span>;
    print(transarrayView);

    <span class="comment">// set transarray to 5    </span>
    transarray = 5;
    std::cout &lt;&lt; <span class="stringliteral">&quot;intarray after setting transarray to 5:\n&quot;</span>;
    print(intarray);

    <span class="comment">// set transarrayView to 5</span>
    transarrayView = 5;
    std::cout &lt;&lt; <span class="stringliteral">&quot;intarray after setting transarrayView to 5:\n&quot;</span>;
    print(intarray);
    <span class="keywordflow">return</span> 0;
}
</pre></div></p>
<p>The output is:</p>
<div class="fragment"><pre class="fragment">
    intarray:
    0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3 
    transarray:
    0 0 0 0 1 1 1 1 2 2 2 2 3 3 3 3 
    transArrayView:
    0 0 0 0 1 1 1 1 2 2 2 2 3 3 3 3 
    intarray after setting transarray to 5:
    0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3 
    intarray after setting transarrayView to 5:
    5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 
    </pre></div><p>As already mentioned it is possible to transpose an array of arbitrary number of dimensions. In this case, the innermost dimension is swapped with the outermost, the 2nd innermost with the 2nd outermost and so on... In the following example we transpose a 5D array and print out its shape.</p>
 <div class="fragment"><pre class="fragment">    <span class="comment">// transposing a 5D array</span>
    <span class="comment">// instantiate 5D array</span>
    MultiArray&lt;5, int&gt; array5D(<a class="code" href="group__MultiIteratorGroup.html#ga5eb712151ca3fc644d569dee5723f67c" title="shape type for MultiArray&lt;5, T&gt;">Shape5</a>(1,2,3,4,5));

    <span class="comment">// print the shape of the original array</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;Shape of Array5D:\n&quot;</span>;
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 5; i++) {
        std::cout &lt;&lt; array5D.shape(i);
    }
    std::cout &lt;&lt; std::endl;

    <span class="comment">// transpose array</span>
    MultiArrayView&lt;5, int&gt; arrayview5D = array5D.transpose();

    <span class="comment">// print the shape of transposed array</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;Shape of transposed Array5D:\n&quot;</span>;
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 5; i++) {
        std::cout &lt;&lt; arrayview5D.shape(i);
    }
    std::cout &lt;&lt; std::endl;
</pre></div></p>
<p>The output is:</p>
<div class="fragment"><pre class="fragment">
    Shape of Array5D:
    12345
    Shape of transposed Array5D:
    54321
    </pre></div><p><b>Remark:</b> You probably think, that the transpose-method is quite inefficient because every array element has to be copied. This not true. For a transposed view of an array, you just need to change the strides.</p>
<p>An image can be transposed like this:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;vigra/multi_array.hxx&gt;</span>
<span class="preprocessor">#include &lt;vigra/stdimage.hxx&gt;</span>
<span class="preprocessor">#include &quot;<a class="code" href="impex_8hxx.html" title="image import and export functions">vigra/impex.hxx</a>&quot;</span>

<span class="keyword">using namespace </span>vigra; 


<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv) {
    
    <span class="comment">// read image given as first argument</span>
    <a class="code" href="classvigra_1_1ImageImportInfo.html" title="Argument object for the function importImage().">vigra::ImageImportInfo</a> imageInfo(argv[1]);

    <span class="comment">// instantiate array for image data</span>
    vigra:<a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">MultiArray&lt;2, unsigned char&gt;</a> imageArray(imageInfo.shape());

    <span class="comment">// copy image data into array</span>
    <a class="code" href="group__VigraImpex.html#ga01aca6d5278dab14e11aef62e746e63e" title="Read the image specified by the given vigra::ImageImportInfo object.">importImage</a>(imageInfo, destImage(imageArray));

    <span class="comment">// transpose image</span>
    imageArray = imageArray.transpose();

    <span class="comment">// write image data to the file given as second argument</span>
    <a class="code" href="group__VigraImpex.html#gabd7976d498abce467cd17989176133e3" title="Write an image given a vigra::ImageExportInfo object.">exportImage</a>(srcImageRange(imageArray), <a class="code" href="classvigra_1_1ImageExportInfo.html" title="Argument object for the function exportImage().">vigra::ImageExportInfo</a>(argv[2]));

    <span class="keywordflow">return</span> 0;
}
</pre></div><p>The result is:</p>
<table  cellspacing="10">
<tr valign="bottom">
<td><div class="image">
<img src="lenna_small.gif" alt="lenna_small.gif"/>
<div class="caption">
input file</div></div>
  </td><td><div class="image">
<img src="lenna_transposed.gif" alt="lenna_transposed.gif"/>
<div class="caption">
output file</div></div>
   </td></tr>
</table>
<p>In VIGRA, there is already a method <code><a class="el" href="group__GeometricTransformations.html#ga50e76dbde3e1b541755604f72e9eb090" title="Transpose an image over the major or minor diagonal.">vigra::transposeImage</a>(...)</code>. The difference is, that transposeImage changes the whole image data, whereas transpose just changes the strides.</p>
<p>Transposing an array changes the direction of the StridedScanOrderIterator. Imagine a 3x4- matrix. ScanOrder means that we iterate from left to right, row by row. Now, let's transpose the matrix to a 4x3-matrix. If this transposed array is just a View and we iterate using ScanOrder, it means that we iterate top to bottom, column by column in the original array.</p>
<hr/>
<h2>permuteDimensions(vector) / transpose(vector) </h2>
<p><b> Note: </b> The usage of <code> permuteDimensions() </code> and <code> <a class="el" href="group__LinearAlgebraFunctions.html#ga38a88300083908488d85348c0cf4d3ff">transpose()</a> </code> with a vector argument is completely equivalent.</p>
<p>An augmentation of transposing an array is to permute the dimensions by an arbitrary permutation. In two dimensions, transpose and permuteDimensions are equal. The method needs a vector that contains the permutation. The length of the vector is equal to the number of array dimensions. The first value of the vector contains the dimension of the original array that should be now the first dimension and so on. In the following example we want to permute an array of shape (1,2,3,4) to an array of shape (2,3,4,1). Remember, that VIGRA counts the dimensions from 0:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;vigra/multi_array.hxx&gt;</span>
<span class="preprocessor">#include &lt;vigra/linear_algebra.hxx&gt;</span>

<span class="keyword">using namespace </span>vigra;

<span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv) {

    <span class="comment">// initialize array</span>
    <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;4, int&gt;</a> intarray(<a class="code" href="group__MultiIteratorGroup.html#ga32d5611234a997a33e239ff31b773628" title="shape type for MultiArray&lt;4, T&gt;">Shape4</a>(1,2,3,4));
    
    <span class="comment">// print the shape of the original array</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;Shape of intarray:\n&quot;</span>;
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; intarray.shape().size(); i++) {
        std::cout &lt;&lt; intarray.size(i);
    }
    std::cout &lt;&lt; std::endl;

    <span class="comment">// permute dimensions</span>
    <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;4, int&gt;</a> permuted = intarray.<a class="code" href="classvigra_1_1MultiArrayView.html#a62a571ba62a9cc4b4f27af78b20a6d0e">permuteDimensions</a>(<a class="code" href="group__MultiIteratorGroup.html#ga32d5611234a997a33e239ff31b773628" title="shape type for MultiArray&lt;4, T&gt;">Shape4</a>(1,2,3,0));

    <span class="comment">// print the shape of the permuted array</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;Shape of permuted intarray:\n&quot;</span>;
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; permuted.<a class="code" href="classvigra_1_1MultiArrayView.html#a53c8f0d5c70f10f31fbc246cbe524e32">shape</a>().size(); i++) {
        std::cout &lt;&lt; permuted.<a class="code" href="classvigra_1_1MultiArrayView.html#a14c1df938ca1578ffc71bc9728b4e401">size</a>(i);
    }
    std::cout &lt;&lt; std::endl;

    <span class="keywordflow">return</span> 0;
}
</pre></div><p>The output is:</p>
<div class="fragment"><pre class="fragment">
    Shape of intarray:
    1234
    Shape of permuted intarray:
    2341
    </pre></div> </div></div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.9.0 (Mon Apr 29 2013)
</i>
</tr>
</table>


</BODY>
</HTML>
