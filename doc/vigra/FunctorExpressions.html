<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Functor Expressions</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{ 
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://hci.iwr.uni-heidelberg.de/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="contents">
<table class="main_heading">
<tr>
<td width="100%">Functor Expressions 
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<div class="textblock"><p>Simple automatic functor creation by means of expression templates (also known as a "lambda library"). Note, however, that the <a class="el" href="group__MultiMathModule.html">vigra::multi_math</a> module offers similar functionality with an easier syntax.</p>
<p><b>#include</b> &lt;<a class="el" href="functorexpression_8hxx_source.html">vigra/functorexpression.hxx</a>&gt;<br/>
 Namespace: vigra::functor</p>
<p><b> Motivation</b></p>
<p>Many generic algorithms are made more flexible by means of functors which define part of the algorithms' behavior according to the needs of a specific situation. For example, we can apply an exponential to each pixel by passing a pointer to the <code>exp</code> function to <code><a class="el" href="group__TransformAlgo.html#gababa545b60bb7db13076648f83c6b314" title="Apply unary point transformation to each pixel.">transformImage()</a></code>:</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::FImage</a> src(w,h), dest(w,h);
    ... <span class="comment">// fill src</span>
    
    <a class="code" href="group__TransformAlgo.html#gababa545b60bb7db13076648f83c6b314" title="Apply unary point transformation to each pixel.">vigra::transformImage</a>(srcImageRange(src), destImage(dest), &amp;<a class="code" href="group__LinearAlgebraFunctions.html#ga2a9e01ae7ae7b39a618e9f4a6afaee5b">exp</a>);    
</pre></div><p>However, this only works for simple operations. If we wanted to apply the exponential to a scaled pixel value (i.e. we want to execute <code>exp(-beta*v)</code>), we first need to implement a new functor:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">struct </span>Exponential
    {
        Exponential(<span class="keywordtype">double</span> b)
        : beta(b)
        {}
        
        <span class="keyword">template</span> &lt;<span class="keyword">class</span> PixelType&gt;
        PixelType operator()(PixelType <span class="keyword">const</span>&amp; v)<span class="keyword"> const</span>
<span class="keyword">        </span>{
            <span class="keywordflow">return</span> <a class="code" href="group__LinearAlgebraFunctions.html#ga2a9e01ae7ae7b39a618e9f4a6afaee5b">exp</a>(-beta*v);
        }
        
        <span class="keywordtype">double</span> beta;
    };
</pre></div><p>This functor would be used like this:</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">double</span> beta =  ...;
    <a class="code" href="group__TransformAlgo.html#gababa545b60bb7db13076648f83c6b314" title="Apply unary point transformation to each pixel.">vigra::transformImage</a>(srcImageRange(src), destImage(dest), 
                   Exponential(beta));    
</pre></div><p>However, this approach has some disadvantages:</p>
<ul>
<li>
Writing a functor is more work then simply program the loop directly, i.e. non-generically. Programmers will tend to avoid generic constructs, if they require so much writing. </li>
<li>
Often, functors are only needed for a single expression. It is not desirable to get into the trouble of introducing and documenting a new class if that class is used only once. </li>
<li>
<p class="startli">Functors cannot be implemented directly at the point of use. Thus, to find out exactly what a functor is doing, one needs to look somewhere else. This complicates use and maintenance ot generic code.</p>
<p class="endli"></p>
</li>
</ul>
<p>Therefore, it is necessary to provide a means to generate functors on the fly where they are needed. The C++ standard library contains so called "functor combinators" that allow to construct complicated functors from simpler ones. The above problem "apply exp(-beta*v) to every pixel" would be solved like this:</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">float</span> beta = ...;
    
    <a class="code" href="group__TransformAlgo.html#gababa545b60bb7db13076648f83c6b314" title="Apply unary point transformation to each pixel.">vigra::transformImage</a>(srcImageRange(src), destImage(dest), 
                   std::compose1(std::ptr_fun(<a class="code" href="group__LinearAlgebraFunctions.html#ga2a9e01ae7ae7b39a618e9f4a6afaee5b">exp</a>),
                                 std::bind1st(std::multiplies&lt;float&gt;(), -beta)));
</pre></div><p>I won't go into details on how this works. Suffice it to say that this technique requires a functional programming style that is unfamiliar to many programmers, and thus leads to code that is difficult to understand. Moreover, this technique has some limitations that prevent certain expressions from being implementable this way. Therefore, VIGRA provides a better and simpler means to create functors on the fly.</p>
<p><b> Automatic Functor Creation</b></p>
<p>Automatic functor creation in VIGRA is based on a technique called <a href="http://extreme.indiana.edu/~tveldhui/papers/Expression-Templates/exprtmpl.html">Expression Templates</a>. This means that C++ operators are overloaded so that they don't execute the specified operation directly, but instead produce a functor which will later calculate the result. This technique has the big advantage that the familiar operator notation can be used, while all the flexibility of generic programming is preserved.</p>
<p>The above problem "apply &lt;TT&gt;exp(-beta*v)&lt;/TT&gt; to every pixel" will be solved like this:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">using namespace </span>vigra::functor;
    
    <span class="keywordtype">float</span> beta = ...;
    
    <a class="code" href="group__TransformAlgo.html#gababa545b60bb7db13076648f83c6b314" title="Apply unary point transformation to each pixel.">transformImage</a>(srcImageRange(src), destImage(dest), 
                   <a class="code" href="group__LinearAlgebraFunctions.html#ga2a9e01ae7ae7b39a618e9f4a6afaee5b">exp</a>(Param(-beta)*Arg1()));
</pre></div><p>Here, four expression templates have been used to create the desired functor:</p>
<dl>
<dt><b><code>Param(-beta):</code></b></dt>
<dd><p class="startdd">creates a functor that represents a constant (<code>-beta</code> in this case)</p>
<p class="enddd"></p>
</dd>
<dt><b><code>Arg1():</code></b></dt>
<dd><p class="startdd">represents the first argument of the expression (i.e. the pixels of image <code>src</code> in the example). Likewise, <code>Arg2()</code> and <code>Arg3()</code> are defined to represent more arguments. These are needed for algorithms that have multiple input images, such as <a class="el" href="group__CombineAlgo.html#gaccf94cfa4b47ceb10e08dabe668fce23">combineTwoImages()</a> and <a class="el" href="group__CombineAlgo.html#ga9bbc3b2f05707a6d4734f5f63c3884e2">combineThreeImages()</a>.</p>
<p class="enddd"></p>
</dd>
<dt><b>* (multiplication):</b></dt>
<dd><p class="startdd">creates a functor that returns the product of its arguments. Likewise, the other C++ operators (i.e. <code>+, -, *, /, %, ==, !=, &lt;, &lt;=, &gt;, &gt;=, &amp;&amp;, ||, &amp;, |, ^, !, ~</code>) are overloaded.</p>
<p class="enddd"></p>
</dd>
<dt><b><code><a class="el" href="group__LinearAlgebraFunctions.html#ga2a9e01ae7ae7b39a618e9f4a6afaee5b">exp()</a>:</code></b></dt>
<dd><p class="startdd">creates a functor that takes the exponential of its argument. Likewise, the other algebraic functions (i.e. <code>sq, sqrt, exp, log, log10, sin, asin, cos, acos, tan, atan, abs, floor, ceil, pow, atan2, fmod, min, max</code>) are overloaded.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>We will explain additional capabilities of the functor creation mechanism by means of examples.</p>
<p>The same argument can be used several times in the expression. For example, to calculate the gradient magnitude from the components of the gradient vector, you may write:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">using namespace </span>vigra::functor;
    
    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::FImage</a> gradient_x(w,h), gradient_y(w,h), magnitude(w,h);
    ... <span class="comment">// calculate gradient_x and gradient_y</span>
    
    <a class="code" href="group__CombineAlgo.html#gaccf94cfa4b47ceb10e08dabe668fce23" title="Combine two source images into destination image.">combineTwoImages</a>(srcImageRange(gradient_x), srcImage(gradient_y),
                     destImage(magnitude),
                     <a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c" title="square root.">sqrt</a>(Arg1()*Arg1() + Arg2()*Arg2()));
</pre></div><p>It is also possible to build other functions into functor expressions. Suppose you want to apply <code>my_complicated_function()</code> to the sum of two images:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">using namespace </span>vigra::functor;
    
    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::FImage</a> src1(w,h), src2(w,h), dest(w,h);
    
    <span class="keywordtype">double</span> my_complicated_function(<span class="keywordtype">double</span>);
    
    <a class="code" href="group__CombineAlgo.html#gaccf94cfa4b47ceb10e08dabe668fce23" title="Combine two source images into destination image.">combineTwoImages</a>(srcImageRange(src1), srcImage(src2), destImage(dest),
                     applyFct(&amp;my_complicated_function, Arg1()+Arg2()));    
</pre></div><p>[Note that the arguments of the wrapped function are passed as additional arguments to <code>applyFct()</code>]</p>
<p>You can implement conditional expression by means of the <code>ifThenElse()</code> functor. It corresponds to the "? :" operator that cannot be overloaded. <code>ifThenElse()</code> can be used, for example, to threshold an image:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">using namespace </span>vigra::functor;
    
    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::FImage</a> src(w,h), thresholded(w,h);
    ...<span class="comment">// fill src</span>
    
    <span class="keywordtype">float</span> threshold = ...;
    
    <a class="code" href="group__TransformAlgo.html#gababa545b60bb7db13076648f83c6b314" title="Apply unary point transformation to each pixel.">transformImage</a>(srcImageRange(src), destImage(thresholded),
                   ifThenElse(Arg1() &lt; Param(threshold),
                              Param(0.0),    <span class="comment">// yes branch</span>
                              Param(1.0))    <span class="comment">// no  branch</span>
                  );
</pre></div><p>You can use the <code>Var()</code> functor to assign values to a variable (<code>=, +=, -=, *=, /=</code>&#160; are supported). For example, the average gray value of the image is calculated like this:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">using namespace </span>vigra::functor;
    
    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::FImage</a> src(w,h);
    ...<span class="comment">// fill src</span>
    
    <span class="keywordtype">double</span> <a class="code" href="group__TinyVectorOperators.html#ga202143b556e7388b4895f457317eb086" title="sum of the vector&#39;s elements">sum</a> = 0.0;
    
    <a class="code" href="group__InspectAlgo.html#gaa055bcaf71c209fdeb006fe3e44b0452" title="Apply read-only functor to every pixel in the image.">inspectImage</a>(srcImageRange(src), Var(<a class="code" href="group__TinyVectorOperators.html#ga202143b556e7388b4895f457317eb086" title="sum of the vector&#39;s elements">sum</a>) += Arg1());
    
    std::cout &lt;&lt; <span class="stringliteral">&quot;Average: &quot;</span> &lt;&lt; (<a class="code" href="group__TinyVectorOperators.html#ga202143b556e7388b4895f457317eb086" title="sum of the vector&#39;s elements">sum</a> / (w*h)) &lt;&lt; std::endl;
</pre></div><p>For use in <a class="el" href="group__InspectAlgo.html#gaa055bcaf71c209fdeb006fe3e44b0452">inspectImage()</a> and its relatives, there is a second conditional functor <code>ifThen()</code> that emulates the <code>if()</code> statement and does not return a value. Using <code>ifThen()</code>, we can calculate the size of an image region:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">using namespace </span>vigra::functor;
    
    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::IImage</a> label_image(w,h);
    ...<span class="comment">// mark regions by labels in label_image</span>
    
    <span class="keywordtype">int</span> region_label = ...; <span class="comment">// the region we want to inspect</span>
    <span class="keywordtype">int</span> size = 0;
    
    <a class="code" href="group__InspectAlgo.html#gaa055bcaf71c209fdeb006fe3e44b0452" title="Apply read-only functor to every pixel in the image.">inspectImage</a>(srcImageRange(label_image),
                 ifThen(Arg1() == Param(region_label),
                        Var(size) += Param(1)));
                        
    std::cout &lt;&lt; <span class="stringliteral">&quot;Size of region &quot;</span> &lt;&lt; region_label &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; size &lt;&lt; std::endl;
</pre></div><p>Often, we want to execute several commands in one functor. This can be done by means of the overloaded <code>operator,()</code> ("operator comma"). Expressions separated by a comma will be executed in succession. We can thus simultaneously find the size and the average gray value of a region:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">using namespace </span>vigra::functor;
    
    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::FImage</a> src(w,h);
    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::IImage</a> label_image(w,h);
    ...<span class="comment">// segment src and mark regions in label_image</span>
    
    <span class="keywordtype">int</span> region_label = ...; <span class="comment">// the region we want to inspect</span>
    <span class="keywordtype">int</span> size = 0;
    <span class="keywordtype">double</span> <a class="code" href="group__TinyVectorOperators.html#ga202143b556e7388b4895f457317eb086" title="sum of the vector&#39;s elements">sum</a> = 0.0;
    
    <a class="code" href="group__InspectAlgo.html#gad70a53a9ab68eab8c6d3371b1269b6ac" title="Apply read-only functor to every pixel of both images.">inspectTwoImages</a>(srcImageRange(src), srcImage(label_image),
                     ifThen(Arg2() == Param(region_label),
                     (
                        Var(size) += Param(1), <span class="comment">// the comma operator is invoked</span>
                        Var(<a class="code" href="group__TinyVectorOperators.html#ga202143b556e7388b4895f457317eb086" title="sum of the vector&#39;s elements">sum</a>) += Arg1()
                     )));

    std::cout &lt;&lt; <span class="stringliteral">&quot;Region &quot;</span> &lt;&lt; region_label &lt;&lt; <span class="stringliteral">&quot;: size = &quot;</span> &lt;&lt; size &lt;&lt; 
                                              <span class="stringliteral">&quot;, average = &quot;</span> &lt;&lt; <a class="code" href="group__TinyVectorOperators.html#ga202143b556e7388b4895f457317eb086" title="sum of the vector&#39;s elements">sum</a> / size &lt;&lt; std::endl;
</pre></div><p>[Note that the list of comma-separated expressions must be enclosed in parentheses.]</p>
<p>A comma separated list of expressions can also be applied in the context of <a class="el" href="group__TransformAlgo.html#gababa545b60bb7db13076648f83c6b314">transformImage()</a> and its cousins. Here, a general rule of C++ applies: The return value of a comma expression is the value of its last subexpression. For example, we can initialize an image so that each pixel contains its address in scan order:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">using namespace </span>vigra::functor;
    
    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::IImage</a> img(w,h);
    
    <span class="keywordtype">int</span> count = -1;
    
    <a class="code" href="group__InitAlgo.html#gabae1fd1bcc1be861f086b347fefbf355" title="Write the result of a functor call to every pixel in an image or rectangular ROI.">initImageWithFunctor</a>(destImageRange(img),
                         (
                              Var(count) += Param(1),  
                              Var(count)     <span class="comment">// this is the result of the comma expression</span>
                         ));
</pre></div><p>Further information about how this mechanism works can be found in <a href="http://hci.iwr.uni-heidelberg.de/vigra/documents/FunctorFactory.ps">this paper</a> (sorry, slightly out of date). </p>
</div></div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.9.1 (Thu Sep 5 2013)
</i>
</tr>
</table>


</BODY>
</HTML>
