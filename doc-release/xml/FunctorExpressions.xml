<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.1.2">
  <compounddef id="FunctorExpressions" kind="page">
    <compoundname>FunctorExpressions</compoundname>
    <title>Functor Expressions</title>
    <detaileddescription>
<para>Simple automatic functor creation by means of expression templates (also known as a &quot;lambda library&quot;).</para><para><bold>#include</bold> &lt;<ref refid="functorexpression_8hxx_source" kindref="compound">vigra/functorexpression.hxx</ref>&gt;<linebreak/>
 Namespace: vigra::functor</para><para><bold> Motivation</bold></para><para>Many generic algorithms are made more flexible by means of functors which define part of the algorithms&apos; behavior according to the needs of a specific situation. For example, we can apply an exponential to each pixel by passing a pointer to the <computeroutput>exp</computeroutput> function to <computeroutput><ref refid="group__TransformAlgo_1gababa545b60bb7db13076648f83c6b314" kindref="member">transformImage()</ref></computeroutput>:</para><para><programlisting><codeline><highlight class="normal"><ref refid="classvigra_1_1BasicImage" kindref="compound" tooltip="Fundamental class template for images.">vigra::FImage</ref><sp/>src(w,h),<sp/>dest(w,h);</highlight></codeline>
<codeline><highlight class="normal">...<sp/></highlight><highlight class="comment">//<sp/>fill<sp/>src</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__TransformAlgo_1gababa545b60bb7db13076648f83c6b314" kindref="member" tooltip="Apply unary point transformation to each pixel.">vigra::transformImage</ref>(srcImageRange(src),<sp/>destImage(dest),<sp/>&amp;<ref refid="group__LinearAlgebraFunctions_1ga2a9e01ae7ae7b39a618e9f4a6afaee5b" kindref="member">exp</ref>);<sp/><sp/><sp/><sp/></highlight></codeline>
</programlisting></para><para>However, this only works for simple operations. If we wanted to apply the exponential to a scaled pixel value (i.e. we want to execute <computeroutput>exp(-beta*v)</computeroutput>), we first need to implement a new functor:</para><para><programlisting><codeline><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Exponential</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Exponential(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>b)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>beta(b)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>PixelType&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PixelType<sp/>operator()(PixelType<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>v)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="group__LinearAlgebraFunctions_1ga2a9e01ae7ae7b39a618e9f4a6afaee5b" kindref="member">exp</ref>(-beta*v);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>beta;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>This functor would be used like this:</para><para><programlisting><codeline><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>beta<sp/>=<sp/><sp/>...;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__TransformAlgo_1gababa545b60bb7db13076648f83c6b314" kindref="member" tooltip="Apply unary point transformation to each pixel.">vigra::transformImage</ref>(srcImageRange(src),<sp/>destImage(dest),<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Exponential(beta));<sp/><sp/><sp/><sp/></highlight></codeline>
</programlisting></para><para>However, this approach has some disadvantages:</para><para><itemizedlist>
<listitem>
<para>Writing a functor is more work then simply program the loop directly, i.e. non-generically. Programmers will tend to avoid generic constructs, if they require so much writing. </para></listitem>
<listitem>
<para>Often, functors are only needed for a single expression. It is not desirable to get into the trouble of introducing and documenting a new class if that class is used only once. </para></listitem>
<listitem>
<para>Functors cannot be implemented directly at the point of use. Thus, to find out exactly what a functor is doing, one needs to look somewhere else. This complicates use and maintenance ot generic code.</para><para></para></listitem>
</itemizedlist>
</para><para>Therefore, it is necessary to provide a means to generate functors on the fly where they are needed. The C++ standard library contains so called &quot;functor combinators&quot; that allow to construct complicated functors from simpler ones. The above problem &quot;apply &lt;TT&gt;exp(-beta*v)&lt;/TT&gt; to every pixel&quot; would be solved like this:</para><para><programlisting><codeline><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>beta<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__TransformAlgo_1gababa545b60bb7db13076648f83c6b314" kindref="member" tooltip="Apply unary point transformation to each pixel.">vigra::transformImage</ref>(srcImageRange(src),<sp/>destImage(dest),<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::compose1(std::ptr_fun(<ref refid="group__LinearAlgebraFunctions_1ga2a9e01ae7ae7b39a618e9f4a6afaee5b" kindref="member">exp</ref>),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::bind1st(std::multiplies&lt;float&gt;(),<sp/>-beta)));</highlight></codeline>
</programlisting></para><para>I won&apos;t go into details on how this works. Suffice it to say that this technique requires a functional programming style that is unfamiliar to many programmers, and thus leads to code that is difficult to understand. Moreover, this technique has some limitations that prevent certain expressions from being implementable this way. Therefore, VIGRA provides a better and simpler means to create functors on the fly.</para><para><bold> Automatic Functor Creation</bold></para><para>Automatic functor creation in VIGRA is based on a technique called <ulink url="http://extreme.indiana.edu/~tveldhui/papers/Expression-Templates/exprtmpl.html">Expression Templates</ulink>. This means that C++ operators are overloaded so that they don&apos;t execute the specified operation directly, but instead produce a functor which will later calculate the result. This technique has the big advantage that the familiar operator notation can be used, while all the flexibility of generic programming is preserved.</para><para>The above problem &quot;apply &lt;TT&gt;exp(-beta*v)&lt;/TT&gt; to every pixel&quot; will be solved like this:</para><para><programlisting><codeline><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal">vigra::functor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>beta<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__TransformAlgo_1gababa545b60bb7db13076648f83c6b314" kindref="member" tooltip="Apply unary point transformation to each pixel.">transformImage</ref>(srcImageRange(src),<sp/>destImage(dest),<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__LinearAlgebraFunctions_1ga2a9e01ae7ae7b39a618e9f4a6afaee5b" kindref="member">exp</ref>(Param(-beta)*Arg1()));</highlight></codeline>
</programlisting></para><para>Here, four expression templates have been used to create the desired functor:</para><para><variablelist>
<varlistentry><term><bold><computeroutput>Param(-beta):</computeroutput></bold></term></varlistentry>
<listitem><para>creates a functor that represents a constant (<computeroutput>-beta</computeroutput> in this case)</para><para></para></listitem>
<varlistentry><term><bold><computeroutput>Arg1():</computeroutput></bold></term></varlistentry>
<listitem><para>represents the first argument of the expression (i.e. the pixels of image <computeroutput>src</computeroutput> in the example). Likewise, <computeroutput>Arg2()</computeroutput> and <computeroutput>Arg3()</computeroutput> are defined to represent more arguments. These are needed for algorithms that have multiple input images, such as <ref refid="group__CombineAlgo_1gaccf94cfa4b47ceb10e08dabe668fce23" kindref="member">combineTwoImages()</ref> and <ref refid="group__CombineAlgo_1ga9bbc3b2f05707a6d4734f5f63c3884e2" kindref="member">combineThreeImages()</ref>.</para><para></para></listitem>
<varlistentry><term><bold>* (multiplication):</bold></term></varlistentry>
<listitem><para>creates a functor that returns the product of its arguments. Likewise, the other C++ operators (i.e. <computeroutput>+, -, *, /, %, ==, !=, &lt;, &lt;=, &gt;, &gt;=, &amp;&amp;, ||, &amp;, |, ^, !, ~</computeroutput>) are overloaded.</para><para></para></listitem>
<varlistentry><term><bold><computeroutput><ref refid="group__LinearAlgebraFunctions_1ga2a9e01ae7ae7b39a618e9f4a6afaee5b" kindref="member">exp()</ref>:</computeroutput></bold></term></varlistentry>
<listitem><para>creates a functor that takes the exponential of its argument. Likewise, the other algebraic functions (i.e. <computeroutput>sq, sqrt, exp, log, log10, sin, asin, cos, acos, tan, atan, abs, floor, ceil, pow, atan2, fmod, min, max</computeroutput>) are overloaded.</para><para></para></listitem>
</variablelist>
</para><para>We will explain additional capabilities of the functor creation mechanism by means of examples.</para><para>The same argument can be used several times in the expression. For example, to calculate the gradient magnitude from the components of the gradient vector, you may write:</para><para><programlisting><codeline><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal">vigra::functor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classvigra_1_1BasicImage" kindref="compound" tooltip="Fundamental class template for images.">vigra::FImage</ref><sp/>gradient_x(w,h),<sp/>gradient_y(w,h),<sp/>magnitude(w,h);</highlight></codeline>
<codeline><highlight class="normal">...<sp/></highlight><highlight class="comment">//<sp/>calculate<sp/>gradient_x<sp/>and<sp/>gradient_y</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__CombineAlgo_1gaccf94cfa4b47ceb10e08dabe668fce23" kindref="member" tooltip="Combine two source images into destination image.">combineTwoImages</ref>(srcImageRange(gradient_x),<sp/>srcImage(gradient_y),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>destImage(magnitude),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__FixedPointOperations_1ga22d75753836176f3d172f58be11ecc4c" kindref="member" tooltip="square root.">sqrt</ref>(Arg1()*Arg1()<sp/>+<sp/>Arg2()*Arg2()));</highlight></codeline>
</programlisting></para><para>It is also possible to build other functions into functor expressions. Suppose you want to apply <computeroutput>my_complicated_function()</computeroutput> to the sum of two images:</para><para><programlisting><codeline><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal">vigra::functor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classvigra_1_1BasicImage" kindref="compound" tooltip="Fundamental class template for images.">vigra::FImage</ref><sp/>src1(w,h),<sp/>src2(w,h),<sp/>dest(w,h);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>my_complicated_function(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__CombineAlgo_1gaccf94cfa4b47ceb10e08dabe668fce23" kindref="member" tooltip="Combine two source images into destination image.">combineTwoImages</ref>(srcImageRange(src1),<sp/>srcImage(src2),<sp/>destImage(dest),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>applyFct(&amp;my_complicated_function,<sp/>Arg1()+Arg2()));<sp/><sp/><sp/><sp/></highlight></codeline>
</programlisting></para><para>[Note that the arguments of the wrapped function are passed as additional arguments to <computeroutput>applyFct()</computeroutput>]</para><para>You can implement conditional expression by means of the <computeroutput>ifThenElse()</computeroutput> functor. It corresponds to the &quot;? :&quot; operator that cannot be overloaded. <computeroutput>ifThenElse()</computeroutput> can be used, for example, to threshold an image:</para><para><programlisting><codeline><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal">vigra::functor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classvigra_1_1BasicImage" kindref="compound" tooltip="Fundamental class template for images.">vigra::FImage</ref><sp/>src(w,h),<sp/>thresholded(w,h);</highlight></codeline>
<codeline><highlight class="normal">...</highlight><highlight class="comment">//<sp/>fill<sp/>src</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">float<sp/>threshold<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__TransformAlgo_1gababa545b60bb7db13076648f83c6b314" kindref="member" tooltip="Apply unary point transformation to each pixel.">transformImage</ref>(srcImageRange(src),<sp/>destImage(thresholded),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ifThenElse(Arg1()<sp/>&lt;<sp/>Param(threshold),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Param(0.0),<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>yes<sp/>branch</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Param(1.0))<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>no<sp/><sp/>branch</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>);</highlight></codeline>
</programlisting></para><para>You can use the <computeroutput>Var()</computeroutput> functor to assign values to a variable (<computeroutput>=, +=, -=, *=, /=</computeroutput><nonbreakablespace/> are supported). For example, the average gray value of the image is calculated like this:</para><para><programlisting><codeline><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal">vigra::functor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classvigra_1_1BasicImage" kindref="compound" tooltip="Fundamental class template for images.">vigra::FImage</ref><sp/>src(w,h);</highlight></codeline>
<codeline><highlight class="normal">...</highlight><highlight class="comment">//<sp/>fill<sp/>src</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">double<sp/><ref refid="group__TinyVectorOperators_1ga202143b556e7388b4895f457317eb086" kindref="member" tooltip="sum of the vector&amp;#39;s elements">sum</ref><sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__InspectAlgo_1gaa055bcaf71c209fdeb006fe3e44b0452" kindref="member" tooltip="Apply read-only functor to every pixel in the image.">inspectImage</ref>(srcImageRange(src),<sp/>Var(<ref refid="group__TinyVectorOperators_1ga202143b556e7388b4895f457317eb086" kindref="member" tooltip="sum of the vector&amp;#39;s elements">sum</ref>)<sp/>+=<sp/>Arg1());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Average:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>(<ref refid="group__TinyVectorOperators_1ga202143b556e7388b4895f457317eb086" kindref="member" tooltip="sum of the vector&amp;#39;s elements">sum</ref><sp/>/<sp/>(w*h))<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
</programlisting></para><para>For use in <ref refid="group__InspectAlgo_1gaa055bcaf71c209fdeb006fe3e44b0452" kindref="member">inspectImage()</ref> and its relatives, there is a second conditional functor <computeroutput>ifThen()</computeroutput> that emulates the <computeroutput>if()</computeroutput> statement and does not return a value. Using <computeroutput>ifThen()</computeroutput>, we can calculate the size of an image region:</para><para><programlisting><codeline><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal">vigra::functor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classvigra_1_1BasicImage" kindref="compound" tooltip="Fundamental class template for images.">vigra::IImage</ref><sp/>label_image(w,h);</highlight></codeline>
<codeline><highlight class="normal">...</highlight><highlight class="comment">//<sp/>mark<sp/>regions<sp/>by<sp/>labels<sp/>in<sp/>label_image</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">int<sp/>region_label<sp/>=<sp/>...;<sp/></highlight><highlight class="comment">//<sp/>the<sp/>region<sp/>we<sp/>want<sp/>to<sp/>inspect</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>size<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__InspectAlgo_1gaa055bcaf71c209fdeb006fe3e44b0452" kindref="member" tooltip="Apply read-only functor to every pixel in the image.">inspectImage</ref>(srcImageRange(label_image),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ifThen(Arg1()<sp/>==<sp/>Param(region_label),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Var(size)<sp/>+=<sp/>Param(1)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal">std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Size<sp/>of<sp/>region<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>region_label<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>size<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
</programlisting></para><para>Often, we want to execute several commands in one functor. This can be done by means of the overloaded <computeroutput>operator,()</computeroutput> (&quot;operator comma&quot;). Expressions separated by a comma will be executed in succession. We can thus simultaneously find the size and the average gray value of a region:</para><para><programlisting><codeline><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal">vigra::functor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classvigra_1_1BasicImage" kindref="compound" tooltip="Fundamental class template for images.">vigra::FImage</ref><sp/>src(w,h);</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classvigra_1_1BasicImage" kindref="compound" tooltip="Fundamental class template for images.">vigra::IImage</ref><sp/>label_image(w,h);</highlight></codeline>
<codeline><highlight class="normal">...</highlight><highlight class="comment">//<sp/>segment<sp/>src<sp/>and<sp/>mark<sp/>regions<sp/>in<sp/>label_image</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">int<sp/>region_label<sp/>=<sp/>...;<sp/></highlight><highlight class="comment">//<sp/>the<sp/>region<sp/>we<sp/>want<sp/>to<sp/>inspect</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>size<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/><ref refid="group__TinyVectorOperators_1ga202143b556e7388b4895f457317eb086" kindref="member" tooltip="sum of the vector&amp;#39;s elements">sum</ref><sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__InspectAlgo_1gad70a53a9ab68eab8c6d3371b1269b6ac" kindref="member" tooltip="Apply read-only functor to every pixel of both images.">inspectTwoImages</ref>(srcImageRange(src),<sp/>srcImage(label_image),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ifThen(Arg2()<sp/>==<sp/>Param(region_label),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Var(size)<sp/>+=<sp/>Param(1),<sp/></highlight><highlight class="comment">//<sp/>the<sp/>comma<sp/>operator<sp/>is<sp/>invoked</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Var(<ref refid="group__TinyVectorOperators_1ga202143b556e7388b4895f457317eb086" kindref="member" tooltip="sum of the vector&amp;#39;s elements">sum</ref>)<sp/>+=<sp/>Arg1()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>)));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Region<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>region_label<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;:<sp/>size<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>size<sp/>&lt;&lt;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;,<sp/>average<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/><ref refid="group__TinyVectorOperators_1ga202143b556e7388b4895f457317eb086" kindref="member" tooltip="sum of the vector&amp;#39;s elements">sum</ref><sp/>/<sp/>size<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
</programlisting></para><para>[Note that the list of comma-separated expressions must be enclosed in parentheses.]</para><para>A comma separated list of expressions can also be applied in the context of <ref refid="group__TransformAlgo_1gababa545b60bb7db13076648f83c6b314" kindref="member">transformImage()</ref> and its cousins. Here, a general rule of C++ applies: The return value of a comma expression is the value of its last subexpression. For example, we can initialize an image so that each pixel contains its address in scan order:</para><para><programlisting><codeline><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal">vigra::functor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classvigra_1_1BasicImage" kindref="compound" tooltip="Fundamental class template for images.">vigra::IImage</ref><sp/>img(w,h);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count<sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__InitAlgo_1gabae1fd1bcc1be861f086b347fefbf355" kindref="member" tooltip="Write the result of a functor call to every pixel in an image or rectangular ROI.">initImageWithFunctor</ref>(destImageRange(img),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Var(count)<sp/>+=<sp/>Param(1),<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Var(count)<sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>this<sp/>is<sp/>the<sp/>result<sp/>of<sp/>the<sp/>comma<sp/>expression</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>));</highlight></codeline>
</programlisting></para><para>Further information about how this mechanism works can be found in <ulink url="documents/FunctorFactory.ps">this paper</ulink> (sorry, slightly out of date). </para>    </detaileddescription>
  </compounddef>
</doxygen>
